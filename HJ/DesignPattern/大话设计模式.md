[TOC]


---

# 1. 23GOFæ€»è§ˆ

| åˆ†ç±»                   | ä½œç”¨                             | åŒ…å«æ¨¡å¼æ•° | è®°å¿†å£è¯€                             |
| ---------------------- | -------------------------------- | ---------- | ------------------------------------ |
| **åˆ›å»ºå‹(Creational)** | éšè—å¯¹è±¡åˆ›å»ºç»†èŠ‚, è§£è€¦å®ä¾‹åŒ–è¿‡ç¨‹ | 5          | **â€œåŸå•å»ºæŠ½æ–¹â€**                     |
| **ç»“æ„å‹(Structural)** | ç»„åˆç±»æˆ–å¯¹è±¡, å½¢æˆæ›´å¤§ç»“æ„       | 7          | **â€œé€‚æ¡¥ç»„, è£…å¤–äº«ä»£â€**               |
| **è¡Œä¸ºå‹(Behavioral)** | åˆ†é…èŒè´£, ç®¡ç†å¯¹è±¡é—´é€šä¿¡         | 11         | **â€œç­–æ¨¡è§‚, è¿­è´£å‘½, å¤‡çŠ¶è®¿, ä¸­ä»‹è§£â€** |

> ğŸ¯ **ç»ˆæå£è¯€(æ¨èèƒŒè¯µ): **  
> **â€œåˆ›äº”ç»“ä¸ƒè¡Œåä¸€, SOLIDæ˜¯æ ¹åŸº;   
> å·¥å‚å•ä¾‹å»ºåŸå‹, é€‚é…è£…é¥°ä»£ç†é½;   
> ç­–ç•¥è§‚å¯Ÿæ¨¡æ¿æ³•, å‘½ä»¤çŠ¶æ€è´£ä»»é“¾;   
> å¤‡å¿˜è®¿é—®ä¸­ä»‹è€…, è§£é‡Šç»„åˆäº«å…ƒæ¡¥ã€‚â€**

---

## ğŸ› ï¸ åˆ›å»ºå‹æ¨¡å¼(5ç§)

| æ¨¡å¼         | ç®€ä»‹                             | ç‰¹ç‚¹                                             | é«˜é¢‘é‡ç‚¹ |
| ------------ | -------------------------------- | ------------------------------------------------ | -------- |
| **å·¥å‚æ–¹æ³•** | å®šä¹‰åˆ›å»ºæ¥å£, å­ç±»å†³å®šå®ä¾‹åŒ–     | **å•ä¸€äº§å“çº¿**; â€œå»¶è¿Ÿåˆ°å­ç±»çš„ newâ€               | âœ…        |
| **æŠ½è±¡å·¥å‚** | åˆ›å»ºç›¸å…³äº§å“æ—, æ— éœ€æŒ‡å®šå…·ä½“ç±»   | **å¤šäº§å“æ—**; â€œå·¥å‚çš„å·¥å‚â€, éš¾æ‰©æ–°äº§å“, æ˜“æ‰©æ–°æ— | âœ…        |
| **å•ä¾‹**     | å…¨å±€å”¯ä¸€å®ä¾‹, æä¾›å…¨å±€è®¿é—®ç‚¹     | **å”¯ä¸€**; æ§åˆ¶èµ„æº(å¦‚é…ç½®ã€è¿æ¥æ± );              | âœ…        |
| **å»ºé€ è€…**   | åˆ†æ­¥æ„é€ å¤æ‚å¯¹è±¡, åˆ†ç¦»æ„é€ ä¸è¡¨ç¤º | **è£…é…çº¿**; å¼ºè°ƒè¿‡ç¨‹(å¦‚SQLæ„é€ å™¨);               | âœ…        |
| **åŸå‹**     | é€šè¿‡å…‹éš†åˆ›å»ºå¯¹è±¡                 | **å¤åˆ¶**; é¿å…æ„é€ å¼€é”€;                          |          |

> ğŸ’¡ **å¯¹æ¯”å£è¯€**:   
> **â€œå·¥å‚æ–¹æ³•é€ ä¸€ä¸ª, æŠ½è±¡å·¥å‚é€ ä¸€å¥—â€**  
> **â€œå»ºé€ è€…é‡æ­¥éª¤, æŠ½è±¡å·¥å‚é‡æ—â€**

---

## ğŸ”Œ ç»“æ„å‹æ¨¡å¼(7ç§)

| æ¨¡å¼       | ç®€ä»‹                                          | ç±»æ¯”è®°å¿†              | é«˜é¢‘é‡ç‚¹ |
| ---------- | --------------------------------------------- | --------------------- | -------- |
| **é€‚é…å™¨** | è½¬æ¢æ¥å£, å…¼å®¹ä¸åŒ¹é…ç±»                        | **è½¬æ¥å¤´/è½¬æ¢æ¥å£**   | âœ…        |
| **æ¡¥æ¥**   | æŠ½è±¡ä¸å®ç°åˆ†ç¦», ç‹¬ç«‹å˜åŒ–                      | **é¥æ§å™¨+ç”µè§†**       |          |
| **ç»„åˆ**   | æ ‘å½¢ç»“æ„ç»Ÿä¸€å¤„ç†éƒ¨åˆ†-æ•´ä½“                     | **æ–‡ä»¶ç³»ç»Ÿ/èœå•æ ‘**   |          |
| **è£…é¥°å™¨** | åŠ¨æ€æ·»åŠ åŠŸèƒ½, æ›¿ä»£ç»§æ‰¿                        | **å±‚å±‚åŒ…è£…,åŠŸèƒ½å¢å¼º** | âœ…        |
| **å¤–è§‚**   | å°è£…å­ç³»ç»Ÿ, æä¾›ç»Ÿä¸€å…¥å£                      | **ä¸€é”®å¼€æœº/å‰å°æ¥å¾…** |          |
| **äº«å…ƒ**   | å…±äº«å¯¹è±¡, èŠ‚çœå†…å­˜;å…³æ³¨å¤ç”¨,åˆ†ç¦»å†…éƒ¨/å¤–éƒ¨çŠ¶æ€ | **å­—ç¬¦æ± /å­å¼¹æ± **;    |          |
| **ä»£ç†**   | æ§åˆ¶å¯¹è±¡è®¿é—®                                  | **ç»çºªäºº/ä»£ç†**       | âœ…        |

| å¯¹æ¯”è®°å¿†   | éƒ½åŒ…è£…å¯¹è±¡, ä½†ç›®çš„ä¸åŒ                | ç±»æ¯”                 |
| ---------- | ------------------------------------- | -------------------- |
| **é€‚é…å™¨** | **è½¬æ¢æ¥å£**(æ—§ç³»ç»Ÿå…¼å®¹)            | â€œç”µæºæ’å¤´è½¬æ¢å™¨â€     |
| **è£…é¥°å™¨** | **å¼ºåŠŸèƒ½**(åŠ¨æ€åŠ æ–™)                | â€œç»™è›‹ç³•åŠ å¥¶æ²¹å’Œæ°´æœâ€ |
| **ä»£ç†**   | **æ§åˆ¶è®¿é—®**(æƒé™ã€å»¶è¿Ÿã€æ—¥å¿—)      | â€œç»çºªäººæ›¿æ˜æ˜Ÿè°ˆåˆåŒâ€ |
| 2          |                                       |                      |
| **è£…é¥°å™¨** | åŒ…è£…å¢å¼º â†’ é€æ˜æ¥å£, å±‚å±‚å åŠ          | è£…é¥°å™¨åƒâ€œç©¿è¡£æœâ€     |
| **ç»„åˆ**   | æ ‘å½¢ç»“æ„ â†’ éƒ¨åˆ†-æ•´ä½“é€’å½’å¤„ç†          | ç»„åˆåƒâ€œç»„ç»‡ç»“æ„å›¾â€   |
| 3          |                                       |                      |
| **å¤–è§‚**   | å°è£…å­ç³»ç»Ÿ â†’ ç®€åŒ–è°ƒç”¨(å®¢æˆ·ç«¯è§†è§’)   | â€œä¸€é”®å¼€æœºæŒ‰é’®â€       |
| **ä¸­ä»‹è€…** | å°è£…å¯¹è±¡äº¤äº’ â†’ é™ä½è€¦åˆ(å¯¹è±¡é—´é€šä¿¡) | â€œæœºåœºå¡”å°åè°ƒé£æœºâ€   |

> ğŸ’¡ **å¯¹æ¯”å£è¯€**:   
> **â€œé€‚é…æ—§æ¥å£, æ¡¥æ¥ä¸¤ç‹¬ç«‹, å¤–è§‚åŒ…å¤æ‚â€**  
> **â€œè£…é¥°å™¨=åŠ æ–™, ä»£ç†=çœ‹é—¨â€**

---

## ğŸ”„ è¡Œä¸ºå‹æ¨¡å¼(11ç§)

| æ¨¡å¼         | ç®€ä»‹                       | ç‰¹ç‚¹(å«å¯¹æ¯” & ç±»æ¯”)                        | é«˜é¢‘é‡ç‚¹ |
| ------------ | -------------------------- | ------------------------------------------ | -------- |
| **ç­–ç•¥**     | å°è£…å¯äº’æ¢ç®—æ³•             | â€œå¯¼èˆªè·¯çº¿åˆ‡æ¢â€                             | âœ…        |
| **æ¨¡æ¿æ–¹æ³•** | å®šä¹‰ç®—æ³•éª¨æ¶, å­ç±»å®ç°æ­¥éª¤ | â€œæ³¡èŒ¶æµç¨‹â€;                                | âœ…        |
| **è§‚å¯Ÿè€…**   | ä¸€å¯¹å¤šä¾èµ–, çŠ¶æ€å˜æ›´é€šçŸ¥   | â€œè®¢é˜…å·æ¨é€â€                               | âœ…        |
| **è´£ä»»é“¾**   | è¯·æ±‚æ²¿é“¾ä¼ é€’å¤„ç†           | â€œå®¡æ‰¹æµç¨‹/å¼‚å¸¸å¤„ç†â€                        |          |
| **å‘½ä»¤**     | å°è£…è¯·æ±‚ä¸ºå¯¹è±¡, æ”¯æŒæ’¤é”€   | â€œé¥æ§å™¨æŒ‰é’®â€                               | âœ…        |
| **è§£é‡Šå™¨**   | å®šä¹‰æ–‡æ³•å¹¶è§£é‡Šè¡¨è¾¾å¼       | â€œç®€å•è¯­è¨€è§£æå™¨â€; ä½¿ç”¨è¾ƒå°‘                 |          |
| **è¿­ä»£å™¨**   | éå†èšåˆå¯¹è±¡, éšè—å†…éƒ¨ç»“æ„ | â€œé€šç”¨éå†å™¨â€;                              |          |
| **ä¸­ä»‹è€…**   | é›†ä¸­ç®¡ç†å¯¹è±¡äº¤äº’           | â€œèŠå¤©å®¤æœåŠ¡å™¨â€                             |          |
| **å¤‡å¿˜å½•**   | ä¿å­˜/æ¢å¤å¯¹è±¡çŠ¶æ€          | â€œæ¸¸æˆå­˜æ¡£â€                                 |          |
| **çŠ¶æ€**     | çŠ¶æ€é©±åŠ¨è¡Œä¸ºè‡ªåŠ¨åˆ‡æ¢       | â€œå”®è´§æœºçŠ¶æ€â€                               | âœ…        |
| **è®¿é—®è€…**   | åˆ†ç¦»æ“ä½œä¸å¯¹è±¡ç»“æ„         | â€œæ•°æ®ç»“æ„+å¤šç§æ“ä½œâ€; é€‚åˆç¨³å®šç»“æ„+å¤šå˜æ“ä½œ |          |

| æ¨¡å¼          | è¯´æ˜                                       | ç±»æ¯”                                      |
| ------------- | ------------------------------------------ | ----------------------------------------- |
| **ç­–ç•¥**      | å®¢æˆ·ç«¯ä¸»åŠ¨åˆ‡æ¢ â†’ â€œæˆ‘é€‰å“ªä¸ªç®—æ³•â€            | é€‰æ‹©é©¾é©¶/éª‘è¡Œ/æ­¥è¡Œ                        |
| **çŠ¶æ€**      | å¯¹è±¡è‡ªåŠ¨åˆ‡æ¢ â†’ â€œæˆ‘æ˜¯ä»€ä¹ˆçŠ¶æ€, è¯¥åšä»€ä¹ˆâ€    | æ‰‹æœºå……ç”µä¸­/æ»¡ç”µ/å…³æœºè‡ªåŠ¨è¡Œä¸ºä¸åŒ          |
| 2             |                                            |                                           |
| **å‘½ä»¤**      | å°è£…â€œè¯·æ±‚â€ â†’ æ”¯æŒæ’¤é”€ã€æ’é˜Ÿ(åŠ¨è¯)        | é¥æ§å™¨æŒ‰é’®(å¼€/å…³/éŸ³é‡)                   |
| **ç­–ç•¥**      | å°è£…â€œç®—æ³•â€ â†’ æ”¯æŒæ›¿æ¢(æ–¹æ³•)              | å¯¼èˆªè·¯çº¿A/B/C                             |
| 3             |                                            |                                           |
| **æ¨¡æ¿æ–¹æ³•**  | çˆ¶ç±»å®šæµç¨‹, å­ç±»å¡«æ­¥éª¤ â†’ **ç»§æ‰¿**          | çˆ¶ç±»å®šä¹‰æ³¡èŒ¶æµç¨‹, å­ç±»å®ç°åŠ ç³–æˆ–ä¸åŠ       |
| **ç­–ç•¥**      | æ³¨å…¥ä¸åŒå®ç° â†’ **ç»„åˆ**                    | æ³¨å…¥ SweetTeaStrategy æˆ– PlainTeaStrategy |
| 4             |                                            |                                           |
| **è§‚å¯Ÿè€…**    | ç›®æ ‡ç›´æ¥é€šçŸ¥è§‚å¯Ÿè€… â†’ åŒæ­¥ã€ç´§è€¦åˆ          |                                           |
| **å‘å¸ƒ-è®¢é˜…** | è¿‡æ¶ˆæ¯é˜Ÿåˆ—è§£è€¦ â†’ å¼‚æ­¥ã€æ¾è€¦åˆ(éGoFæ¨¡å¼) | GoFåªæœ‰â€œè§‚å¯Ÿè€…â€, å‘å¸ƒè®¢é˜…æ˜¯å…¶åˆ†å¸ƒå¼æ¼”è¿›   |
| 5             |                                            |                                           |
| **å¤‡å¿˜å½•**    | ä¿å­˜çŠ¶æ€å¿«ç…§ â†’ æ¢å¤(å†…å­˜æ¶ˆè€—å¤§)          | â€œæ¸¸æˆå­˜æ¡£â€                                |
| **å‘½ä»¤**      | è®°å½•æ“ä½œ+åå‘æ“ä½œ â†’ æ’¤é”€(è½»é‡)           | â€œCtrl+Zâ€                                  |
| 6             |                                            |                                           |
| **ä¸­ä»‹è€…**    | æ˜Ÿå‹ç»“æ„, é›†ä¸­è°ƒåº¦ â†’ é™ä½Nå¯¹Nè€¦åˆ          | â€œæœºåœºå¡”å°â€                                |
| **è§‚å¯Ÿè€…**    | å¹¿æ’­é€šçŸ¥ â†’ ç›®æ ‡ä¸è§‚å¯Ÿè€…ç›´æ¥è€¦åˆ            | â€œå¾®ä¿¡ç¾¤@æ‰€æœ‰äººâ€                           |

> ğŸ’¡ **å¯¹æ¯”å£è¯€**:   
> **â€œç­–ç•¥æ¢ç®—æ³•, çŠ¶æ€æ¢è¡Œä¸º, æ¨¡æ¿å®šéª¨æ¶â€**  
> **â€œå‘½ä»¤=å°è£…è¯·æ±‚, è´£ä»»é“¾=ä¼ é€’è¯·æ±‚â€**  
> **â€œè§‚å¯Ÿè€…=ç›´æ¥é€šçŸ¥, å‘å¸ƒè®¢é˜…=æ¶ˆæ¯é˜Ÿåˆ—(æ‰©å±•)â€**

---

## ğŸ“Š é«˜é¢‘é‡ç‚¹æ¨¡å¼æ¨è

| ç±»å‹   | é‡ç‚¹æ¨¡å¼                           | å…¸å‹åº”ç”¨åœºæ™¯                 |
| ------ | ---------------------------------- | ---------------------------- |
| åˆ›å»ºå‹ | å·¥å‚æ–¹æ³•ã€å•ä¾‹ã€å»ºé€ è€…             | æ¡†æ¶ã€å·¥å…·ç±»ã€å¤æ‚å¯¹è±¡æ„å»º   |
| ç»“æ„å‹ | é€‚é…å™¨ã€è£…é¥°å™¨ã€ä»£ç†               | ç³»ç»Ÿé›†æˆã€åŠŸèƒ½å¢å¼ºã€æƒé™æ§åˆ¶ |
| è¡Œä¸ºå‹ | ç­–ç•¥ã€è§‚å¯Ÿè€…ã€æ¨¡æ¿æ–¹æ³•ã€çŠ¶æ€ã€å‘½ä»¤ | ä¸šåŠ¡é€»è¾‘ã€äº‹ä»¶é©±åŠ¨ã€æµç¨‹æ§åˆ¶ |

---

## ğŸ§  å­¦ä¹ å»ºè®®

1. **æŒ‰ç±»å­¦ä¹ **: åˆ›å»º â†’ ç»“æ„ â†’ è¡Œä¸º, ç†è§£æ¼”è¿›é€»è¾‘ã€‚
2. **å¯¹æ¯”è®°å¿†**: é‡ç‚¹æŒæ¡ç­–ç•¥vsçŠ¶æ€ã€è£…é¥°å™¨vsä»£ç†ã€å‘½ä»¤vså¤‡å¿˜å½•ç­‰ã€‚
3. **åœºæ™¯é©±åŠ¨**: æ€è€ƒâ€œä»€ä¹ˆé—®é¢˜ç”¨ä»€ä¹ˆæ¨¡å¼â€, ç»“åˆSpring/JDK/Qtç­‰æ¡†æ¶ã€‚
4. **ç”»å›¾+å†™ç **: UMLç±»å›¾ + æœ€å°å¯è¿è¡ŒDemo, åŠ æ·±ç†è§£ã€‚
5. **ä»£ç å®è·µ**: ç”¨ C++/Java/Python å®ç°æœ€å°å¯è¿è¡Œç¤ºä¾‹ã€‚
6. **ä¼˜å…ˆæŒæ¡é«˜é¢‘æ¨¡å¼**, é¿å…æ­»è®°ç¡¬èƒŒã€‚

---

## ğŸ¯ ä¸€å¥è¯è®°å¿†å£è¯€

> **â€œå·¥å•å»ºåŸå‹, å·¥æŠ½å•å»ºåŸâ€** â€”â€” åˆ›å»ºå‹  
> **â€œé€‚æ¡¥ç»„, è£…å¤–äº«ä»£â€** â€”â€” ç»“æ„å‹  
> **â€œè´£å‘½è§£, è¿­ä¸­å¤‡, è§‚çŠ¶ç­–, æ¨¡è®¿â€** â€”â€” è¡Œä¸ºå‹

> ğŸš€ **ç»ˆæå£è¯€å…¨æ–‡(å¿…èƒŒ): **  
> **â€œåˆ›äº”ç»“ä¸ƒè¡Œåä¸€, SOLIDæ˜¯æ ¹åŸº;   
> å·¥å‚å•ä¾‹å»ºåŸå‹, é€‚é…è£…é¥°ä»£ç†é½;   
> ç­–ç•¥è§‚å¯Ÿæ¨¡æ¿æ³•, å‘½ä»¤çŠ¶æ€è´£ä»»é“¾;   
> å¤‡å¿˜è®¿é—®ä¸­ä»‹è€…, è§£é‡Šç»„åˆäº«å…ƒæ¡¥ã€‚â€**

---

ğŸ“Œ **ç»“è¯­: **

> è®¾è®¡æ¨¡å¼ = **è§£å†³ç‰¹å®šé—®é¢˜çš„æ€ç»´æ¨¡æ¿**ã€‚  
> æŒæ¡æ­¤è¡¨ + å£è¯€ + å¯¹æ¯”, 23ç§æ¨¡å¼å°½åœ¨æŒæ¡, ä»£ç è®¾è®¡æ¸¸åˆƒæœ‰ä½™ï¼

âœ… ä¸€è¡¨åœ¨æ‰‹, æ¨¡å¼æ— å¿§ï¼  
âœ… ç²¾ç‚¼æ•´åˆ, é«˜æ•ˆå­¦ä¹ ï¼

---

# 2. ğŸ¯å¸¸ç”¨è®¾è®¡åŸåˆ™

> âœ… **SOLID + LoD = é¢å‘å¯¹è±¡è®¾è®¡é»„é‡‘æ³•åˆ™**
>
> âœ… **æŒæ¡è¿™å…­å¤§åŸåˆ™, ä½ å°±æŒæ¡äº†é¢å‘å¯¹è±¡è®¾è®¡çš„çµé­‚ï¼**
>
> âœ… **è®¾è®¡æ¨¡å¼æ˜¯â€œæœ¯â€, è¿™äº›åŸåˆ™æ˜¯â€œé“â€ã€‚**
>
> ğŸš€ **ç»ˆæå¿ƒæ³•: é«˜å†…èš, ä½è€¦åˆ, å¯æ‰©å±•, æ˜“ç»´æŠ¤ã€‚**

| ä¸­æ–‡å                    | æ ¸å¿ƒæ€æƒ³(ä¸€å¥è¯)                   |
| ------------------------- | ------------------------------------ |
| å•ä¸€èŒè´£åŸåˆ™ (SRP-Single Responsibility Principle) | ä¸€ä¸ªç±»åªåšä¸€ä»¶äº‹;                    |
| å¼€é—­åŸåˆ™ (OCP - Open/Closed Principle) | å¯¹æ‰©å±•å¼€æ”¾, å¯¹ä¿®æ”¹å…³é—­;              |
| é‡Œæ°æ›¿æ¢åŸåˆ™ (LSP - Liskov Substitution Principle) | å­ç±»å¿…é¡»èƒ½æ›¿æ¢çˆ¶ç±»è€Œä¸å½±å“ç¨‹åºæ­£ç¡®æ€§;**å­æ¢çˆ¶, ä¸å‡ºé”™** |
| æ¥å£éš”ç¦»åŸåˆ™ (ISP - Interface Segregation Principle) | å®¢æˆ·ç«¯ä¸åº”ä¾èµ–å®ƒä¸éœ€è¦çš„æ¥å£;**æ¥å£å°, ä¸å¼ºå¡** |
| ä¾èµ–å€’ç½®åŸåˆ™ (DIP - Dependency Inversion Principle) | ä¾èµ–æŠ½è±¡, ä¸ä¾èµ–å…·ä½“; **ä¾èµ–æŠ½è±¡è€Œéå…·ä½“** |
| è¿ªç±³ç‰¹æ³•åˆ™ (æœ€å°‘çŸ¥é“åŸåˆ™)(LoD - Law of Demeter) | åªä¸ç›´æ¥æœ‹å‹é€šä¿¡, é™ä½è€¦åˆ; **åªèŠç†Ÿäºº, ä¸ä¸²é—¨** |

---

## 1ï¸âƒ£ å•ä¸€èŒè´£åŸåˆ™

> **ä¸€ä¸ªç±», åªè´Ÿè´£ä¸€ä»¶äº‹ã€‚**

ğŸ’¡ ç²¾ç‚¼è§£é‡Š: 

- èŒè´£ = å˜åŒ–çš„åŸå› ã€‚
- å¦‚æœä¸€ä¸ªç±»æœ‰å¤šä¸ªèŒè´£, ä¿®æ”¹ä¸€ä¸ªå¯èƒ½å½±å“å¦ä¸€ä¸ª â†’ è„†å¼±ã€éš¾ç»´æŠ¤ã€‚

ğŸ§© C++ ç¤ºä¾‹: 

```cpp
// âŒ è¿åSRP: ä¸€ä¸ªç±»æ—¢ç®¡ç”¨æˆ·æ•°æ®, åˆç®¡ä¿å­˜åˆ°æ•°æ®åº“
class User {
    std::string name;
public:
    void setName(std::string n) { name = n; }
    void saveToDB() { /* è¿æ¥æ•°æ®åº“ã€æ‰§è¡ŒSQL... */ } // èŒè´£2: æŒä¹…åŒ–
};

// âœ… éµå¾ªSRP: æ‹†åˆ†èŒè´£
class User {
    std::string name;
public:
    void setName(std::string n) { name = n; }
    std::string getName() const { return name; }
};

class UserRepository {
public:
    static void save(const User& user) {
        // ä¸“é—¨è´Ÿè´£æŒä¹…åŒ–
    }
};
```

---

## 2ï¸âƒ£ å¼€é—­åŸåˆ™

> **å¯¹æ‰©å±•å¼€æ”¾, å¯¹ä¿®æ”¹å…³é—­ã€‚**

ğŸ’¡ ç²¾ç‚¼è§£é‡Š: 

- æ–°å¢åŠŸèƒ½ â†’ **æ‰©å±•**(åŠ æ–°ç±»/ç­–ç•¥), è€Œé**ä¿®æ”¹**æ—§ä»£ç ã€‚
- é€šå¸¸é€šè¿‡**æŠ½è±¡ + å¤šæ€**å®ç°ã€‚

ğŸ§© C++ ç¤ºä¾‹: 

```cpp
// âŒ è¿åOCP: æ–°å¢æ”¯ä»˜æ–¹å¼éœ€ä¿®æ”¹åŸç±»
class PaymentProcessor {
public:
    void process(std::string type, double amount) {
        if (type == "Alipay") { /* ... */ }
        else if (type == "WeChat") { /* ... */ }
        // else if (type == "Crypto") { ... } // æ¯æ¬¡åŠ æ–°æ”¯ä»˜éƒ½è¦æ”¹è¿™é‡Œï¼
    }
};

// âœ… éµå¾ªOCP: æ‰©å±•æ–°ç±», ä¸æ”¹æ—§ä»£ç 
class IPayment {
public:
    virtual ~IPayment() = default;
    virtual void pay(double amount) = 0;
};

class Alipay : public IPayment {
    void pay(double amount) override { /* ... */ }
};

class WeChatPay : public IPayment {
    void pay(double amount) override { /* ... */ }
};

class PaymentProcessor {
    std::unique_ptr<IPayment> strategy;
public:
    void setPayment(std::unique_ptr<IPayment> p) {
        strategy = std::move(p);
    }
    void process(double amount) {
        if (strategy) strategy->pay(amount);
    }
};
// æ–°å¢ CryptoPayï¼Ÿåªéœ€ç»§æ‰¿ IPayment, æ— éœ€ä¿®æ”¹ PaymentProcessorï¼
```

---

## 3ï¸âƒ£ é‡Œæ°æ›¿æ¢åŸåˆ™

> **å­ç±»å¿…é¡»èƒ½æ›¿æ¢çˆ¶ç±», ä¸”ç¨‹åºè¡Œä¸ºä¸å˜ã€‚**

ğŸ’¡ ç²¾ç‚¼è§£é‡Š: 

- å­ç±»ä¸èƒ½ç ´åçˆ¶ç±»å¥‘çº¦(å‰ç½®/åç½®æ¡ä»¶ã€ä¸å˜é‡)ã€‚
- ä¸è¦ç”¨ç»§æ‰¿å¼ºè¡Œâ€œæ˜¯-aâ€å…³ç³»ã€‚

ğŸ§© C++ ç¤ºä¾‹: 

```cpp
// âŒ è¿åLSP: æ­£æ–¹å½¢ç»§æ‰¿çŸ©å½¢, ä½†è¡Œä¸ºä¸ä¸€è‡´
class Rectangle {
protected:
    int width, height;
public:
    virtual void setWidth(int w) { width = w; }
    virtual void setHeight(int h) { height = h; }
    virtual int getArea() { return width * height; }
};

class Square : public Rectangle {
public:
    void setWidth(int w) override { width = height = w; } // ç ´åçˆ¶ç±»å¥‘çº¦ï¼
    void setHeight(int h) override { width = height = h; }
};

// ä½¿ç”¨æ—¶å‡ºé”™: 
void resize(Rectangle& r) {
    r.setWidth(5);
    r.setHeight(4);
    assert(r.getArea() == 20); // å¯¹Squareä¼šå¤±è´¥ï¼é¢ç§¯=16 â‰  20
}

// âœ… éµå¾ªLSP: æ­£æ–¹å½¢ä¸åº”ç»§æ‰¿çŸ©å½¢, æˆ–é‡æ–°è®¾è®¡æ¥å£
// â†’ ç”¨ç»„åˆ or ç‹¬ç«‹ç±» or æ¥å£éš”ç¦»
```

---

## 4ï¸âƒ£ æ¥å£éš”ç¦»åŸåˆ™

> **å®¢æˆ·ç«¯ä¸åº”è¢«è¿«ä¾èµ–å®ƒä¸éœ€è¦çš„æ¥å£ã€‚**

ğŸ’¡ ç²¾ç‚¼è§£é‡Š: 

- æ¥å£è¦â€œå°è€Œä¸“â€, ä¸è¦â€œå¤§è€Œå…¨â€ã€‚
- é¿å…â€œèƒ–æ¥å£â€, æŒ‰è§’è‰²æ‹†åˆ†ã€‚

ğŸ§© C++ ç¤ºä¾‹: 

```cpp
// âŒ è¿åISP: ä¸€ä¸ªæ¥å£åŒ…å«æ‰€æœ‰æ–¹æ³•, æœ‰äº›ç±»ç”¨ä¸åˆ°
class IBird {
public:
    virtual void fly() = 0;
    virtual void eat() = 0;
    virtual void swim() = 0; // ä¼é¹…ä¸éœ€è¦ï¼
};

class Penguin : public IBird {
    void fly() override { /* ä¸èƒ½é£, æŠ›å¼‚å¸¸ï¼Ÿç©ºå®ç°ï¼Ÿéƒ½ä¸å¯¹ï¼ */ }
    void eat() override { /* ... */ }
    void swim() override { /* ... */ }
};

// âœ… éµå¾ªISP: æŒ‰èƒ½åŠ›æ‹†åˆ†æ¥å£
class IFlyable { virtual void fly() = 0; };
class ISwimmable { virtual void swim() = 0; };
class IEatable { virtual void eat() = 0; };

class Sparrow : public IFlyable, public IEatable { /* ... */ };
class Penguin : public ISwimmable, public IEatable { /* ... */ };
```

---

## 5ï¸âƒ£ ä¾èµ–å€’ç½®åŸåˆ™

> **é«˜å±‚æ¨¡å—ä¸åº”ä¾èµ–ä½å±‚æ¨¡å—, äºŒè€…éƒ½åº”ä¾èµ–æŠ½è±¡ã€‚**

ğŸ’¡ ç²¾ç‚¼è§£é‡Š: 

- ä¾èµ–æŠ½è±¡(æ¥å£/åŸºç±»), ä¸ä¾èµ–å…·ä½“å®ç°ã€‚
- æ§åˆ¶åè½¬(IoC)çš„åŸºç¡€ã€‚

ğŸ§© C++ ç¤ºä¾‹: 

```cpp
// âŒ è¿åDIP: é«˜å±‚ç›´æ¥ä¾èµ–ä½å±‚å…·ä½“ç±»
class MySQLDatabase {
public:
    void connect() { /* ... */ }
    void query(std::string sql) { /* ... */ }
};

class UserService {
    MySQLDatabase db; // ç´§è€¦åˆï¼æ¢æ•°æ®åº“ï¼Ÿæ”¹ä»£ç ï¼
public:
    void getUser(int id) {
        db.query("SELECT * FROM users WHERE id=" + std::to_string(id));
    }
};

// âœ… éµå¾ªDIP: ä¾èµ–æŠ½è±¡
class IDatabase {
public:
    virtual ~IDatabase() = default;
    virtual void connect() = 0;
    virtual void query(std::string sql) = 0;
};

class MySQLDatabase : public IDatabase { /* ... */ };
class PostgreSQLDatabase : public IDatabase { /* ... */ };

class UserService {
    std::unique_ptr<IDatabase> db; // ä¾èµ–æŠ½è±¡
public:
    UserService(std::unique_ptr<IDatabase> d) : db(std::move(d)) {}
    void getUser(int id) {
        db->query("SELECT * FROM users WHERE id=" + std::to_string(id));
    }
};
// æ¢æ•°æ®åº“ï¼Ÿæ³¨å…¥ä¸åŒå®ç°å³å¯, UserService ä¸€è¡Œä¸æ”¹ï¼
```

---

## 6ï¸âƒ£ è¿ªç±³ç‰¹æ³•åˆ™

> **åªä¸ç›´æ¥æœ‹å‹é€šä¿¡, ä¸å’Œâ€œé™Œç”Ÿäººâ€è¯´è¯ã€‚**

ğŸ’¡ ç²¾ç‚¼è§£é‡Š: 

- â€œæœ‹å‹â€ = å‚æ•°ã€æˆå‘˜ã€å±€éƒ¨å˜é‡ã€thisã€‚
- ä¸è¦ `a.getB().getC().doSomething()` é“¾å¼è°ƒç”¨ â†’ è€¦åˆæ·±, æ˜“å´©ã€‚

ğŸ§© C++ ç¤ºä¾‹: 

```cpp
// âŒ è¿åLoD: é“¾å¼è°ƒç”¨, è€¦åˆè¿‡æ·±
class Engine {
public:
    void start() { /* ... */ }
};

class Car {
    Engine engine;
public:
    Engine& getEngine() { return engine; } // æš´éœ²å†…éƒ¨å¯¹è±¡ï¼
};

class Driver {
public:
    void drive(Car& car) {
        car.getEngine().start(); // ä¾èµ–äº†Engineï¼ä¸è¯¥çŸ¥é“Carå†…éƒ¨ç»“æ„
    }
};

// âœ… éµå¾ªLoD: å°è£…å†…éƒ¨, åªè°ƒç”¨ç›´æ¥æ¥å£
class Car {
    Engine engine;
public:
    void start() { engine.start(); } // å°è£…ï¼Driver åªéœ€çŸ¥é“ Car.start()
};

class Driver {
public:
    void drive(Car& car) {
        car.start(); // åªä¸Caré€šä¿¡, ä¸ç¢°Engine
    }
};
```

---

# ğŸ› ï¸åˆ›å»ºå‹æ¨¡å¼

# 3.ç®€å•å·¥å‚æ¨¡å¼

## ç®€ä»‹

**ç®€å•å·¥å‚æ¨¡å¼(Simple Factory Pattern)** å¹¶ä¸æ˜¯ GoF 23 ç§è®¾è®¡æ¨¡å¼ä¹‹ä¸€,è€Œæ˜¯ä¸€ç§â€œç¼–ç¨‹ä¹ æƒ¯â€æˆ–â€œæƒ¯ç”¨æ³•â€,å¸¸è¢«ç”¨ä½œå·¥å‚æ–¹æ³•æ¨¡å¼çš„ç®€åŒ–ç‰ˆã€‚

**é€‚ç”¨åœºæ™¯**

1. **å¯¹è±¡åˆ›å»ºé€»è¾‘ç®€å•,ä½†éœ€è¦é›†ä¸­ç®¡ç†** - å¦‚æ ¹æ®é…ç½®ã€ç”¨æˆ·è¾“å…¥ã€ç±»å‹å­—ç¬¦ä¸²ç­‰åˆ›å»ºä¸åŒå¯¹è±¡ã€‚
2. **å®¢æˆ·ç«¯ä¸å…³å¿ƒå…·ä½“ç±»,åªå…³å¿ƒæ¥å£** - è§£è€¦å®¢æˆ·ç«¯ä¸å…·ä½“å®ç°ã€‚
3. **äº§å“ç±»è¾ƒå°‘,ä¸”ä¸å¤ªä¼šé¢‘ç¹æ‰©å±•** - é¿å…å·¥å‚ç±»è†¨èƒ€ã€‚
4. **å¿«é€ŸåŸå‹æˆ–æ•™å­¦ç¤ºä¾‹** - ç®€å•ç›´è§‚,æ˜“äºç†è§£ã€‚

**ä¼˜ç¼ºç‚¹**

âœ… ä¼˜ç‚¹

- **å°è£…åˆ›å»ºé€»è¾‘**: å®¢æˆ·ç«¯æ— éœ€çŸ¥é“å…·ä½“ç±»å,é™ä½è€¦åˆã€‚
- **é›†ä¸­ç®¡ç†å¯¹è±¡åˆ›å»º**: ä¾¿äºç»´æŠ¤å’Œä¿®æ”¹åˆ›å»ºé€»è¾‘ã€‚
- **ä»£ç ç®€æ´**: ç›¸æ¯”å·¥å‚æ–¹æ³•/æŠ½è±¡å·¥å‚æ›´è½»é‡ã€‚

âŒ ç¼ºç‚¹

- **è¿åå¼€é—­åŸåˆ™(OCP)**: æ–°å¢äº§å“æ—¶å¿…é¡»ä¿®æ”¹å·¥å‚ç±»(éœ€åŠ  `if-else` æˆ– `switch`)ã€‚
- **å·¥å‚ç±»èŒè´£è¿‡é‡**: æ‰€æœ‰äº§å“çš„åˆ›å»ºé€»è¾‘é›†ä¸­åœ¨ä¸€ä¸ªç±»ä¸­,ä¸æ˜“æ‰©å±•å’Œç»´æŠ¤ã€‚
- **ä¸æ˜¯çœŸæ­£çš„â€œè®¾è®¡æ¨¡å¼â€**: ç¼ºä¹æ‰©å±•æ€§å’Œå¤šæ€æ€§æ”¯æŒ(å¯¹æ¯”å·¥å‚æ–¹æ³•æ¨¡å¼)ã€‚

**âš ï¸ æ³¨æ„äº‹é¡¹**

1. **é¿å…å·¥å‚ç±»è¿‡äºåºå¤§** - å¦‚æœäº§å“ç§ç±»å¾ˆå¤š,è€ƒè™‘ä½¿ç”¨**å·¥å‚æ–¹æ³•æ¨¡å¼**æˆ–**æ³¨å†Œè¡¨æ¨¡å¼(åå°„/é…ç½®é©±åŠ¨)**ã€‚
2. **å¼‚å¸¸å¤„ç†è¦å®Œå–„** - å¯¹éæ³•è¾“å…¥å‚æ•°æŠ›å‡ºå¼‚å¸¸æˆ–è¿”å›ç©ºæŒ‡é’ˆ,å¹¶åšå¥½å®¢æˆ·ç«¯å¤„ç†ã€‚
3. **çº¿ç¨‹å®‰å…¨é—®é¢˜** - å¦‚æœå·¥å‚ç±»æœ‰çŠ¶æ€æˆ–ä½¿ç”¨å•ä¾‹,éœ€è€ƒè™‘å¤šçº¿ç¨‹ç¯å¢ƒä¸‹çš„åŒæ­¥ã€‚
4. **å†…å­˜ç®¡ç†** - ç¤ºä¾‹ä¸­ä½¿ç”¨ `std::unique_ptr` è‡ªåŠ¨ç®¡ç†èµ„æº,é¿å…å†…å­˜æ³„æ¼ã€‚
5. **å¯è€ƒè™‘ä½¿ç”¨æšä¸¾æ›¿ä»£å­—ç¬¦ä¸²** - æé«˜ç±»å‹å®‰å…¨æ€§,é¿å…æ‹¼å†™é”™è¯¯: 

**ğŸ“Œæ€»ç»“**

> **ç®€å•å·¥å‚æ¨¡å¼æ˜¯â€œå·¥å‚æ¨¡å¼å®¶æ—â€çš„å…¥é—¨æ¬¾,é€‚åˆäº§å“ç§ç±»å°‘ã€å˜åŒ–ä¸é¢‘ç¹çš„åœºæ™¯ã€‚**
>  å®ƒè®©ä»£ç æ›´æ•´æ´ã€è€¦åˆæ›´ä½,ä½†ä¸å…·å¤‡è‰¯å¥½çš„æ‰©å±•æ€§ã€‚åœ¨éœ€è¦çµæ´»æ‰©å±•æ—¶,åº”å‡çº§ä¸º**å·¥å‚æ–¹æ³•æ¨¡å¼**æˆ–**æŠ½è±¡å·¥å‚æ¨¡å¼**ã€‚

## ä»£ç 

```
#include <iostream>
#include <memory>
#include <string>

// æŠ½è±¡äº§å“ç±»
class Product {
public:
    virtual ~Product() = default;
    virtual void operation() = 0;
};

// å…·ä½“äº§å“ A
class ConcreteProductA : public Product {
public:
    void operation() override {
        std::cout << "ConcreteProductA::operation() called.\n";
    }
};

// å…·ä½“äº§å“ B
class ConcreteProductB : public Product {
public:
    void operation() override {
        std::cout << "ConcreteProductB::operation() called.\n";
    }
};

// ç®€å•å·¥å‚ç±»
class SimpleFactory {
public:
    static std::unique_ptr<Product> createProduct(const std::string& type) {
        if (type == "A") {
            return std::make_unique<ConcreteProductA>();
        } else if (type == "B") {
            return std::make_unique<ConcreteProductB>();
        } else {
            throw std::invalid_argument("Unknown product type: " + type);
        }
    }
};

// å®¢æˆ·ç«¯ä»£ç 
int main() {
    try {
        auto productA = SimpleFactory::createProduct("A");
        productA->operation();

        auto productB = SimpleFactory::createProduct("B");
        productB->operation();

        // auto productC = SimpleFactory::createProduct("C"); // æŠ›å‡ºå¼‚å¸¸
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }

    return 0;
}
```

## PlantUML

```
@startuml
' ç®€å•å·¥å‚æ¨¡å¼ç±»å›¾

interface Product {
    +operation()
}

class ConcreteProductA {
    +operation()
}

class ConcreteProductB {
    +operation()
}

class SimpleFactory {
    +createProduct(type: string): Product
}

class Client

Client --> SimpleFactory : ä½¿ç”¨
SimpleFactory --> Product : åˆ›å»º
Product <|-- ConcreteProductA
Product <|-- ConcreteProductB

note right of SimpleFactory
  æ ¹æ®ä¼ å…¥å‚æ•°å†³å®š
  åˆ›å»ºå“ªä¸ªå…·ä½“äº§å“
end note

@enduml
```

![](./picture/1.SimpleFactoryPattern.png)



# 4. å·¥å‚æ–¹æ³•æ¨¡å¼

## ç®€ä»‹

**å·¥å‚æ–¹æ³•æ¨¡å¼(Factory Method Pattern)** æ˜¯ GoF 23 ç§ç»å…¸è®¾è®¡æ¨¡å¼ä¹‹ä¸€, å±äº **åˆ›å»ºå‹æ¨¡å¼**ã€‚

> å®ƒå®šä¹‰ä¸€ä¸ªç”¨äºåˆ›å»ºå¯¹è±¡çš„**æ¥å£(å·¥å‚æ–¹æ³•)**, ä½†è®©**å­ç±»å†³å®šå®ä¾‹åŒ–å“ªä¸€ä¸ªç±»**ã€‚å·¥å‚æ–¹æ³•ä½¿ä¸€ä¸ªç±»çš„å®ä¾‹åŒ–å»¶è¿Ÿåˆ°å…¶å­ç±»ã€‚

ğŸ“Œ æ ¸å¿ƒæ€æƒ³: **â€œæˆ‘ä¸ç›´æ¥åˆ›å»ºäº§å“, æˆ‘æä¾›ä¸€ä¸ªåˆ›å»ºæ–¹æ³•, è®©å­ç±»å»å®ç°å…·ä½“åˆ›å»ºé€»è¾‘ã€‚â€**

> ğŸ’¡ ç±»æ¯”: æ¡†æ¶è¯´â€œä½ å¿…é¡»æä¾›ä¸€ä¸ªé€ æŒ‰é’®çš„æ–¹æ³•â€, å…·ä½“æ˜¯é€  Windows æŒ‰é’®è¿˜æ˜¯ Mac æŒ‰é’®, ç”±å­ç±»å†³å®šã€‚

ä¸â€œç®€å•å·¥å‚â€ä¸åŒ, å·¥å‚æ–¹æ³•æ¨¡å¼é€šè¿‡**ç»§æ‰¿ + å¤šæ€**å®ç°æ‰©å±•, ç¬¦åˆ**å¼€é—­åŸåˆ™**ã€‚

**é€‚ç”¨åœºæ™¯**

1. **ä¸ç¡®å®šå¯¹è±¡åˆ›å»ºç»†èŠ‚, å¸Œæœ›å­ç±»å†³å®š** â€”â€” å¦‚æ¡†æ¶æä¾›æ¥å£, ç”¨æˆ·å®ç°å…·ä½“äº§å“ã€‚
2. **éœ€è¦å°†äº§å“åˆ›å»ºä¸ä½¿ç”¨è§£è€¦** â€”â€” å®¢æˆ·ç«¯åªä¾èµ–æŠ½è±¡äº§å“å’Œåˆ›å»ºè€…ã€‚
3. **å¸Œæœ›æ”¯æŒæ‰©å±•æ–°äº§å“, è€Œä¸ä¿®æ”¹ç°æœ‰ä»£ç ** â€”â€” ç¬¦åˆå¼€é—­åŸåˆ™ã€‚
4. **å¹¶è¡Œäº§å“æ—ç»“æ„** â€”â€” å¦‚ä¸åŒå¹³å°ã€ä¸åŒæ•°æ®åº“ã€ä¸åŒæ–‡ä»¶æ ¼å¼çš„åˆ›å»ºã€‚

ğŸ“Œ å¸¸è§åº”ç”¨: 

- è·¨å¹³å° UI æ§ä»¶(Qtã€MFC ç­‰æ¡†æ¶)
- æ•°æ®åº“è¿æ¥å·¥å‚(MySQLFactoryã€PostgreSQLFactory)
- æ¸¸æˆå…³å¡ç”Ÿæˆå™¨(EasyLevelFactoryã€HardLevelFactory)
- æ—¥å¿—è®°å½•å™¨(FileLoggerFactoryã€DBLoggerFactory)
- æ’ä»¶ç³»ç»Ÿ(æ¯ä¸ªæ’ä»¶æä¾›è‡ªå·±çš„å·¥å‚)

**ä¼˜ç¼ºç‚¹**

**âœ… ä¼˜ç‚¹**

- **ç¬¦åˆå¼€é—­åŸåˆ™** â€”â€” æ–°å¢äº§å“åªéœ€æ–°å¢å…·ä½“å·¥å‚å’Œäº§å“ç±», æ— éœ€ä¿®æ”¹ç°æœ‰ä»£ç ã€‚
- **ç¬¦åˆå•ä¸€èŒè´£åŸåˆ™** â€”â€” åˆ›å»ºé€»è¾‘å°è£…åœ¨å·¥å‚å­ç±»ä¸­ã€‚
- **å®¢æˆ·ç«¯ä¸å…·ä½“äº§å“è§£è€¦** â€”â€” åªä¾èµ–æŠ½è±¡æ¥å£ã€‚
- **æ”¯æŒå¹¶è¡Œäº§å“æ—ç»“æ„** â€”â€” æ˜“äºç»„ç»‡ç›¸å…³äº§å“ã€‚
- **ä¾¿äºå•å…ƒæµ‹è¯•** â€”â€” å¯è½»æ¾ Mock å·¥å‚æ–¹æ³•ã€‚

**âŒ ç¼ºç‚¹**

- **ç±»æ•°é‡å¢åŠ ** â€”â€” æ¯ä¸ªäº§å“å¯¹åº”ä¸€ä¸ªå·¥å‚å­ç±»(æœ‰æ—¶æ˜¾å¾—â€œç±»çˆ†ç‚¸â€)ã€‚
- **ç»“æ„ç•¥å¤æ‚** â€”â€” ç›¸æ¯”â€œç®€å•å·¥å‚â€, å¤šäº†ä¸€å±‚ç»§æ‰¿ç»“æ„ã€‚
- **å®¢æˆ·ç«¯éœ€çŸ¥é“å…·ä½“å·¥å‚ç±»** â€”â€” ä»éœ€ `new WindowsDialog()`, å¯é€šè¿‡â€œæŠ½è±¡å·¥å‚â€æˆ–é…ç½®è¿›ä¸€æ­¥è§£è€¦ã€‚

**âš ï¸ æ³¨æ„äº‹é¡¹**

1. **å·¥å‚æ–¹æ³•é€šå¸¸ä¸ºè™šå‡½æ•°** â€”â€” C++ ä¸­ç”¨ `virtual` æ ‡è®°, å…è®¸å­ç±»é‡å†™ã€‚
2. **è¿”å›æ™ºèƒ½æŒ‡é’ˆç®¡ç†èµ„æº** â€”â€” ç¤ºä¾‹ä¸­ä½¿ç”¨ `std::unique_ptr` é¿å…å†…å­˜æ³„æ¼ã€‚
3. **å¯ç»“åˆæ¨¡æ¿ç®€åŒ–(æ¨¡æ¿å·¥å‚æ–¹æ³•)** â€”â€” è‹¥äº§å“æ„é€ ç®€å•, å¯ç”¨ CRTP: 

ğŸ“Œ **ä¸€å¥è¯æ€»ç»“: **

> **å·¥å‚æ–¹æ³• = â€œæˆ‘å®šä¹‰åˆ›å»ºæ¥å£, ä½ (å­ç±»)å†³å®šåˆ›å»ºè°â€, å®ç°çµæ´»æ‰©å±•, æ‹¥æŠ±å˜åŒ–ã€‚**

## ä»£ç 

```
// Shape.h
#include <iostream>
#include <memory>

// æŠ½è±¡äº§å“
class Shape {
public:
    virtual ~Shape() = default;
    virtual void draw() = 0;
};

// å…·ä½“äº§å“: åœ†å½¢
class Circle : public Shape {
public:
    void draw() override {
        std::cout << "Drawing a Circle" << std::endl;
    }
};

// å…·ä½“äº§å“: çŸ©å½¢
class Rectangle : public Shape {
public:
    void draw() override {
        std::cout << "Drawing a Rectangle" << std::endl;
    }
};

// æŠ½è±¡å·¥å‚
class ShapeFactory {
public:
    virtual ~ShapeFactory() = default;
    virtual std::unique_ptr<Shape> createShape() = 0; // å·¥å‚æ–¹æ³•
};

// å…·ä½“å·¥å‚: åœ†å½¢å·¥å‚
class CircleFactory : public ShapeFactory {
public:
    std::unique_ptr<Shape> createShape() override {
        return std::make_unique<Circle>();
    }
};

// å…·ä½“å·¥å‚: çŸ©å½¢å·¥å‚
class RectangleFactory : public ShapeFactory {
public:
    std::unique_ptr<Shape> createShape() override {
        return std::make_unique<Rectangle>();
    }
};

// å®¢æˆ·ç«¯ä»£ç 
void clientCode(std::unique_ptr<ShapeFactory> factory) {
    auto shape = factory->createShape();
    shape->draw();
}

// main.cpp
#include "Shape.h"

int main() {
    std::cout << "Client: Testing with CircleFactory:\n";
    clientCode(std::make_unique<CircleFactory>());

    std::cout << "\nClient: Testing with RectangleFactory:\n";
    clientCode(std::make_unique<RectangleFactory>());

    return 0;
}
```

## PlantUML

```
@startuml
' æŠ½è±¡äº§å“
abstract class Shape {
    +draw() : void
}

' å…·ä½“äº§å“
class Circle {
    +draw() : void
}

class Rectangle {
    +draw() : void
}

' æŠ½è±¡å·¥å‚
abstract class ShapeFactory {
    +createShape() : std::unique_ptr<Shape>
}

' å…·ä½“å·¥å‚
class CircleFactory {
    +createShape() : std::unique_ptr<Shape>
}

class RectangleFactory {
    +createShape() : std::unique_ptr<Shape>
}

' å…³ç³»
Shape <|-- Circle
Shape <|-- Rectangle

ShapeFactory <|-- CircleFactory
ShapeFactory <|-- RectangleFactory

CircleFactory ..> Circle : creates
RectangleFactory ..> Rectangle : creates

note right of ShapeFactory
    Factory Method
    declares interface
end note

note right of CircleFactory
    overrides to
    create Circle
end note

@enduml
```

![](./picture/2.FactoryMethodPattern.png)



# 5. æŠ½è±¡å·¥å‚æ¨¡å¼

## ç®€ä»‹

**æŠ½è±¡å·¥å‚æ¨¡å¼(Abstract Factory Pattern)** æ˜¯ GoF 23 ç§ç»å…¸è®¾è®¡æ¨¡å¼ä¹‹ä¸€, å±äº **åˆ›å»ºå‹æ¨¡å¼**ã€‚

> å®ƒæä¾›ä¸€ä¸ª**åˆ›å»ºä¸€ç³»åˆ—ç›¸å…³æˆ–ç›¸äº’ä¾èµ–å¯¹è±¡çš„æ¥å£**, è€Œæ— éœ€æŒ‡å®šå®ƒä»¬å…·ä½“çš„ç±»ã€‚

ğŸ“Œ æ ¸å¿ƒæ€æƒ³: **â€œä¸æ˜¯é€ ä¸€ä¸ªäº§å“, è€Œæ˜¯é€ ä¸€æ•´å¥—é£æ ¼ä¸€è‡´çš„äº§å“æ—ã€‚â€**

> ğŸ’¡ ç±»æ¯”: ä¹°å®¶å…· â€”â€” ä½ é€‰â€œåŒ—æ¬§é£æ ¼â€, å·¥å‚å°±ç»™ä½ é€ åŒ—æ¬§çš„æ²™å‘+æ¤…å­+æ¡Œå­; é€‰â€œå·¥ä¸šé£â€, å°±å…¨æ¢æˆå·¥ä¸šé£ã€‚ä½ ä¸ç”¨ä¸€ä¸ªä¸ªæŒ‡å®š, å·¥å‚æ‰“åŒ…ç»™ä½ ã€‚

æŠ½è±¡å·¥å‚æ˜¯ **å·¥å‚æ–¹æ³•æ¨¡å¼çš„æ‰©å±•** â€”â€” å·¥å‚æ–¹æ³•é’ˆå¯¹â€œå•ä¸€äº§å“â€, æŠ½è±¡å·¥å‚é’ˆå¯¹â€œäº§å“æ—â€ã€‚

**é€‚ç”¨åœºæ™¯**

1. **ç³»ç»Ÿéœ€è¦ç‹¬ç«‹äºäº§å“çš„åˆ›å»ºã€ç»„åˆå’Œè¡¨ç¤ºæ—¶ã€‚**
2. **ç³»ç»Ÿéœ€è¦ç”±å¤šä¸ªäº§å“ç³»åˆ—ä¸­çš„ä¸€ä¸ªæ¥é…ç½®æ—¶ã€‚**
3. **å¼ºè°ƒä¸€ç³»åˆ—ç›¸å…³äº§å“å¯¹è±¡çš„è®¾è®¡ä»¥ä¾¿è¿›è¡Œè”åˆä½¿ç”¨ã€‚**
4. **æä¾›ä¸€ä¸ªäº§å“ç±»åº“, è€Œåªæƒ³æ˜¾ç¤ºå®ƒä»¬çš„æ¥å£, è€Œä¸æ˜¯å®ç°æ—¶ã€‚**

ğŸ“Œ **å…¸å‹åº”ç”¨åœºæ™¯: **

- GUI è·¨å¹³å°ç»„ä»¶åº“(Windows vs Mac vs Linux é£æ ¼æ§ä»¶)
- æ¸¸æˆä¸­ä¸åŒä¸»é¢˜çš„è£…å¤‡å¥—è£…(æˆ˜å£«å¥—è£…ã€æ³•å¸ˆå¥—è£…)
- æ•°æ®åº“è®¿é—®å±‚(MySQLFactoryã€PostgreSQLFactory åˆ›å»º Connectionã€Commandã€DataReader)

**âœ… ä¸‰ã€ä¼˜ç¼ºç‚¹**

**âœ… ä¼˜ç‚¹: **

1. **åˆ†ç¦»å…·ä½“ç±»çš„ç”Ÿæˆ, å®¢æˆ·ç«¯ä¸ä¾èµ–å…·ä½“ç±»ã€‚**
2. **æ˜“äºäº¤æ¢äº§å“ç³»åˆ—** â€”â€” åªéœ€æ›´æ¢ ConcreteFactoryã€‚
3. **æœ‰åˆ©äºäº§å“ä¸€è‡´æ€§** â€”â€” ç¡®ä¿åˆ›å»ºçš„å¯¹è±¡æ˜¯é…å¥—çš„ã€å…¼å®¹çš„ã€‚
4. **ç¬¦åˆå¼€é—­åŸåˆ™(å¯¹æ‰©å±•å¼€æ”¾)** â€”â€” å¢åŠ æ–°äº§å“æ—æ—¶åªéœ€æ–°å¢å·¥å‚å’Œäº§å“ç±»ã€‚

**âŒ ç¼ºç‚¹: **

1. **éš¾ä»¥æ”¯æŒæ–°ç§ç±»çš„äº§å“** â€”â€” å¦‚æœè¦æ–°å¢ä¸€ç±»äº§å“(å¦‚æ–°å¢ TextBox), éœ€è¦ä¿®æ”¹æ‰€æœ‰å·¥å‚æ¥å£åŠå…¶å®ç°ã€‚
2. **ç±»æ•°é‡çˆ†ç‚¸** â€”â€” æ¯ä¸ªäº§å“æ— Ã— æ¯ä¸ªäº§å“ç±»å‹ = å¤§é‡ç±»ã€‚
3. **ç»“æ„å¤æ‚, å°é¡¹ç›®ä¸æ¨èã€‚**

> ğŸ’¡ æŠ½è±¡å·¥å‚é€‚åˆâ€œäº§å“æ—ç¨³å®šã€äº§å“ç±»å‹å°‘ã€æ—å¤šâ€çš„åœºæ™¯ã€‚

**âœ… æ³¨æ„äº‹é¡¹**

1. **æŠ½è±¡å·¥å‚æ¥å£åº”ç¨³å®š, é¿å…é¢‘ç¹å¢åˆ äº§å“ç±»å‹ã€‚**
2. **C++ ä¸­æ¨èè¿”å›æ™ºèƒ½æŒ‡é’ˆ(`std::unique_ptr`)ç®¡ç†èµ„æºã€‚**
3. **å·¥å‚é€šå¸¸ä¸æŒæœ‰çŠ¶æ€, å¯è®¾è®¡ä¸ºå•ä¾‹æˆ–é™æ€å·¥å‚ã€‚**
4. **é¿å…åœ¨å·¥å‚ä¸­åšå¤æ‚åˆå§‹åŒ–é€»è¾‘, ä¿æŒèŒè´£å•ä¸€ã€‚**
5. **å¦‚æœäº§å“ç±»å‹å¯èƒ½æ‰©å±•, å¯è€ƒè™‘ç»“åˆâ€œåå°„â€æˆ–â€œæ³¨å†Œæœºåˆ¶â€åŠ¨æ€æ”¯æŒã€‚**

ğŸ“Œ **ä¸€å¥è¯æ€»ç»“: **

> **æŠ½è±¡å·¥å‚ = â€œæˆ‘ç»™ä½ ä¸€å¥—é…å¥—äº§å“, ä½ æ— éœ€å…³å¿ƒå®ƒä»¬ä»å“ªæ¥, åªéœ€ç”¨å°±å¯¹äº†â€ã€‚**

## ä»£ç 

```
// GUIFactory.h
#include <iostream>
#include <memory>
#include <string>

// æŠ½è±¡äº§å“: æŒ‰é’®
class Button {
public:
    virtual ~Button() = default;
    virtual void paint() = 0;
};

// æŠ½è±¡äº§å“: å¤é€‰æ¡†
class Checkbox {
public:
    virtual ~Checkbox() = default;
    virtual void paint() = 0;
};

// æŠ½è±¡å·¥å‚
class GUIFactory {
public:
    virtual ~GUIFactory() = default;
    virtual std::unique_ptr<Button> createButton() = 0;
    virtual std::unique_ptr<Checkbox> createCheckbox() = 0;
};

// ==================== Windows å¹³å°äº§å“ ====================

class WinButton : public Button {
public:
    void paint() override {
        std::cout << "Render a button in Windows style." << std::endl;
    }
};

class WinCheckbox : public Checkbox {
public:
    void paint() override {
        std::cout << "Render a checkbox in Windows style." << std::endl;
    }
};

class WinFactory : public GUIFactory {
public:
    std::unique_ptr<Button> createButton() override {
        return std::make_unique<WinButton>();
    }

    std::unique_ptr<Checkbox> createCheckbox() override {
        return std::make_unique<WinCheckbox>();
    }
};

// ==================== Mac å¹³å°äº§å“ ====================

class MacButton : public Button {
public:
    void paint() override {
        std::cout << "Render a button in Mac style." << std::endl;
    }
};

class MacCheckbox : public Checkbox {
public:
    void paint() override {
        std::cout << "Render a checkbox in Mac style." << std::endl;
    }
};

class MacFactory : public GUIFactory {
public:
    std::unique_ptr<Button> createButton() override {
        return std::make_unique<MacButton>();
    }

    std::unique_ptr<Checkbox> createCheckbox() override {
        return std::make_unique<MacCheckbox>();
    }
};

// ==================== å®¢æˆ·ç«¯ä»£ç  ====================

void clientCode(std::unique_ptr<GUIFactory> factory) {
    auto button = factory->createButton();
    auto checkbox = factory->createCheckbox();

    button->paint();
    checkbox->paint();
}

// main.cpp
#include "GUIFactory.h"

int main() {
    std::cout << "Client: Testing client code with Windows factory:\n";
    clientCode(std::make_unique<WinFactory>());

    std::cout << "\nClient: Testing client code with Mac factory:\n";
    clientCode(std::make_unique<MacFactory>());

    return 0;
}
```

## PlantUML

```
@startuml

' ================= æŠ½è±¡å±‚ =================
abstract class GUIFactory {
    +createButton() : std::unique_ptr<Button>
    +createCheckbox() : std::unique_ptr<Checkbox>
}

abstract class Button {
    +paint() : void
}

abstract class Checkbox {
    +paint() : void
}

' ================= Windows äº§å“æ— =================
class WinFactory {
    +createButton() : std::unique_ptr<Button>
    +createCheckbox() : std::unique_ptr<Checkbox>
}

class WinButton {
    +paint() : void
}

class WinCheckbox {
    +paint() : void
}

' ================= Mac äº§å“æ— =================
class MacFactory {
    +createButton() : std::unique_ptr<Button>
    +createCheckbox() : std::unique_ptr<Checkbox>
}

class MacButton {
    +paint() : void
}

class MacCheckbox {
    +paint() : void
}

' ================= ç»§æ‰¿å…³ç³» =================
GUIFactory <|-- WinFactory
GUIFactory <|-- MacFactory

Button <|-- WinButton
Button <|-- MacButton

Checkbox <|-- WinCheckbox
Checkbox <|-- MacCheckbox

' ================= åˆ›å»ºå…³ç³» =================
WinFactory ..> WinButton : creates
WinFactory ..> WinCheckbox : creates

MacFactory ..> MacButton : creates
MacFactory ..> MacCheckbox : creates

note right of GUIFactory
    Abstract Factory
    creates a family of products
end note

note right of WinFactory
    Concrete Factory for Windows
end note

@enduml
```

![](./picture\3.AbstractFactoryPattern.png)

# 6. å•ä¾‹æ¨¡å¼

## ç®€ä»‹

> **å•ä¾‹æ¨¡å¼(Singleton Pattern)** æ˜¯ä¸€ç§åˆ›å»ºå‹è®¾è®¡æ¨¡å¼, å®ƒç¡®ä¿ä¸€ä¸ªç±»**åªæœ‰ä¸€ä¸ªå®ä¾‹**, å¹¶æä¾›ä¸€ä¸ª**å…¨å±€è®¿é—®ç‚¹**æ¥è®¿é—®è¯¥å®ä¾‹ã€‚

**æ ¸å¿ƒæ€æƒ³: **

- **ç§æœ‰åŒ–æ„é€ å‡½æ•°** â†’ é˜²æ­¢å¤–éƒ¨ `new`
- **é™æ€æˆå‘˜å˜é‡** â†’ å­˜å‚¨å”¯ä¸€å®ä¾‹
- **é™æ€æˆå‘˜å‡½æ•°** â†’ æä¾›å…¨å±€è®¿é—®æ¥å£(å¦‚ `getInstance()`

**é€‚ç”¨åœºæ™¯**

1. **éœ€è¦å…¨å±€å”¯ä¸€è®¿é—®ç‚¹çš„å¯¹è±¡**, å¦‚: 
   - é…ç½®ç®¡ç†å™¨(ConfigManager)
   - æ—¥å¿—è®°å½•å™¨(Logger)
   - æ•°æ®åº“è¿æ¥æ± (ConnectionPool)
   - çº¿ç¨‹æ± (ThreadPool)
   - åº”ç”¨ç¨‹åºä¸Šä¸‹æ–‡(ApplicationContext)
2. **èµ„æºéœ€è¦å…±äº«ä¸”æ§åˆ¶è®¿é—®æ•°é‡æ—¶**(å¦‚è®¸å¯è¯ã€ç¡¬ä»¶è®¾å¤‡é©±åŠ¨)ã€‚
3. **é¿å…é¢‘ç¹åˆ›å»ºé”€æ¯å¼€é”€å¤§çš„å¯¹è±¡**ã€‚

ğŸ“Œ **å…¸å‹åº”ç”¨åœºæ™¯: **

- æ¸¸æˆä¸­çš„â€œæ¸¸æˆç®¡ç†å™¨â€
- ç³»ç»Ÿä¸­çš„â€œè®¾ç½®ä¸­å¿ƒâ€
- å¤šçº¿ç¨‹ç¯å¢ƒä¸­çš„â€œå…¨å±€çŠ¶æ€ç®¡ç†â€

**ä¼˜ç¼ºç‚¹**

**âœ… ä¼˜ç‚¹: **

1. **ç¡®ä¿å…¨å±€å”¯ä¸€å®ä¾‹, èŠ‚çœèµ„æºã€‚**
2. **æä¾›å…¨å±€è®¿é—®ç‚¹, ä½¿ç”¨æ–¹ä¾¿ã€‚**
3. **å»¶è¿Ÿåˆå§‹åŒ–(Lazy Initialization)â€”â€” é¦–æ¬¡ä½¿ç”¨æ‰åˆ›å»ºã€‚**
4. **å¯ç»§æ‰¿æ‰©å±•(å—é™, ä½†å¯é€šè¿‡æ¨¡æ¿æˆ–ä¾èµ–æ³¨å…¥ä¼˜åŒ–)ã€‚**

**âŒ ç¼ºç‚¹: **

1. **è¿åå•ä¸€èŒè´£åŸåˆ™** â€”â€” æ—¢è¦ç®¡ç†å®ä¾‹, åˆè¦å¤„ç†ä¸šåŠ¡é€»è¾‘ã€‚
2. **éšè—ä¾èµ–å…³ç³»** â€”â€” ä¸åˆ©äºå•å…ƒæµ‹è¯•(Mock å›°éš¾)ã€‚
3. **å¤šçº¿ç¨‹ç¯å¢ƒä¸‹éœ€è€ƒè™‘çº¿ç¨‹å®‰å…¨**(C++11 åå¯ç®€åŒ–)ã€‚
4. **ç”Ÿå‘½å‘¨æœŸç®¡ç†å›°éš¾** â€”â€” ä½•æ—¶é”€æ¯ï¼Ÿè°æ¥é”€æ¯ï¼Ÿ
5. **å¯èƒ½é€ æˆâ€œå…¨å±€çŠ¶æ€æ±¡æŸ“â€**, å¯¼è‡´ä»£ç è€¦åˆåº¦é«˜ã€‚

> ğŸ’¡ ç°ä»£ C++ é¡¹ç›®ä¸­, å•ä¾‹åº”è°¨æ…ä½¿ç”¨, ä¼˜å…ˆè€ƒè™‘ä¾èµ–æ³¨å…¥(DI)æˆ–æœåŠ¡å®šä½å™¨(Service Locator)ã€‚

**æ³¨æ„äº‹é¡¹(éå¸¸é‡è¦ï¼)**

1. ğŸš¨ çº¿ç¨‹å®‰å…¨(Thread Safety)

2. ğŸš« ç¦æ­¢æ‹·è´å’Œèµ‹å€¼
3. ğŸ•’ ææ„é¡ºåºé—®é¢˜(â€œé™æ€ææ„é¡ºåºæƒ¨æ¡ˆâ€)
4. å•å…ƒæµ‹è¯•å›°éš¾

**ğŸ“Œ ä¸€å¥è¯æ€»ç»“: **

> **å•ä¾‹æ¨¡å¼ = â€œæˆ‘ä¿è¯å…¨å±€åªæœ‰ä¸€ä¸ªæˆ‘, è°è¦ç”¨, æ‰¾æˆ‘æ‹¿â€ã€‚**

## ä»£ç 

```
// Singleton.h
#pragma once
#include <iostream>

class Singleton {
private:
    // ç§æœ‰æ„é€ 
    Singleton() {
        std::cout << "Singleton created!" << std::endl;
    }

    // ç¦æ­¢æ‹·è´
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

public:
    // C++11 Magic Static: çº¿ç¨‹å®‰å…¨ + å»¶è¿Ÿåˆå§‹åŒ– + è‡ªåŠ¨ææ„
    static Singleton& getInstance() {
        static Singleton instance;
        return instance;
    }

    void doSomething() {
        std::cout << "Doing something..." << std::endl;
    }

    ~Singleton() {
        std::cout << "Singleton destroyed!" << std::endl;
    }
};

// main.cpp
#include "Singleton.h"

int main() {
    auto& s1 = Singleton::getInstance();
    s1.doSomething();

    auto& s2 = Singleton::getInstance();
    std::cout << (&s1 == &s2 ? "Same instance!" : "Different!") << std::endl;

    return 0;
}
```

## PlantUML

```
@startuml

class Singleton {
    -{static} instance : Singleton*
    -Singleton()
    +{static} getInstance() : Singleton&
    +doSomething() : void
    -{delete} Singleton(const Singleton&)
    -{delete} operator=(const Singleton&)
}

note right of Singleton::getInstance
    C++11 Magic Static:
    - Thread-safe
    - Lazy initialization
    - Auto destruction
end note

note bottom of Singleton
    Ensures only one instance exists
    and provides global access point.
end note

@enduml
```

![](./picture/4.SingletonPattern.png)

# 7. å»ºé€ è€…æ¨¡å¼

## ç®€ä»‹

> **å»ºé€ è€…æ¨¡å¼(Builder Pattern)** æ˜¯ä¸€ç§åˆ›å»ºå‹è®¾è®¡æ¨¡å¼, å®ƒå°†ä¸€ä¸ª**å¤æ‚å¯¹è±¡çš„æ„å»ºè¿‡ç¨‹ä¸å…¶è¡¨ç¤ºåˆ†ç¦»**, ä½¿å¾—åŒæ ·çš„æ„å»ºè¿‡ç¨‹å¯ä»¥åˆ›å»ºä¸åŒçš„è¡¨ç¤ºã€‚

ğŸ¯ æ ¸å¿ƒæ€æƒ³: 

- å°†å¯¹è±¡çš„**æ„é€ è¿‡ç¨‹åˆ†è§£ä¸ºå¤šä¸ªæ­¥éª¤**(å¦‚ setPartA, setPartB, setPartCâ€¦)
- ä½¿ç”¨ä¸€ä¸ªâ€œå¯¼æ¼”â€(Director)æ§åˆ¶æ„å»ºæµç¨‹(å¯é€‰)
- æœ€ç»ˆè¿”å›å®Œæ•´æ„å»ºå¥½çš„å¯¹è±¡

> ğŸ’¡ é€‚ç”¨äº: å¯¹è±¡æ„é€ å¤æ‚ã€å‚æ•°å¤šã€æ„é€ æ­¥éª¤å¤šã€éœ€è¦çµæ´»ç»„åˆä¸åŒéƒ¨åˆ†ã€‚

ğŸ§© **ç»“æ„ç»„æˆ**: 

| è§’è‰²              | è¯´æ˜                                             |
| ----------------- | ------------------------------------------------ |
| `Product`         | è¢«æ„å»ºçš„å¤æ‚å¯¹è±¡(å¦‚æ±½è½¦ã€SQLæŸ¥è¯¢ã€HTMLæ–‡æ¡£)    |
| `Builder`         | æŠ½è±¡å»ºé€ è€…, å®šä¹‰æ„å»ºå„éƒ¨åˆ†çš„æ¥å£                 |
| `ConcreteBuilder` | å…·ä½“å»ºé€ è€…, å®ç°æ„å»ºæ­¥éª¤, æä¾›è·å–æœ€ç»ˆäº§å“çš„æ¥å£ |
| `Director`        | (å¯é€‰)æŒ‡å¯¼æ„å»ºè¿‡ç¨‹, å°è£…æ„å»ºæµç¨‹               |

âœ…**é€‚ç”¨åœºæ™¯**

1. **åˆ›å»ºå¤æ‚å¯¹è±¡, å…¶æ„é€ è¿‡ç¨‹åŒ…å«å¤šä¸ªæ­¥éª¤æˆ–éƒ¨ä»¶ã€‚**
2. **æ„é€ è¿‡ç¨‹å¿…é¡»å…è®¸æ„é€ ä¸åŒçš„è¡¨ç¤º(å¦‚ä¸åŒé…ç½®çš„æ±½è½¦ã€ä¸åŒé£æ ¼çš„æ–‡æ¡£)ã€‚**
3. **å¯¹è±¡çš„æ„é€ ç®—æ³•åº”ç‹¬ç«‹äºç»„æˆéƒ¨åˆ†å’Œè£…é…æ–¹å¼ã€‚**
4. **æ„é€ è¿‡ç¨‹éœ€è¦è¢«å¤ç”¨æˆ–æ ‡å‡†åŒ–(å¦‚â€œæ ‡å‡†å¥—é¤â€ã€â€œè±ªåå¥—é¤â€)ã€‚**

ğŸ“Œ **å…¸å‹åº”ç”¨åœºæ™¯: **

- æ„å»º SQL æŸ¥è¯¢è¯­å¥(SELECT, FROM, WHERE, GROUP BYâ€¦)
- æ„å»º HTML / XML æ–‡æ¡£
- æ¸¸æˆè§’è‰²åˆ›å»º(ä¸åŒè£…å¤‡ã€å±æ€§ç»„åˆ)
- æ±½è½¦/ç”µè„‘é…ç½®å™¨(é€‰é… CPUã€å†…å­˜ã€ç¡¬ç›˜â€¦)
- æµå¼ API(å¦‚ std::ostringstream, Qt çš„ä¿¡å·æ§½è¿æ¥å™¨)

**ä¼˜ç¼ºç‚¹**

**âœ… ä¼˜ç‚¹: **

1. **åˆ†ç¦»æ„é€ ä¸è¡¨ç¤º** â†’ åŒä¸€æ„å»ºè¿‡ç¨‹å¯åˆ›å»ºä¸åŒäº§å“ã€‚
2. **æ›´ç²¾ç»†æ§åˆ¶æ„é€ è¿‡ç¨‹** â†’ å¯è·³è¿‡ã€é‡å¤ã€æ¡ä»¶åŒ–æŸäº›æ­¥éª¤ã€‚
3. **ä»£ç å¯è¯»æ€§é«˜** â†’ æ­¥éª¤æ¸…æ™°, æ˜“äºç»´æŠ¤ã€‚
4. **æ”¯æŒ Fluent Interface(æµå¼è°ƒç”¨)** â†’ æå‡ API ä½“éªŒã€‚
5. **ç¬¦åˆå¼€é—­åŸåˆ™** â†’ æ–°å¢ Builder ä¸å½±å“åŸæœ‰ä»£ç ã€‚

**âŒ ç¼ºç‚¹: **

1. **ç±»æ•°é‡å¢åŠ ** â†’ æ¯ä¸ªäº§å“å˜ä½“å¯èƒ½éœ€è¦ä¸€ä¸ª Builderã€‚
2. **ç»“æ„ç•¥å¤æ‚** â†’ å°é¡¹ç›®æˆ–ç®€å•å¯¹è±¡ä¸æ¨èä½¿ç”¨ã€‚
3. **Director éå¿…éœ€** â†’ æœ‰æ—¶å®¢æˆ·ç«¯ç›´æ¥è°ƒç”¨ Builder æ›´çµæ´»ã€‚

âœ…**æ³¨æ„äº‹é¡¹**

1. **Builder é€šå¸¸ä¸æŒæœ‰æœ€ç»ˆäº§å“çŠ¶æ€, è€Œæ˜¯é€æ­¥æ„å»ºã€‚**
2. **æœ€ç»ˆäº§å“åº”æä¾›â€œè·å–ç»“æœâ€æ–¹æ³•(å¦‚ `getProduct()`)ã€‚**
3. **å¯é€‰: æä¾›â€œé‡ç½®â€æ–¹æ³•, ä»¥ä¾¿ Builder é‡ç”¨ã€‚**
4. **C++ ä¸­æ¨èè¿”å› `std::unique_ptr` æˆ–å€¼å¯¹è±¡, é¿å…è£¸æŒ‡é’ˆã€‚**
5. **æ”¯æŒ Fluent Interface æ—¶, æ¯ä¸ª setter è¿”å› `\*this`ã€‚**
6. **çº¿ç¨‹å®‰å…¨: Builder é€šå¸¸éçº¿ç¨‹å®‰å…¨, åº”é¿å…å…±äº«ã€‚**

> **è®°å¿†å£è¯€: **
>
> - **å·¥å‚ â†’ â€œç»™ä½ ä¸€ä¸ªæˆå“â€**
> - **å»ºé€ è€… â†’ â€œä¸€æ­¥æ­¥å¸®ä½ æ­å‡ºæ¥â€**

ğŸ“Œ **ç»ˆæå»ºè®®: **

> **ç°ä»£ C++ ä¸­, ä¼˜å…ˆè€ƒè™‘ Fluent Builder(æµå¼æ¥å£), å®ƒæ›´ç›´è§‚ã€æ›´æ˜“ç”¨ã€æ›´ç¬¦åˆç›´è§‰ã€‚Director å¯é€‰, å®¢æˆ·ç«¯ç›´æ¥è°ƒç”¨ Builder å¾€å¾€æ›´çµæ´»ã€‚**



## ä»£ç 

```
// Computer.h
#include <iostream>
#include <string>
#include <memory>

// äº§å“ç±»: è®¡ç®—æœº
class Computer {
private:
    std::string cpu;
    std::string ram;
    std::string storage;
    bool hasGPU = false;
    bool hasSSD = false;

public:
    // è®¾ç½®å™¨(å¯é€‰, Builder ä¹Ÿå¯ç›´æ¥è®¿é—®ç§æœ‰æˆå‘˜, æˆ–è®¾ä¸º friend)
    void setCPU(const std::string& c) { cpu = c; }
    void setRAM(const std::string& r) { ram = r; }
    void setStorage(const std::string& s) { storage = s; }
    void setGPU(bool g) { hasGPU = g; }
    void setSSD(bool s) { hasSSD = s; }

    void show() const {
        std::cout << "=== Computer Configuration ===\n";
        std::cout << "CPU: " << cpu << "\n";
        std::cout << "RAM: " << ram << "\n";
        std::cout << "Storage: " << storage << "\n";
        std::cout << "GPU: " << (hasGPU ? "Yes" : "No") << "\n";
        std::cout << "SSD: " << (hasSSD ? "Yes" : "No") << "\n";
        std::cout << "=============================\n\n";
    }
};

// æŠ½è±¡å»ºé€ è€…
class ComputerBuilder {
public:
    virtual ~ComputerBuilder() = default;
    virtual void buildCPU() = 0;
    virtual void buildRAM() = 0;
    virtual void buildStorage() = 0;
    virtual void buildGPU() = 0;
    virtual void buildSSD() = 0;
    virtual std::unique_ptr<Computer> getComputer() = 0;
};

// å…·ä½“å»ºé€ è€…: æ¸¸æˆç”µè„‘
class GamingComputerBuilder : public ComputerBuilder {
private:
    std::unique_ptr<Computer> computer;

public:
    GamingComputerBuilder() {
        computer = std::make_unique<Computer>();
    }

    void buildCPU() override {
        computer->setCPU("Intel i9-13900K");
    }

    void buildRAM() override {
        computer->setRAM("32GB DDR5");
    }

    void buildStorage() override {
        computer->setStorage("2TB NVMe");
    }

    void buildGPU() override {
        computer->setGPU(true);
    }

    void buildSSD() override {
        computer->setSSD(true);
    }

    std::unique_ptr<Computer> getComputer() override {
        return std::move(computer);
    }
};

// å…·ä½“å»ºé€ è€…: åŠå…¬ç”µè„‘
class OfficeComputerBuilder : public ComputerBuilder {
private:
    std::unique_ptr<Computer> computer;

public:
    OfficeComputerBuilder() {
        computer = std::make_unique<Computer>();
    }

    void buildCPU() override {
        computer->setCPU("Intel i5-13400");
    }

    void buildRAM() override {
        computer->setRAM("16GB DDR4");
    }

    void buildStorage() override {
        computer->setStorage("512GB SSD");
    }

    void buildGPU() override {
        computer->setGPU(false);
    }

    void buildSSD() override {
        computer->setSSD(true);
    }

    std::unique_ptr<Computer> getComputer() override {
        return std::move(computer);
    }
};

// å¯¼æ¼”ç±»(å¯é€‰): å°è£…æ„å»ºæµç¨‹
class ComputerDirector {
public:
    static void constructGamingComputer(ComputerBuilder& builder) {
        builder.buildCPU();
        builder.buildRAM();
        builder.buildStorage();
        builder.buildGPU();
        builder.buildSSD();
    }

    static void constructOfficeComputer(ComputerBuilder& builder) {
        builder.buildCPU();
        builder.buildRAM();
        builder.buildStorage();
        builder.buildSSD();
        // ä¸è£…ç‹¬ç«‹æ˜¾å¡
    }
};

// å®¢æˆ·ç«¯ä»£ç 
#include "Computer.h"

int main() {
    // æ–¹å¼1: ä½¿ç”¨ Director
    std::cout << "=== Using Director ===\n";
    GamingComputerBuilder gamingBuilder;
    ComputerDirector::constructGamingComputer(gamingBuilder);
    auto gamingPC = gamingBuilder.getComputer();
    gamingPC->show();

    // æ–¹å¼2: å®¢æˆ·ç«¯ç›´æ¥æ§åˆ¶æ„å»ºæ­¥éª¤(æ›´çµæ´»)
    std::cout << "=== Manual Building ===\n";
    OfficeComputerBuilder officeBuilder;
    officeBuilder.buildCPU();
    officeBuilder.buildRAM();
    officeBuilder.buildStorage();
    officeBuilder.buildSSD();
    // è·³è¿‡ buildGPU()
    auto officePC = officeBuilder.getComputer();
    officePC->show();

    return 0;
}
```

âœ… è¿›é˜¶: Fluent Builder(æµå¼æ¥å£)

```
class FluentComputerBuilder {
private:
    std::unique_ptr<Computer> computer;

public:
    FluentComputerBuilder() : computer(std::make_unique<Computer>()) {}

    FluentComputerBuilder& withCPU(const std::string& cpu) {
        computer->setCPU(cpu);
        return *this; // è¿”å›è‡ªèº«, æ”¯æŒé“¾å¼è°ƒç”¨
    }

    FluentComputerBuilder& withRAM(const std::string& ram) {
        computer->setRAM(ram);
        return *this;
    }

    FluentComputerBuilder& withStorage(const std::string& storage) {
        computer->setStorage(storage);
        return *this;
    }

    FluentComputerBuilder& withGPU() {
        computer->setGPU(true);
        return *this;
    }

    std::unique_ptr<Computer> build() {
        return std::move(computer);
    }
};

// ä½¿ç”¨æ–¹å¼: 
auto customPC = FluentComputerBuilder()
    .withCPU("AMD Ryzen 9")
    .withRAM("64GB DDR5")
    .withStorage("4TB SSD")
    .withGPU()
    .build();

customPC->show();
```

## PlantUML

```
@startuml

' äº§å“
class Computer {
    -cpu: string
    -ram: string
    -storage: string
    -hasGPU: bool
    -hasSSD: bool
    +setCPU(cpu: string)
    +setRAM(ram: string)
    +setStorage(storage: string)
    +setGPU(gpu: bool)
    +setSSD(ssd: bool)
    +show() : void
}

' æŠ½è±¡å»ºé€ è€…
abstract class ComputerBuilder {
    +buildCPU() : void
    +buildRAM() : void
    +buildStorage() : void
    +buildGPU() : void
    +buildSSD() : void
    +getComputer() : std::unique_ptr<Computer>
}

' å…·ä½“å»ºé€ è€…
class GamingComputerBuilder {
    -computer: std::unique_ptr<Computer>
    +buildCPU()
    +buildRAM()
    +buildStorage()
    +buildGPU()
    +buildSSD()
    +getComputer() : std::unique_ptr<Computer>
}

class OfficeComputerBuilder {
    -computer: std::unique_ptr<Computer>
    +buildCPU()
    +buildRAM()
    +buildStorage()
    +buildGPU()
    +buildSSD()
    +getComputer() : std::unique_ptr<Computer>
}

' å¯¼æ¼”(å¯é€‰)
class ComputerDirector {
    +{static} constructGamingComputer(builder: ComputerBuilder&)
    +{static} constructOfficeComputer(builder: ComputerBuilder&)
}

' å…³ç³»
ComputerBuilder <|-- GamingComputerBuilder
ComputerBuilder <|-- OfficeComputerBuilder

GamingComputerBuilder ..> Computer : builds
OfficeComputerBuilder ..> Computer : builds

ComputerDirector ..> ComputerBuilder : uses

note right of ComputerBuilder
    Defines steps to build
    a Computer.
end note

note bottom of ComputerDirector
    Optional: Encapsulates
    common build sequences.
end note

@enduml
```

![](./picture/5.BuilderPattern.png)

# 8. åŸå‹æ¨¡å¼

## ç®€ä»‹

> **åŸå‹æ¨¡å¼(Prototype Pattern)** æ˜¯ä¸€ç§åˆ›å»ºå‹è®¾è®¡æ¨¡å¼, å®ƒé€šè¿‡**å¤åˆ¶ç°æœ‰å¯¹è±¡(åŸå‹)** æ¥åˆ›å»ºæ–°å¯¹è±¡, è€Œä¸æ˜¯é€šè¿‡ `new` è°ƒç”¨æ„é€ å‡½æ•°ã€‚

ğŸ¯ **æ ¸å¿ƒæ€æƒ³: **

- **â€œå…‹éš†â€ä»£æ›¿â€œæ„é€ â€**
- å®šä¹‰ä¸€ä¸ª `clone()` æ¥å£, ç”±å­ç±»å®ç°å…·ä½“çš„å¤åˆ¶é€»è¾‘
- å®¢æˆ·ç«¯ä¸å…³å¿ƒå¯¹è±¡åˆ›å»ºç»†èŠ‚, åªéœ€å¤åˆ¶åŸå‹å³å¯

> ğŸ’¡ é€‚ç”¨äº: å¯¹è±¡åˆ›å»ºæˆæœ¬é«˜ã€ç»“æ„å¤æ‚ã€æˆ–éœ€åŠ¨æ€é…ç½®å¯¹è±¡æ—¶ã€‚

ğŸ§© **ç»“æ„ç»„æˆ: **

| è§’è‰²                | è¯´æ˜                             |
| ------------------- | -------------------------------- |
| `Prototype`         | å£°æ˜å…‹éš†æ¥å£(å¦‚ `clone()`)     |
| `ConcretePrototype` | å®ç°å…‹éš†æ–¹æ³•, è¿”å›è‡ªèº«å‰¯æœ¬       |
| `Client`            | æŒæœ‰åŸå‹å¯¹è±¡, é€šè¿‡å…‹éš†åˆ›å»ºæ–°å¯¹è±¡ |

âœ…**é€‚ç”¨åœºæ™¯**

1. **å¯¹è±¡åˆ›å»ºæˆæœ¬é«˜(å¦‚éœ€ä»æ•°æ®åº“/ç½‘ç»œåŠ è½½ã€å¤æ‚åˆå§‹åŒ–)**
2. **ç³»ç»Ÿéœ€ç‹¬ç«‹äºå¯¹è±¡çš„åˆ›å»ºã€ç»„åˆå’Œè¡¨ç¤º**
3. **è¿è¡Œæ—¶åŠ¨æ€å†³å®šåˆ›å»ºå¯¹è±¡çš„ç§ç±»(é€šè¿‡é…ç½®åŸå‹æ± )**
4. **é¿å…æ„å»ºç±»å±‚æ¬¡çš„å·¥å‚(ç”¨å…‹éš†ä»£æ›¿å·¥å‚)**
5. **éœ€è¦â€œå¯¹è±¡æ¨¡æ¿â€åŠŸèƒ½(å¦‚æ¸¸æˆä¸­çš„æ€ªç‰©æ¨¡æ¿ã€æ–‡æ¡£æ¨¡æ¿)**

ğŸ“Œ **å…¸å‹åº”ç”¨åœºæ™¯: **

- æ¸¸æˆä¸­å¤§é‡ç›¸åŒæ€ªç‰©/é“å…·çš„ç”Ÿæˆ(å…‹éš†æ¨¡æ¿)
- å›¾å½¢ç¼–è¾‘å™¨ä¸­å¤åˆ¶å¤æ‚å›¾å½¢å¯¹è±¡
- é…ç½®ç®¡ç†ç³»ç»Ÿä¸­å¤åˆ¶é¢„è®¾é…ç½®å¯¹è±¡
- å¤æ‚å¯¹è±¡åˆå§‹åŒ–åä½œä¸ºâ€œé»˜è®¤æ¨¡æ¿â€ä¾›åç»­å¤åˆ¶

âœ… **ä¼˜ç¼ºç‚¹**

âœ… ä¼˜ç‚¹: 

1. **éšè—åˆ›å»ºç»†èŠ‚** â†’ å®¢æˆ·ç«¯æ— éœ€çŸ¥é“å…·ä½“ç±»ã€‚
2. **æ€§èƒ½ä¼˜åŒ–** â†’ é¿å…é‡å¤æ˜‚è´µåˆå§‹åŒ–ã€‚
3. **æ”¯æŒåŠ¨æ€é…ç½®** â†’ è¿è¡Œæ—¶æ›¿æ¢åŸå‹å¯¹è±¡ã€‚
4. **ç®€åŒ–å¯¹è±¡åˆ›å»º** â†’ æ— éœ€å¯¹åº”æ¯ä¸ªç±»å†™å·¥å‚ã€‚
5. **å¯ç»“åˆâ€œåŸå‹æ³¨å†Œè¡¨â€å®ç°é…ç½®åŒ–åˆ›å»ºã€‚**

âŒ ç¼ºç‚¹: 

1. **å¿…é¡»å®ç°å…‹éš†æ–¹æ³•** â†’ æ¯ä¸ªå­ç±»éƒ½è¦å†™ `clone()`ã€‚
2. **æ·±æ‹·è´å®ç°å¤æ‚** â†’ æ¶‰åŠæŒ‡é’ˆã€èµ„æºç®¡ç†æ—¶å®¹æ˜“å‡ºé”™ã€‚
3. **ç ´åå°è£…æ€§** â†’ å…‹éš†å¯èƒ½éœ€è®¿é—®ç§æœ‰æˆå‘˜(å¯å£°æ˜ä¸º `friend` æˆ–æä¾›å¤åˆ¶æ„é€ )ã€‚
4. **å¯¹â€œä¸å¯å˜å¯¹è±¡â€æ— æ„ä¹‰** â†’ å¦‚å…¨æ˜¯ `const` æˆå‘˜ã€‚

âœ… **æ³¨æ„äº‹é¡¹(éå¸¸é‡è¦ï¼)**

1. ğŸš¨ æ·±æ‹·è´ vs æµ…æ‹·è´(C++ æ ¸å¿ƒé—®é¢˜ï¼)

- **æµ…æ‹·è´(é»˜è®¤)**: åªå¤åˆ¶æŒ‡é’ˆå€¼ â†’ å¤šä¸ªå¯¹è±¡å…±äº«åŒä¸€å—å†…å­˜ â†’ å±é™©ï¼
- **æ·±æ‹·è´**: å¤åˆ¶æŒ‡é’ˆæŒ‡å‘çš„å†…å®¹ â†’ ç‹¬ç«‹å‰¯æœ¬ â†’ å®‰å…¨ï¼

âœ… **å¿…é¡»æ‰‹åŠ¨å®ç°æ·±æ‹·è´**, æˆ–ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆ + è‡ªå®šä¹‰å…‹éš†ã€‚

2. ğŸ“Œ å®ç° `clone()` çš„å¸¸è§æ–¹å¼: 

æ–¹å¼1: çº¯è™šå‡½æ•° + å­ç±» override(æ¨è)

æ–¹å¼2: ä½¿ç”¨å¤åˆ¶æ„é€ å‡½æ•°(éœ€æš´éœ²æˆ–å£°æ˜ä¸º friend)

3. ğŸ§© èµ„æºç®¡ç†å»ºè®®: 

- ä½¿ç”¨ `std::unique_ptr` / `std::shared_ptr` ç®¡ç†åŠ¨æ€èµ„æº
- è‹¥å«è£¸æŒ‡é’ˆ, å¿…é¡»åœ¨ `clone()` ä¸­æ‰‹åŠ¨ `new` + æ·±æ‹·è´
- è€ƒè™‘ä½¿ç”¨â€œå¤åˆ¶æ„é€ å‡½æ•° + èµ‹å€¼æ“ä½œç¬¦â€å®ç° RAII

4. ğŸ§ª å¯ç»“åˆâ€œåŸå‹æ³¨å†Œè¡¨â€å®ç°åŠ¨æ€åˆ›å»º

â€‹	std::map<std::string, std::unique_ptr<Prototype>> prototypeRegistry;

â€‹	å®¢æˆ·ç«¯é€šè¿‡ key è·å–åŸå‹å¹¶å…‹éš†, å®ç°â€œé…ç½®åŒ–å¯¹è±¡åˆ›å»ºâ€ã€‚

ğŸ“Œ **ç»ˆæå»ºè®®: **

> **ç°ä»£ C++ ä¸­, è‹¥å¯¹è±¡ä¸å«è£¸æŒ‡é’ˆæˆ–å¤æ‚èµ„æº, ä½¿ç”¨é»˜è®¤å¤åˆ¶æ„é€ å³å¯; è‹¥å«èµ„æº, ä¼˜å…ˆä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆæˆ–å®¹å™¨, é¿å…æ‰‹åŠ¨ç®¡ç†å†…å­˜ã€‚åŸå‹æ¨¡å¼åœ¨æ¸¸æˆå¼€å‘ã€å›¾å½¢ç¼–è¾‘å™¨ã€é…ç½®ç³»ç»Ÿä¸­éå¸¸å®ç”¨ï¼**

æŒæ¡åŸå‹æ¨¡å¼, ä½ å°±èƒ½é«˜æ•ˆâ€œå…‹éš†â€å¯¹è±¡, é¿å…é‡å¤åˆå§‹åŒ–å¼€é”€, æå‡ç³»ç»Ÿæ€§èƒ½å’Œçµæ´»æ€§ï¼

## ä»£ç 

```
// Prototype.h
#include <iostream>
#include <string>
#include <memory>
#include <unordered_map>

// æŠ½è±¡åŸå‹
class EnemyPrototype {
public:
    virtual ~EnemyPrototype() = default;

    // çº¯è™šå…‹éš†å‡½æ•°
    virtual std::unique_ptr<EnemyPrototype> clone() const = 0;

    // ä¸šåŠ¡æ–¹æ³•
    virtual void showInfo() const = 0;
    virtual void fight() const = 0;
};

// å…·ä½“åŸå‹: å“¥å¸ƒæ—
class Goblin : public EnemyPrototype {
private:
    std::string name;
    int health;
    int damage;

public:
    Goblin(const std::string& n = "Goblin", int h = 50, int d = 10)
        : name(n), health(h), damage(d) {}

    // å®ç°æ·±æ‹·è´å…‹éš†
    std::unique_ptr<EnemyPrototype> clone() const override {
        return std::make_unique<Goblin>(*this); // è°ƒç”¨å¤åˆ¶æ„é€ (é»˜è®¤å³å¯, æ— æŒ‡é’ˆ)
    }

    void showInfo() const override {
        std::cout << "[Goblin] Name: " << name << ", Health: " << health << ", Damage: " << damage << std::endl;
    }

    void fight() const override {
        std::cout << name << " attacks with " << damage << " damage!" << std::endl;
    }

    // å¯é€‰: æä¾›ä¿®æ”¹æ–¹æ³•ç”¨äºé…ç½®æ¨¡æ¿
    void setHealth(int h) { health = h; }
    void setDamage(int d) { damage = d; }
    void setName(const std::string& n) { name = n; }
};

// å…·ä½“åŸå‹: å·¨é­”
class Troll : public EnemyPrototype {
private:
    std::string name;
    int health;
    int damage;
    bool regenerates;

public:
    Troll(const std::string& n = "Troll", int h = 100, int d = 20, bool regen = true)
        : name(n), health(h), damage(d), regenerates(regen) {}

    std::unique_ptr<EnemyPrototype> clone() const override {
        return std::make_unique<Troll>(*this);
    }

    void showInfo() const override {
        std::cout << "[Troll] Name: " << name << ", Health: " << health
                  << ", Damage: " << damage << ", Regen: " << (regenerates ? "Yes" : "No") << std::endl;
    }

    void fight() const override {
        std::cout << name << " smashes for " << damage << " damage!" << std::endl;
        if (regenerates) std::cout << name << " starts regenerating health!\n";
    }
};

// åŸå‹ç®¡ç†å™¨(æ³¨å†Œè¡¨)
class EnemyPrototypeManager {
private:
    std::unordered_map<std::string, std::unique_ptr<EnemyPrototype>> prototypes;

public:
    void registerPrototype(const std::string& key, std::unique_ptr<EnemyPrototype> prototype) {
        prototypes[key] = std::move(prototype);
    }

    std::unique_ptr<EnemyPrototype> create(const std::string& key) const {
        auto it = prototypes.find(key);
        if (it != prototypes.end() && it->second) {
            return it->second->clone();
        }
        throw std::runtime_error("Prototype not found: " + key);
    }
};

// main.cpp
#include "Prototype.h"

int main() {
    // åˆ›å»ºåŸå‹æ¨¡æ¿
    auto goblinTemplate = std::make_unique<Goblin>("Green Goblin", 60, 15);
    auto trollTemplate = std::make_unique<Troll>("Cave Troll", 120, 25, true);

    // æ³¨å†Œåˆ°ç®¡ç†å™¨
    EnemyPrototypeManager manager;
    manager.registerPrototype("goblin", std::move(goblinTemplate));
    manager.registerPrototype("troll", std::move(trollTemplate));

    // é€šè¿‡å…‹éš†åˆ›å»ºæ–°å¯¹è±¡
    std::cout << "=== Creating enemies via Prototype ===\n";
    auto enemy1 = manager.create("goblin");
    auto enemy2 = manager.create("troll");
    auto enemy3 = manager.create("goblin"); // å†å…‹éš†ä¸€ä¸ªå“¥å¸ƒæ—

    enemy1->showInfo();
    enemy1->fight();

    enemy2->showInfo();
    enemy2->fight();

    enemy3->showInfo();
    enemy3->fight();

    return 0;
}
```

âœ… å«æŒ‡é’ˆæˆå‘˜çš„æ·±æ‹·è´ç¤ºä¾‹(é‡è¦ï¼)

```
class DeepCopyExample : public EnemyPrototype {
private:
    std::string* name; // å‡è®¾ç”¨è£¸æŒ‡é’ˆ(å®é™…æ¨èç”¨ std::string)
    int health;

public:
    DeepCopyExample(const std::string& n = "Default", int h = 100) 
        : health(h) {
        name = new std::string(n);
    }

    // æ·±æ‹·è´å¤åˆ¶æ„é€ 
    DeepCopyExample(const DeepCopyExample& other)
        : health(other.health) {
        name = new std::string(*other.name); // æ·±æ‹·è´ï¼
    }

    // å¿…é¡»é‡è½½èµ‹å€¼æ“ä½œç¬¦(Rule of Three)
    DeepCopyExample& operator=(const DeepCopyExample& other) {
        if (this != &other) {
            delete name;
            name = new std::string(*other.name);
            health = other.health;
        }
        return *this;
    }

    ~DeepCopyExample() {
        delete name;
    }

    std::unique_ptr<EnemyPrototype> clone() const override {
        return std::make_unique<DeepCopyExample>(*this); // è°ƒç”¨å¤åˆ¶æ„é€ 
    }

    void showInfo() const override {
        std::cout << "Name: " << *name << ", Health: " << health << std::endl;
    }

    void fight() const override {
        std::cout << *name << " fights!\n";
    }
};
```

## PlantUML

```
@startuml

' æŠ½è±¡åŸå‹
abstract class EnemyPrototype {
    +clone() : std::unique_ptr<EnemyPrototype>
    +showInfo() : void
    +fight() : void
}

' å…·ä½“åŸå‹
class Goblin {
    -name: string
    -health: int
    -damage: int
    +clone() : std::unique_ptr<EnemyPrototype>
    +showInfo() : void
    +fight() : void
    +setHealth(h: int)
    +setDamage(d: int)
}

class Troll {
    -name: string
    -health: int
    -damage: int
    -regenerates: bool
    +clone() : std::unique_ptr<EnemyPrototype>
    +showInfo() : void
    +fight() : void
}

' åŸå‹ç®¡ç†å™¨
class EnemyPrototypeManager {
    -prototypes: map<string, unique_ptr<EnemyPrototype>>
    +registerPrototype(key: string, prototype: unique_ptr<EnemyPrototype>)
    +create(key: string) : unique_ptr<EnemyPrototype>
}

' å…³ç³»
EnemyPrototype <|-- Goblin
EnemyPrototype <|-- Troll

EnemyPrototypeManager o-- EnemyPrototype : holds prototypes

note right of EnemyPrototype::clone
    Pure virtual function
    Subclasses implement
    deep copy logic.
end note

note bottom of EnemyPrototypeManager
    Optional registry for
    dynamic prototype access.
end note

@enduml
```

![](./picture/6.PrototypePattern.png)

# ğŸ”Œç»“æ„å‹æ¨¡å¼

# 9. é€‚é…å™¨æ¨¡å¼

## ç®€ä»‹

> **é€‚é…å™¨æ¨¡å¼(Adapter Pattern)** æ˜¯ä¸€ç§ç»“æ„å‹è®¾è®¡æ¨¡å¼, å®ƒ**å°†ä¸€ä¸ªç±»çš„æ¥å£è½¬æ¢æˆå®¢æˆ·æœŸæœ›çš„å¦ä¸€ä¸ªæ¥å£**, ä½¿å¾—åŸæœ¬ç”±äºæ¥å£ä¸å…¼å®¹è€Œä¸èƒ½ä¸€èµ·å·¥ä½œçš„ç±»å¯ä»¥ååŒå·¥ä½œã€‚

ğŸ¯ **æ ¸å¿ƒæ€æƒ³: **

- **â€œæ¥å£è½¬æ¢å™¨â€** â€”â€” åƒç”µæºé€‚é…å™¨ä¸€æ ·, æŠŠâ€œä¸åŒ¹é…çš„æ’å¤´â€å˜æˆâ€œåŒ¹é…çš„æ’å¤´â€
- è§£å†³â€œè€æ¥å£â€ä¸â€œæ–°éœ€æ±‚â€ä¹‹é—´çš„ä¸å…¼å®¹é—®é¢˜
- ä¸ä¿®æ”¹åŸæœ‰ç±», é€šè¿‡â€œåŒ…è£…â€å®ç°æ¥å£è½¬æ¢

> ğŸ’¡ é€‚ç”¨äº: é›†æˆç¬¬ä¸‰æ–¹åº“ã€æ—§ç³»ç»Ÿæ”¹é€ ã€æ¥å£æ ‡å‡†åŒ–ç­‰åœºæ™¯ã€‚

ğŸ§© **ç»“æ„ç»„æˆ: **

| è§’è‰²      | è¯´æ˜                                            |
| --------- | ----------------------------------------------- |
| `Target`  | å®¢æˆ·ç«¯æœŸæœ›çš„æ¥å£(æŠ½è±¡ç±»æˆ–æ¥å£)                |
| `Adaptee` | å·²å­˜åœ¨çš„ã€ä½†æ¥å£ä¸å…¼å®¹çš„ç±»(â€œè¢«é€‚é…è€…â€)        |
| `Adapter` | é€‚é…å™¨, ç»§æ‰¿/ç»„åˆ `Adaptee`, å®ç° `Target` æ¥å£ |

âœ… **é€‚ç”¨åœºæ™¯**

1. **ä½¿ç”¨ç°æœ‰ç±», ä½†å…¶æ¥å£ä¸ç¬¦åˆéœ€æ±‚ã€‚**
2. **æƒ³å¤ç”¨ä¸€äº›ç°å­˜çš„ç±», ä½†æ— æ³•ä¿®æ”¹å…¶æºç (å¦‚ç¬¬ä¸‰æ–¹åº“)ã€‚**
3. **åˆ›å»ºä¸€ä¸ªå¯å¤ç”¨çš„ç±», ä¸å…¶ä»–ä¸ç›¸å…³æˆ–ä¸å¯é¢„è§çš„ç±»ååŒå·¥ä½œã€‚**
4. **ç³»ç»Ÿæ•°æ®/æ¥å£å‡çº§, éœ€è¦å…¼å®¹æ—§ç‰ˆæœ¬æ¥å£ã€‚**

ğŸ“Œ **å…¸å‹åº”ç”¨åœºæ™¯: **

- å°†æ—§ç‰ˆæ—¥å¿—æ¥å£é€‚é…åˆ°æ–°ç‰ˆç»Ÿä¸€æ—¥å¿—ç³»ç»Ÿ
- å°†ç¬¬ä¸‰æ–¹æ”¯ä»˜ SDK(å¦‚æ”¯ä»˜å®ã€å¾®ä¿¡)ç»Ÿä¸€æˆå†…éƒ¨æ”¯ä»˜æ¥å£
- å°†ä¸åŒå›¾å½¢åº“(OpenGL/DirectX)ç»Ÿä¸€æˆå¼•æ“æ¸²æŸ“æ¥å£
- å°† C é£æ ¼ API é€‚é…æˆ C++ RAII æ¥å£
- æ¸¸æˆä¸­ä¸åŒè¾“å…¥è®¾å¤‡(é”®ç›˜ã€æ‰‹æŸ„ã€è§¦å±)ç»Ÿä¸€æˆâ€œè¾“å…¥äº‹ä»¶â€

âœ… **ä¼˜ç¼ºç‚¹**

âœ… ä¼˜ç‚¹: 

1. **æé«˜ç±»çš„å¤ç”¨æ€§** â†’ ä¸ä¿®æ”¹åŸæœ‰ä»£ç å³å¯é›†æˆã€‚
2. **å¢å¼ºç±»çš„é€æ˜æ€§å’Œå¤ç”¨æ€§** â†’ å®¢æˆ·ç«¯åªä¸ Target æ¥å£äº¤äº’ã€‚
3. **çµæ´»æ€§é«˜** â†’ å¯åŒæ—¶é€‚é…å¤šä¸ª Adapteeã€‚
4. **ç¬¦åˆå¼€é—­åŸåˆ™** â†’ å¯¹æ‰©å±•å¼€æ”¾, å¯¹ä¿®æ”¹å…³é—­ã€‚

âŒ ç¼ºç‚¹: 

1. **å¢åŠ ç³»ç»Ÿå¤æ‚åº¦** â†’ å¼•å…¥é¢å¤–çš„é€‚é…å™¨ç±»ã€‚
2. **è¿‡å¤šé€‚é…å™¨ä¼šè®©ç³»ç»Ÿâ€œç»•æ¥ç»•å»â€** â†’ è°ƒè¯•å›°éš¾ã€‚
3. **æ€§èƒ½ç•¥æœ‰æŸå¤±** â†’ å¤šä¸€å±‚è°ƒç”¨(é€šå¸¸å¯å¿½ç•¥)ã€‚

âœ… **æ³¨æ„äº‹é¡¹**

1. ğŸ”„ ä¸¤ç§å®ç°æ–¹å¼: 

| æ–¹å¼           | è¯´æ˜                         | ä¼˜ç‚¹                 | ç¼ºç‚¹                     |
| -------------- | ---------------------------- | -------------------- | ------------------------ |
| **ç±»é€‚é…å™¨**   | é€šè¿‡å¤šé‡ç»§æ‰¿å®ç°(C++ æ”¯æŒ) | æ•ˆç‡é«˜, ç›´æ¥ç»§æ‰¿     | ä¸çµæ´», C++ å¤šé‡ç»§æ‰¿å¤æ‚ |
| **å¯¹è±¡é€‚é…å™¨** | é€šè¿‡ç»„åˆ + å§”æ‰˜å®ç°(æ¨è)  | çµæ´», å¯é€‚é…ç±»çš„å­ç±» | å¤šä¸€å±‚å¯¹è±¡å¼•ç”¨           |

> âœ… **ç°ä»£ C++ æ¨èä½¿ç”¨â€œå¯¹è±¡é€‚é…å™¨â€** â€”â€” æ›´çµæ´»ã€æ›´å®‰å…¨ã€æ›´ç¬¦åˆç»„åˆä¼˜äºç»§æ‰¿åŸåˆ™ã€‚

2. âš ï¸ é€‚é…å™¨ä¸æ˜¯ä¸‡èƒ½èƒ¶æ°´

- é€‚é…å™¨ç”¨äº**æ¥å£è½¬æ¢**, ä¸æ˜¯ç”¨äº**åŠŸèƒ½å¢å¼º**
- å¦‚æœä¸¤ä¸ªç±»è¯­ä¹‰å®Œå…¨ä¸ç›¸å…³, å¼ºè¡Œé€‚é…ä¼šå¯¼è‡´é€»è¾‘æ··ä¹±

3. ğŸ“¦ é€‚é…å™¨å¯ç»“åˆâ€œå·¥å‚æ¨¡å¼â€åŠ¨æ€é€‰æ‹©é€‚é…å¯¹è±¡

4. ğŸ§© é€‚é…å™¨å¯â€œåŒå‘é€‚é…â€

- æœ‰æ—¶éœ€è¦ Aâ†’B, æœ‰æ—¶éœ€è¦ Bâ†’A, å¯è®¾è®¡åŒå‘é€‚é…å™¨(è¾ƒå°‘è§)

ğŸ¯ **æ¨èè¯­: **

> **å½“ä½ é¢å¯¹â€œç¥–ä¼ ä»£ç â€æˆ–â€œç¬¬ä¸‰æ–¹é»‘ç›’åº“â€æ—¶, é€‚é…å™¨æ¨¡å¼æ˜¯ä½ æœ€å¥½çš„æœ‹å‹ã€‚å®ƒè®©ä½ åœ¨ä¸ç ´ååŸæœ‰ç³»ç»Ÿçš„æƒ…å†µä¸‹, ä¼˜é›…åœ°é›†æˆæ–°åŠŸèƒ½ã€‚**

æŒæ¡é€‚é…å™¨æ¨¡å¼, ä½ å°±èƒ½åœ¨â€œæ¥å£ä¸å…¼å®¹â€çš„æˆ˜åœºä¸Šæ‰€å‘æŠ«é¡ï¼

## ä»£ç 

```
// Target.h - å®¢æˆ·ç«¯æœŸæœ›çš„æ¥å£
#pragma once
#include <string>
#include <iostream>

// ç›®æ ‡æ¥å£: ç»Ÿä¸€æ”¯ä»˜æ¥å£
class IPayment {
public:
    virtual ~IPayment() = default;
    virtual bool pay(double amount, const std::string& orderId) = 0;
    virtual std::string getName() const = 0;
};

// ==============================
// Adaptee: å¾®ä¿¡æ”¯ä»˜(ç¬¬ä¸‰æ–¹åº“, ä¸èƒ½æ”¹)
class WeChatPaySDK {
public:
    // æ³¨æ„: æ¥å£ä¸å…¼å®¹ï¼å‚æ•°é¡ºåºã€ç±»å‹ã€è¿”å›å€¼éƒ½ä¸åŒ
    int makePayment(const std::string& tradeNo, float price) {
        std::cout << "[WeChatPay] Paying " << price << " for order " << tradeNo << std::endl;
        return 0; // 0=success
    }
};

// ==============================
// Adaptee: æ”¯ä»˜å®(ç¬¬ä¸‰æ–¹åº“, ä¸èƒ½æ”¹)
class AliPaySDK {
public:
    // æ¥å£åˆä¸ä¸€æ ·ï¼
    bool doPay(float money, const char* orderNum) {
        std::cout << "[AliPay] Paying " << money << " for order " << orderNum << std::endl;
        return true; // true=success
    }
};

// ==============================
// å¯¹è±¡é€‚é…å™¨: å¾®ä¿¡æ”¯ä»˜é€‚é…å™¨(æ¨èæ–¹å¼)
class WeChatPayAdapter : public IPayment {
private:
    WeChatPaySDK wechat; // ç»„åˆ

public:
    bool pay(double amount, const std::string& orderId) override {
        int result = wechat.makePayment(orderId, static_cast<float>(amount));
        return result == 0;
    }

    std::string getName() const override {
        return "WeChat Pay";
    }
};

// ==============================
// å¯¹è±¡é€‚é…å™¨: æ”¯ä»˜å®é€‚é…å™¨
class AliPayAdapter : public IPayment {
private:
    AliPaySDK alipay; // ç»„åˆ

public:
    bool pay(double amount, const std::string& orderId) override {
        bool result = alipay.doPay(static_cast<float>(amount), orderId.c_str());
        return result;
    }

    std::string getName() const override {
        return "AliPay";
    }
};

// ==============================
// å®¢æˆ·ç«¯ä»£ç 
#include "Target.h"

class PaymentProcessor {
public:
    static void processPayment(IPayment& payment, double amount, const std::string& orderId) {
        std::cout << "Processing payment via " << payment.getName() << "...\n";
        if (payment.pay(amount, orderId)) {
            std::cout << "âœ… Payment successful!\n\n";
        } else {
            std::cout << "âŒ Payment failed!\n\n";
        }
    }
};

// main.cpp
int main() {
    WeChatPayAdapter wechatAdapter;
    AliPayAdapter aliAdapter;

    PaymentProcessor::processPayment(wechatAdapter, 99.9, "ORDER_12345");
    PaymentProcessor::processPayment(aliAdapter, 199.5, "ORDER_67890");

    return 0;
}
```

âœ… è¿›é˜¶: å¸¦å·¥å‚çš„åŠ¨æ€é€‚é…å™¨

```
class PaymentAdapterFactory {
public:
    static std::unique_ptr<IPayment> create(const std::string& type) {
        if (type == "wechat") return std::make_unique<WeChatPayAdapter>();
        if (type == "alipay") return std::make_unique<AliPayAdapter>();
        throw std::invalid_argument("Unsupported payment type: " + type);
    }
};

// ä½¿ç”¨: 
auto payment = PaymentAdapterFactory::create("wechat");
PaymentProcessor::processPayment(*payment, 50.0, "DYNAMIC_ORDER");
```

## PlantUML

```
@startuml

' ç›®æ ‡æ¥å£
interface IPayment {
    +pay(amount: double, orderId: string) : bool
    +getName() : string
}

' è¢«é€‚é…è€…(å¾®ä¿¡)
class WeChatPaySDK {
    +makePayment(tradeNo: string, price: float) : int
}

' è¢«é€‚é…è€…(æ”¯ä»˜å®)
class AliPaySDK {
    +doPay(money: float, orderNum: char*) : bool
}

' é€‚é…å™¨(å¯¹è±¡é€‚é…å™¨ - æ¨è)
class WeChatPayAdapter {
    -wechat: WeChatPaySDK
    +pay(amount: double, orderId: string) : bool
    +getName() : string
}

class AliPayAdapter {
    -alipay: AliPaySDK
    +pay(amount: double, orderId: string) : bool
    +getName() : string
}

' å®¢æˆ·ç«¯
class PaymentProcessor {
    +{static} processPayment(payment: IPayment&, amount: double, orderId: string)
}

' å…³ç³»
WeChatPayAdapter ..|> IPayment
AliPayAdapter ..|> IPayment

WeChatPayAdapter *-- WeChatPaySDK : adapts
AliPayAdapter *-- AliPaySDK : adapts

PaymentProcessor --> IPayment : uses

note right of WeChatPayAdapter
    Object Adapter (Composition)
    Recommended in modern C++
end note

note right of AliPayAdapter
    Converts AliPaySDK interface
    to IPayment interface.
end note

@enduml
```

![](./picture/7.AdapterPattern.png)

# 10. æ¡¥æ¥æ¨¡å¼

## ç®€ä»‹

> **æ¡¥æ¥æ¨¡å¼(Bridge Pattern)** æ˜¯ä¸€ç§**ç»“æ„å‹è®¾è®¡æ¨¡å¼**, å®ƒå°†**æŠ½è±¡éƒ¨åˆ†ä¸å®ç°éƒ¨åˆ†åˆ†ç¦»**, ä½¿å®ƒä»¬å¯ä»¥**ç‹¬ç«‹å˜åŒ–**ã€‚

ğŸ¯ æ ¸å¿ƒæ€æƒ³: 

- â€œæŠ½è±¡â€ ä¸ â€œå®ç°â€ è§£è€¦ â†’ ç”¨**ç»„åˆä»£æ›¿ç»§æ‰¿**
- æŠ½è±¡å±‚æŒæœ‰ä¸€ä¸ªâ€œå®ç°å±‚â€çš„å¼•ç”¨(æŒ‡é’ˆ)
- ä¸¤è€…å¯ç‹¬ç«‹æ‰©å±•, é¿å…â€œç±»çˆ†ç‚¸â€

> ğŸ’¡ æ¡¥æ¥ = â€œæŠ½è±¡â€ ä¸ â€œå®ç°â€ ä¹‹é—´çš„æ¡¥æ¢ â†’ åŠ¨æ€ç»‘å®š, è¿è¡Œæ—¶åˆ‡æ¢å®ç°ã€‚

ğŸ“Œ **ç»å…¸æ¯”å–»: **

> ç”µè§†(æŠ½è±¡)å’Œé¥æ§å™¨(å®ç°)â€”â€” åŒä¸€ä¸ªé¥æ§å™¨å¯ä»¥æ§åˆ¶ä¸åŒå“ç‰Œç”µè§†, åŒä¸€ç”µè§†ä¹Ÿå¯é…ä¸åŒé¥æ§å™¨ã€‚

ğŸ§© ç»“æ„ç»„æˆ: 

| è§’è‰²                  | è¯´æ˜                                             |
| --------------------- | ------------------------------------------------ |
| `Abstraction`         | æŠ½è±¡ç±», å®šä¹‰é«˜å±‚æ§åˆ¶æ¥å£, æŒæœ‰ä¸€ä¸ª `Implementor` |
| `RefinedAbstraction`  | æ‰©å±•æŠ½è±¡(å¯é€‰), å¦‚ä¸åŒå½¢çŠ¶ã€ä¸åŒè®¾å¤‡           |
| `Implementor`         | å®ç°æ¥å£, å®šä¹‰åº•å±‚æ“ä½œ(å¦‚ç»˜åˆ¶ã€é©±åŠ¨)           |
| `ConcreteImplementor` | å…·ä½“å®ç°, å¦‚ OpenGLã€DirectXã€Vulkan æ¸²æŸ“å™¨      |

âœ… é€‚ç”¨åœºæ™¯

1. **ä½ ä¸å¸Œæœ›åœ¨æŠ½è±¡å’Œå®ç°ä¹‹é—´æœ‰å›ºå®šçš„ç»‘å®šå…³ç³»(ç»§æ‰¿å¤ªæ­»æ¿)**
2. **æŠ½è±¡åŠå…¶å®ç°éƒ½åº”å¯é€šè¿‡å­ç±»åŒ–ç‹¬ç«‹æ‰©å±•**
3. **å¯¹æŠ½è±¡çš„å®ç°ä¿®æ”¹ä¸åº”å½±å“å®¢æˆ·ç«¯ä»£ç **
4. **ä½ æƒ³åœ¨è¿è¡Œæ—¶åˆ‡æ¢å®ç°(å¦‚åˆ‡æ¢æ¸²æŸ“åç«¯ã€æ•°æ®åº“é©±åŠ¨)**
5. **é¿å…â€œå¤šç»´åº¦ç»§æ‰¿â€å¯¼è‡´çš„ç±»çˆ†ç‚¸(å¦‚ Shape Ã— Color Ã— Renderer = NÃ—MÃ—K ä¸ªç±»)**

ğŸ“Œ **å…¸å‹åº”ç”¨åœºæ™¯: **

- å›¾å½¢åº“: Shape(æŠ½è±¡) + Renderer(å®ç°: OpenGL/DirectX/Vulkan)
- è·¨å¹³å° UI: Button(æŠ½è±¡) + PlatformImpl(Win/Mac/Linux)
- æ•°æ®åº“é©±åŠ¨: DAO(æŠ½è±¡) + DriverImpl(MySQL/PostgreSQL/SQLite)
- æ¸¸æˆå¼•æ“: GameObject(æŠ½è±¡) + PhysicsEngine(Box2D/Bullet)
- é¥æ§è®¾å¤‡: TV(æŠ½è±¡) + RemoteControl(çº¢å¤–/è“ç‰™/WiFi)

âœ… ä¼˜ç¼ºç‚¹

âœ… ä¼˜ç‚¹: 

1. **åˆ†ç¦»æŠ½è±¡ä¸å®ç°** â†’ ä¸¤è€…å¯ç‹¬ç«‹æ‰©å±•, ç¬¦åˆå•ä¸€èŒè´£åŸåˆ™ã€‚
2. **é¿å…ç±»çˆ†ç‚¸** â†’ N ä¸ªæŠ½è±¡ Ã— M ä¸ªå®ç° = N+M ä¸ªç±», è€Œä¸æ˜¯ NÃ—Mã€‚
3. **è¿è¡Œæ—¶åˆ‡æ¢å®ç°** â†’ çµæ´», å¦‚åˆ‡æ¢å›¾å½¢ APIã€æ•°æ®åº“åç«¯ã€‚
4. **æé«˜å¯æ‰©å±•æ€§** â†’ æ–°å¢å®ç°ä¸å½±å“æŠ½è±¡å±‚, åä¹‹äº¦ç„¶ã€‚
5. **éšè—å®ç°ç»†èŠ‚** â†’ å®¢æˆ·ç«¯åªä¸æŠ½è±¡å±‚äº¤äº’ã€‚

âŒ ç¼ºç‚¹: 

1. **å¢åŠ ç³»ç»Ÿå¤æ‚åº¦** â†’ å¼•å…¥é¢å¤–å±‚æ¬¡ã€‚
2. **å®¢æˆ·ç«¯éœ€ç†è§£â€œæ¡¥æ¥â€æ¦‚å¿µ** â†’ åˆå­¦è€…å¯èƒ½å›°æƒ‘ã€‚
3. **ä»…é€‚ç”¨äºâ€œæŠ½è±¡-å®ç°â€å¯åˆ†ç¦»çš„åœºæ™¯** â†’ ä¸æ˜¯ä¸‡èƒ½ã€‚

ğŸ¯ **æ¨èè¯­: **

> **æ¡¥æ¥æ¨¡å¼æ˜¯è§£å†³â€œå¤šç»´åº¦å˜åŒ–â€é—®é¢˜çš„åˆ©å™¨ã€‚å½“ä½ å‘ç°ç±»åœ¨å¤šä¸ªç»´åº¦ä¸Šæ‰©å±•å¯¼è‡´å­ç±»çˆ†ç‚¸æ—¶, æ¡¥æ¥æ¨¡å¼å°±æ˜¯ä½ çš„æ•‘æ˜Ÿï¼**

æŒæ¡æ¡¥æ¥æ¨¡å¼, ä½ å°±èƒ½è®¾è®¡å‡ºé«˜åº¦çµæ´»ã€æ˜“äºæ‰©å±•çš„ç³»ç»Ÿæ¶æ„ï¼

## ä»£ç 

```
// Bridge.h
#include <iostream>
#include <memory>
#include <string>

// ============ å®ç°å±‚ ============
// æŠ½è±¡å®ç°æ¥å£
class Renderer {
public:
    virtual ~Renderer() = default;
    virtual void render(const std::string& shapeType, const std::string& info) = 0;
};

// å…·ä½“å®ç°: OpenGL
class OpenGLRenderer : public Renderer {
public:
    void render(const std::string& shapeType, const std::string& info) override {
        std::cout << "[OpenGL] Rendering " << shapeType << ": " << info << std::endl;
    }
};

// å…·ä½“å®ç°: DirectX
class DirectXRenderer : public Renderer {
public:
    void render(const std::string& shapeType, const std::string& info) override {
        std::cout << "[DirectX] Drawing " << shapeType << " -> " << info << std::endl;
    }
};

// å…·ä½“å®ç°: Vulkan
class VulkanRenderer : public Renderer {
public:
    void render(const std::string& shapeType, const std::string& info) override {
        std::cout << "[Vulkan] ğŸš€ Ultra-fast rendering of " << shapeType << " (" << info << ")" << std::endl;
    }
};

// ============ æŠ½è±¡å±‚ ============
// æŠ½è±¡å›¾å½¢
class Shape {
protected:
    std::unique_ptr<Renderer> renderer; // æ¡¥æ¥æ ¸å¿ƒ: ç»„åˆè€Œéç»§æ‰¿

public:
    Shape(std::unique_ptr<Renderer> r) : renderer(std::move(r)) {}

    virtual ~Shape() = default;

    // è®¾ç½®æ¸²æŸ“å™¨(è¿è¡Œæ—¶åˆ‡æ¢)
    void setRenderer(std::unique_ptr<Renderer> r) {
        renderer = std::move(r);
    }

    virtual void draw() = 0;
    virtual std::string getInfo() const = 0;
    virtual std::string getType() const = 0;
};

// å…·ä½“æŠ½è±¡: åœ†å½¢
class Circle : public Shape {
private:
    double radius;
    std::string position;

public:
    Circle(double r, const std::string& pos, std::unique_ptr<Renderer> r)
        : Shape(std::move(r)), radius(r), position(pos) {}

    void draw() override {
        if (renderer) {
            renderer->render(getType(), getInfo());
        }
    }

    std::string getInfo() const override {
        return "Radius=" + std::to_string(radius) + ", Pos=" + position;
    }

    std::string getType() const override {
        return "Circle";
    }
};

// å…·ä½“æŠ½è±¡: çŸ©å½¢
class Rectangle : public Shape {
private:
    double width, height;
    std::string position;

public:
    Rectangle(double w, double h, const std::string& pos, std::unique_ptr<Renderer> r)
        : Shape(std::move(r)), width(w), height(h), position(pos) {}

    void draw() override {
        if (renderer) {
            renderer->render(getType(), getInfo());
        }
    }

    std::string getInfo() const override {
        return "W=" + std::to_string(width) + ", H=" + std::to_string(height) + ", Pos=" + position;
    }

    std::string getType() const override {
        return "Rectangle";
    }
};

// å®¢æˆ·ç«¯
int main() {
    std::cout << "=== æ¡¥æ¥æ¨¡å¼ç¤ºä¾‹: å›¾å½¢ + æ¸²æŸ“å™¨ ===\n\n";

    // åˆ›å»ºä¸åŒæ¸²æŸ“å™¨
    auto opengl = std::make_unique<OpenGLRenderer>();
    auto directx = std::make_unique<DirectXRenderer>();
    auto vulkan = std::make_unique<VulkanRenderer>();

    // åˆ›å»ºå›¾å½¢å¯¹è±¡, ç»‘å®šæ¸²æŸ“å™¨
    Circle circle(5.0, "(10,20)", std::make_unique<OpenGLRenderer>());
    Rectangle rect(10.0, 8.0, "(30,40)", std::make_unique<DirectXRenderer>());

    // ç»˜åˆ¶
    circle.draw();
    rect.draw();

    std::cout << "\n=== è¿è¡Œæ—¶åˆ‡æ¢æ¸²æŸ“å™¨ ===\n";
    circle.setRenderer(std::make_unique<VulkanRenderer>());
    circle.draw();

    rect.setRenderer(std::make_unique<OpenGLRenderer>());
    rect.draw();

    return 0;
}
```

âœ… è¿›é˜¶: å¸¦å·¥å‚çš„åŠ¨æ€æ¡¥æ¥

```
class RendererFactory {
public:
    static std::unique_ptr<Renderer> create(const std::string& type) {
        if (type == "opengl") return std::make_unique<OpenGLRenderer>();
        if (type == "directx") return std::make_unique<DirectXRenderer>();
        if (type == "vulkan") return std::make_unique<VulkanRenderer>();
        throw std::invalid_argument("Unknown renderer: " + type);
    }
};

// ä½¿ç”¨: 
auto circle = std::make_unique<Circle>(5.0, "(0,0)", RendererFactory::create("vulkan"));
```

## PlantUML

```
@startuml

' æŠ½è±¡å®ç°æ¥å£
interface Renderer {
    +render(shapeType: string, info: string) : void
}

' å…·ä½“å®ç°
class OpenGLRenderer {
    +render(shapeType: string, info: string) : void
}

class DirectXRenderer {
    +render(shapeType: string, info: string) : void
}

class VulkanRenderer {
    +render(shapeType: string, info: string) : void
}

' æŠ½è±¡å±‚
abstract class Shape {
    -renderer: unique_ptr<Renderer>
    +setRenderer(r: unique_ptr<Renderer>)
    +draw() : void {abstract}
    +getInfo() : string {abstract}
    +getType() : string {abstract}
}

' å…·ä½“æŠ½è±¡
class Circle {
    -radius: double
    -position: string
    +draw()
    +getInfo() : string
    +getType() : string
}

class Rectangle {
    -width: double
    -height: double
    -position: string
    +draw()
    +getInfo() : string
    +getType() : string
}

' å…³ç³»
Shape *-- Renderer : "has a (bridge)"

Renderer <|.. OpenGLRenderer
Renderer <|.. DirectXRenderer
Renderer <|.. VulkanRenderer

Shape <|-- Circle
Shape <|-- Rectangle

note right of Shape
    Holds a reference to
    Renderer (composition).
    This is the BRIDGE.
end note

note bottom of Renderer
    Defines the implementation
    interface. Can be extended
    independently of Shape.
end note

@enduml
```

![](./picture/8.BridgePattern.png)

# 11. ç»„åˆæ¨¡å¼

## ç®€ä»‹

> **ç»„åˆæ¨¡å¼(Composite Pattern)** æ˜¯ä¸€ç§**ç»“æ„å‹è®¾è®¡æ¨¡å¼**, å®ƒ**å°†å¯¹è±¡ç»„åˆæˆæ ‘å½¢ç»“æ„ä»¥è¡¨ç¤ºâ€œéƒ¨åˆ†-æ•´ä½“â€çš„å±‚æ¬¡ç»“æ„**, ä½¿å¾—å®¢æˆ·ç«¯å¯¹å•ä¸ªå¯¹è±¡å’Œç»„åˆå¯¹è±¡çš„ä½¿ç”¨å…·æœ‰ä¸€è‡´æ€§ã€‚

ğŸ¯ æ ¸å¿ƒæ€æƒ³: 

- **â€œéƒ¨åˆ†-æ•´ä½“â€ç»Ÿä¸€æ¥å£** â†’ å®¢æˆ·ç«¯æ— éœ€åŒºåˆ†å¶å­å’Œå®¹å™¨
- æ ‘å½¢ç»“æ„: èŠ‚ç‚¹å¯ä»¥æ˜¯å¶å­(Leaf)æˆ–å®¹å™¨(Composite)
- é€’å½’ç»„åˆ â†’ å®¹å™¨å¯åŒ…å«å¶å­æˆ–å…¶ä»–å®¹å™¨

> ğŸ’¡ ç»å…¸æ¯”å–»: 
>  **æ–‡ä»¶ç³»ç»Ÿ** â€”â€” æ–‡ä»¶(å¶å­)å’Œæ–‡ä»¶å¤¹(å®¹å™¨)éƒ½å¯è¢«â€œæ“ä½œâ€, å¦‚ `getSize()`ã€`display()`, å®¢æˆ·ç«¯æ— éœ€å…³å¿ƒæ˜¯æ–‡ä»¶è¿˜æ˜¯æ–‡ä»¶å¤¹ã€‚

------

 ğŸ§© ç»“æ„ç»„æˆ: 

| è§’è‰²        | è¯´æ˜                                                         |
| ----------- | ------------------------------------------------------------ |
| `Component` | æŠ½è±¡åŸºç±», å£°æ˜å¶å­å’Œå®¹å™¨çš„å…¬å…±æ¥å£(å¦‚ `display()`, `getSize()`) |
| `Leaf`      | å¶å­èŠ‚ç‚¹, å®ç° `Component` æ¥å£, æ— å­èŠ‚ç‚¹                    |
| `Composite` | å®¹å™¨èŠ‚ç‚¹, èšåˆå­èŠ‚ç‚¹(`Component*`), å®ç°ç›¸åŒæ¥å£, å†…éƒ¨é€’å½’è°ƒç”¨å­èŠ‚ç‚¹ |

------

 âœ… é€‚ç”¨åœºæ™¯

1. **ä½ æƒ³è¡¨ç¤ºå¯¹è±¡çš„â€œéƒ¨åˆ†-æ•´ä½“â€å±‚æ¬¡ç»“æ„(æ ‘å½¢ç»“æ„)**
2. **å¸Œæœ›å®¢æˆ·ç«¯å¿½ç•¥ç»„åˆå¯¹è±¡ä¸å•ä¸ªå¯¹è±¡çš„å·®å¼‚, ç»Ÿä¸€å¤„ç†**
3. **ç»“æ„åœ¨è¿è¡Œæ—¶åŠ¨æ€å˜åŒ–(å¦‚æ·»åŠ /åˆ é™¤å­èŠ‚ç‚¹)**
4. **éœ€è¦é€’å½’éå†æˆ–æ“ä½œæ•´ä¸ªç»“æ„**

ğŸ“Œ **å…¸å‹åº”ç”¨åœºæ™¯: **

- ğŸ“ **æ–‡ä»¶ç³»ç»Ÿ**: æ–‡ä»¶ + æ–‡ä»¶å¤¹
- ğŸ¨ **å›¾å½¢ç•Œé¢**: æ§ä»¶ + å®¹å™¨æ§ä»¶(å¦‚ GroupBoxã€Panel)
- ğŸ® **æ¸¸æˆå¯¹è±¡**: GameObject + å­å¯¹è±¡(å¦‚è§’è‰² + è£…å¤‡ + æŠ€èƒ½)
- ğŸ“Š **ç»„ç»‡æ¶æ„**: å‘˜å·¥ + éƒ¨é—¨(éƒ¨é—¨å¯åŒ…å«å­éƒ¨é—¨)
- ğŸ“œ **XML/HTML DOM æ ‘**: èŠ‚ç‚¹ + å­èŠ‚ç‚¹

------

 âœ… ä¼˜ç¼ºç‚¹

 âœ… ä¼˜ç‚¹: 

1. **å®šä¹‰äº†åŒ…å«ç®€å•å¯¹è±¡å’Œå¤åˆå¯¹è±¡çš„ç±»å±‚æ¬¡ç»“æ„** â†’ å®¢æˆ·ç«¯ç»Ÿä¸€å¤„ç†
2. **ç®€åŒ–å®¢æˆ·ç«¯ä»£ç ** â†’ æ— éœ€åˆ¤æ–­æ˜¯å¶å­è¿˜æ˜¯å®¹å™¨
3. **æ›´å®¹æ˜“å¢åŠ æ–°ç±»å‹çš„ç»„ä»¶** â†’ ç¬¦åˆå¼€é—­åŸåˆ™
4. **æ”¯æŒé€’å½’ç»“æ„** â†’ å¤©ç„¶é€‚åˆæ ‘å½¢æ•°æ®

 âŒ ç¼ºç‚¹: 

1. **è®¾è®¡æ›´å¤æ‚** â†’ éœ€è¦å®šä¹‰å…¬å…±æ¥å£, å¯èƒ½åŒ…å«å¶å­ä¸éœ€è¦çš„æ–¹æ³•
2. **ç±»å‹ç³»ç»Ÿé™åˆ¶** â†’ æŸäº›æ“ä½œåªå¯¹å®¹å™¨æœ‰æ„ä¹‰(å¦‚ `addChild`), å¶å­è°ƒç”¨ä¼šå‡ºé”™
3. **å¯èƒ½è¿åæ¥å£éš”ç¦»åŸåˆ™** â†’ å¶å­è¢«è¿«å®ç°æ— æ„ä¹‰çš„æ–¹æ³•

------

 âœ… æ³¨æ„äº‹é¡¹

 1. ğŸ”„ ä¸¤ç§è®¾è®¡é£æ ¼: 

| ç±»å‹                 | è¯´æ˜                                                       | ä¼˜ç‚¹                         | ç¼ºç‚¹                                         |
| -------------------- | ---------------------------------------------------------- | ---------------------------- | -------------------------------------------- |
| **é€æ˜æ–¹å¼(æ¨è)** | `Component` å£°æ˜æ‰€æœ‰æ–¹æ³•(åŒ…æ‹¬ `addChild`, `removeChild`) | å®¢æˆ·ç«¯å®Œå…¨ç»Ÿä¸€, æ— éœ€ç±»å‹åˆ¤æ–­ | å¶å­éœ€æŠ›å¼‚å¸¸æˆ–ç©ºå®ç°æ— æ„ä¹‰æ–¹æ³•               |
| **å®‰å…¨æ–¹å¼**         | åªåœ¨ `Composite` ä¸­å£°æ˜ç®¡ç†å­èŠ‚ç‚¹çš„æ–¹æ³•                    | ç±»å‹å®‰å…¨, ç¼–è¯‘æœŸæ£€æŸ¥         | å®¢æˆ·ç«¯éœ€ `dynamic_cast` åˆ¤æ–­ç±»å‹, ç ´åé€æ˜æ€§ |

> âœ… **ç°ä»£ C++ æ¨èâ€œé€æ˜æ–¹å¼â€ + è¿è¡Œæ—¶å¼‚å¸¸/ç©ºæ“ä½œ**, ä¿æŒæ¥å£ä¸€è‡´æ€§ã€‚

------

 2. âš ï¸ å¶å­èŠ‚ç‚¹å¯¹å®¹å™¨æ–¹æ³•çš„å¤„ç†: 

```
// é€æ˜æ–¹å¼ - Leaf å®ç°ä½†æŠ›å¼‚å¸¸
void addChild(std::unique_ptr<Component>) override {
    throw std::logic_error("Cannot add child to a leaf!");
}

// æˆ–è€…ç©ºå®ç°(é™é»˜å¤±è´¥, ä¸æ¨è)
void addChild(std::unique_ptr<Component>) override {}
```

> ğŸš¨ **å»ºè®®æŠ›å¼‚å¸¸**, é¿å…é™é»˜å¤±è´¥å¯¼è‡´è°ƒè¯•å›°éš¾ã€‚

------

 3. ğŸ§¹ å†…å­˜ç®¡ç†å»ºè®®: 

- ä½¿ç”¨ `std::unique_ptr<Component>` ç®¡ç†å­èŠ‚ç‚¹ç”Ÿå‘½å‘¨æœŸ
- Composite ææ„æ—¶è‡ªåŠ¨é‡Šæ”¾æ‰€æœ‰å­èŠ‚ç‚¹
- é¿å…è£¸æŒ‡é’ˆå’Œæ‰‹åŠ¨ `delete`

------

 4. ğŸ”„ é€’å½’æ“ä½œæ³¨æ„æ ˆæº¢å‡º

- è¶…æ·±æ ‘ç»“æ„å¯èƒ½å¯¼è‡´æ ˆæº¢å‡º â†’ å¯æ”¹ç”¨è¿­ä»£ + æ ˆæ¨¡æ‹Ÿ
- é€šå¸¸ä¸šåŠ¡åœºæ™¯æ·±åº¦æœ‰é™, æ— éœ€è¿‡åº¦æ‹…å¿ƒ

------

 5. ğŸ§© å¯é€‰: æä¾›è¿­ä»£å™¨æ”¯æŒ

```
class Composite : public Component {
    std::vector<std::unique_ptr<Component>> children;
public:
    using Iterator = decltype(children)::iterator;
    Iterator begin() { return children.begin(); }
    Iterator end() { return children.end(); }
};
```

ğŸ¯ **æ¨èè¯­: **

> **å½“ä½ éœ€è¦å¤„ç†æ ‘å½¢ç»“æ„(å¦‚æ–‡ä»¶ç³»ç»Ÿã€UI æ§ä»¶æ ‘ã€ç»„ç»‡æ¶æ„)æ—¶, ç»„åˆæ¨¡å¼æ˜¯ä½ æœ€ä½³é€‰æ‹©ã€‚å®ƒè®©å¤æ‚ç»“æ„çš„æ“ä½œå˜å¾—ç®€å•è€Œä¼˜é›…ï¼**

æŒæ¡ç»„åˆæ¨¡å¼, ä½ å°±èƒ½è½»æ¾é©¾é©­ä»»ä½•â€œéƒ¨åˆ†-æ•´ä½“â€å±‚æ¬¡ç»“æ„ï¼

## ä»£ç 

```
// Composite.h
#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <stdexcept>

// ============ æŠ½è±¡ç»„ä»¶ ============
class FileSystemComponent {
public:
    virtual ~FileSystemComponent() = default;

    // é€šç”¨æ“ä½œ(é€æ˜æ–¹å¼)
    virtual void display(const std::string& prefix = "") const = 0;
    virtual size_t getSize() const = 0;
    virtual std::string getName() const = 0;

    // å®¹å™¨æ“ä½œ(å¶å­éœ€å®ç°ä½†æŠ›å¼‚å¸¸)
    virtual void addChild(std::unique_ptr<FileSystemComponent> child) {
        throw std::logic_error("Cannot add child to a leaf node: " + getName());
    }

    virtual void removeChild(const std::string& name) {
        throw std::logic_error("Cannot remove child from a leaf node: " + getName());
    }

    virtual FileSystemComponent* getChild(const std::string& name) {
        throw std::logic_error("Leaf node has no children: " + getName());
    }
};

// ============ å¶å­èŠ‚ç‚¹: æ–‡ä»¶ ============
class File : public FileSystemComponent {
private:
    std::string name;
    size_t size;

public:
    File(const std::string& n, size_t s) : name(n), size(s) {}

    void display(const std::string& prefix = "") const override {
        std::cout << prefix << "ğŸ“„ " << name << " (" << size << " KB)" << std::endl;
    }

    size_t getSize() const override {
        return size;
    }

    std::string getName() const override {
        return name;
    }
};

// ============ å®¹å™¨èŠ‚ç‚¹: ç›®å½• ============
class Directory : public FileSystemComponent {
private:
    std::string name;
    std::vector<std::unique_ptr<FileSystemComponent>> children;

public:
    Directory(const std::string& n) : name(n) {}

    void display(const std::string& prefix = "") const override {
        std::cout << prefix << "ğŸ“ " << name << "/" << std::endl;
        for (const auto& child : children) {
            child->display(prefix + "  "); // é€’å½’æ˜¾ç¤º
        }
    }

    size_t getSize() const override {
        size_t total = 0;
        for (const auto& child : children) {
            total += child->getSize(); // é€’å½’è®¡ç®—
        }
        return total;
    }

    std::string getName() const override {
        return name;
    }

    // å®¹å™¨ç‰¹æœ‰æ“ä½œ
    void addChild(std::unique_ptr<FileSystemComponent> child) override {
        children.push_back(std::move(child));
    }

    void removeChild(const std::string& name) override {
        auto it = std::remove_if(children.begin(), children.end(),
            [&name](const std::unique_ptr<FileSystemComponent>& child) {
                return child->getName() == name;
            });
        if (it != children.end()) {
            children.erase(it, children.end());
        } else {
            throw std::runtime_error("Child not found: " + name);
        }
    }

    FileSystemComponent* getChild(const std::string& name) override {
        for (auto& child : children) {
            if (child->getName() == name) {
                return child.get();
            }
        }
        return nullptr;
    }
};

// ============ å®¢æˆ·ç«¯ä½¿ç”¨ ============
#include "Composite.h"

int main() {
    std::cout << "=== ç»„åˆæ¨¡å¼: æ–‡ä»¶ç³»ç»Ÿæ¨¡æ‹Ÿ ===\n\n";

    // åˆ›å»ºæ ¹ç›®å½•
    auto root = std::make_unique<Directory>("root");

    // æ·»åŠ æ–‡ä»¶
    root->addChild(std::make_unique<File>("readme.txt", 2));
    root->addChild(std::make_unique<File>("config.json", 1));

    // åˆ›å»ºå­ç›®å½•
    auto docs = std::make_unique<Directory>("documents");
    docs->addChild(std::make_unique<File>("report.pdf", 5000));
    docs->addChild(std::make_unique<File>("notes.txt", 100));

    auto pics = std::make_unique<Directory>("pictures");
    pics->addChild(std::make_unique<File>("photo1.jpg", 3000));
    pics->addChild(std::make_unique<File>("photo2.png", 2500));

    // å°†å­ç›®å½•åŠ å…¥æ ¹ç›®å½•
    root->addChild(std::move(docs));
    root->addChild(std::move(pics));

    // æ˜¾ç¤ºæ•´ä¸ªæ–‡ä»¶æ ‘
    root->display();

    // è®¡ç®—æ€»å¤§å°
    std::cout << "\nTotal size: " << root->getSize() << " KB" << std::endl;

    // å°è¯•å¯¹å¶å­è°ƒç”¨å®¹å™¨æ–¹æ³•(åº”æŠ›å¼‚å¸¸)
    std::cout << "\n=== æµ‹è¯•å¶å­èŠ‚ç‚¹å¼‚å¸¸ ===\n";
    auto file = std::make_unique<File>("test.txt", 10);
    try {
        file->addChild(std::make_unique<File>("invalid.txt", 0));
    } catch (const std::exception& e) {
        std::cout << "âœ… Caught expected exception: " << e.what() << std::endl;
    }

    return 0;
}
```



## PlantUML

```
@startuml

' æŠ½è±¡ç»„ä»¶(é€æ˜æ–¹å¼)
abstract class FileSystemComponent {
    +display(prefix: string) : void {abstract}
    +getSize() : size_t {abstract}
    +getName() : string {abstract}
    +addChild(child: unique_ptr<FileSystemComponent>) : void
    +removeChild(name: string) : void
    +getChild(name: string) : FileSystemComponent*
}

' å¶å­èŠ‚ç‚¹
class File {
    -name: string
    -size: size_t
    +display(prefix: string) : void
    +getSize() : size_t
    +getName() : string
    +addChild(...) {throws}
    +removeChild(...) {throws}
    +getChild(...) {throws}
}

' å®¹å™¨èŠ‚ç‚¹
class Directory {
    -name: string
    -children: vector<unique_ptr<FileSystemComponent>>
    +display(prefix: string) : void
    +getSize() : size_t
    +getName() : string
    +addChild(child: unique_ptr<FileSystemComponent>) : void
    +removeChild(name: string) : void
    +getChild(name: string) : FileSystemComponent*
}

' å…³ç³»
FileSystemComponent <|-- File
FileSystemComponent <|-- Directory

note right of FileSystemComponent
    Transparent Composite:
    Declares all operations,
    Leaf throws on container methods.
end note

note bottom of Directory
    Manages child components
    recursively. Uses composition.
end note

@enduml
```

![](./picture/9.CompositePattern.png)

# 12.è£…é¥°å™¨æ¨¡å¼

## ç®€ä»‹

> **è£…é¥°å™¨æ¨¡å¼(Decorator Pattern)** æ˜¯ä¸€ç§**ç»“æ„å‹è®¾è®¡æ¨¡å¼**, å®ƒ**åŠ¨æ€åœ°ç»™ä¸€ä¸ªå¯¹è±¡æ·»åŠ ä¸€äº›é¢å¤–çš„èŒè´£(åŠŸèƒ½)**, å°±å¢åŠ åŠŸèƒ½æ¥è¯´, è£…é¥°å™¨æ¨¡å¼ç›¸æ¯”ç”Ÿæˆå­ç±»æ›´ä¸ºçµæ´»ã€‚

 ğŸ¯ æ ¸å¿ƒæ€æƒ³: 

- **â€œå¥—å¨ƒå¼â€å¢å¼ºåŠŸèƒ½** â€”â€” ä¸€å±‚å¥—ä¸€å±‚, æ¯å±‚æ·»åŠ æ–°åŠŸèƒ½
- **ç»§æ‰¿æ˜¯é™æ€çš„, è£…é¥°æ˜¯åŠ¨æ€çš„**
- **ç¬¦åˆå¼€é—­åŸåˆ™** â€”â€” å¯¹æ‰©å±•å¼€æ”¾, å¯¹ä¿®æ”¹å…³é—­

> ğŸ’¡ ç»å…¸æ¯”å–»: 
>  **å’–å•¡ + é…æ–™** â€”â€” åŸºç¡€å’–å•¡(Espresso)å¯åŠ¨æ€æ·»åŠ â€œç‰›å¥¶â€ã€â€œç³–â€ã€â€œå·§å…‹åŠ›â€ç­‰è£…é¥°, æ¯åŠ ä¸€å±‚, ä»·æ ¼å’Œæè¿°éƒ½å˜åŒ–, ä½†ä»ç„¶æ˜¯â€œä¸€æ¯å’–å•¡â€ã€‚

------

 ğŸ§© ç»“æ„ç»„æˆ: 

| è§’è‰²                | è¯´æ˜                                                        |
| ------------------- | ----------------------------------------------------------- |
| `Component`         | æŠ½è±¡ç»„ä»¶, å®šä¹‰å¯¹è±¡æ¥å£(å¦‚ `cost()`, `getDescription()`)   |
| `ConcreteComponent` | å…·ä½“ç»„ä»¶, è¢«è£…é¥°çš„åŸå§‹å¯¹è±¡                                  |
| `Decorator`         | æŠ½è±¡è£…é¥°å™¨, ç»§æ‰¿ `Component`, æŒæœ‰ä¸€ä¸ª `Component*`(ç»„åˆ) |
| `ConcreteDecorator` | å…·ä½“è£…é¥°å™¨, å®ç°é¢å¤–åŠŸèƒ½, è°ƒç”¨è¢«è£…é¥°å¯¹è±¡çš„æ–¹æ³•å¹¶å¢å¼º        |

------

 âœ… é€‚ç”¨åœºæ™¯

1. **éœ€è¦åœ¨è¿è¡Œæ—¶åŠ¨æ€ã€é€æ˜åœ°ç»™å¯¹è±¡æ·»åŠ èŒè´£**
2. **æ‰©å±•åŠŸèƒ½çš„æ–¹æ¡ˆæœ‰å¾ˆå¤š, ç”¨ç»§æ‰¿ä¼šå¯¼è‡´å­ç±»çˆ†ç‚¸**
3. **èŒè´£å¯ä»¥â€œå åŠ â€, ä¸”é¡ºåºå¯èƒ½å½±å“ç»“æœ(å¦‚åŠ å¯†+å‹ç¼© vs å‹ç¼©+åŠ å¯†)**
4. **ä¸å¸Œæœ›ä¿®æ”¹åŸå§‹ç±»ä»£ç (å¦‚ç¬¬ä¸‰æ–¹åº“)**

ğŸ“Œ **å…¸å‹åº”ç”¨åœºæ™¯: **

- â˜• **å’–å•¡/é¥®æ–™ç³»ç»Ÿ**: åŸºç¡€é¥®å“ + å„ç§é…æ–™(ç³–ã€å¥¶ã€æ‘©å¡)
- ğŸ’¾ **I/O æµå¢å¼º**: `std::ostream` â†’ æ·»åŠ å‹ç¼©ã€åŠ å¯†ã€æ—¥å¿—åŠŸèƒ½
- ğŸ® **æ¸¸æˆé“å…·ç³»ç»Ÿ**: åŸºç¡€æ­¦å™¨ + é™„é­”(ç«ç„°ã€å†°éœœã€å¸è¡€)
- ğŸ§± **GUI æ§ä»¶è£…é¥°**: åŸºç¡€æŒ‰é’® + è¾¹æ¡†è£…é¥°ã€æ»šåŠ¨è£…é¥°ã€é€æ˜åº¦è£…é¥°
- ğŸ“¦ **ç½‘ç»œè¯·æ±‚ä¸­é—´ä»¶**: åŸºç¡€è¯·æ±‚ + æ—¥å¿—ã€é‡è¯•ã€ç¼“å­˜ã€è®¤è¯è£…é¥°å™¨

------

 âœ… ä¼˜ç¼ºç‚¹

 âœ… ä¼˜ç‚¹: 

1. **æ¯”ç»§æ‰¿æ›´çµæ´»** â†’ è¿è¡Œæ—¶åŠ¨æ€ç»„åˆåŠŸèƒ½
2. **é¿å…ç±»çˆ†ç‚¸** â†’ N ä¸ªåŠŸèƒ½ç»„åˆ = N ä¸ªè£…é¥°å™¨ç±», è€Œä¸æ˜¯ 2^N ä¸ªå­ç±»
3. **ç¬¦åˆå¼€é—­åŸåˆ™** â†’ æ–°å¢åŠŸèƒ½ä¸ä¿®æ”¹åŸæœ‰ä»£ç 
4. **å¯å åŠ ã€å¯åµŒå¥—** â†’ åŠŸèƒ½è‡ªç”±ç»„åˆ
5. **å•ä¸€èŒè´£åŸåˆ™** â†’ æ¯ä¸ªè£…é¥°å™¨åªè´Ÿè´£ä¸€ä¸ªå¢å¼ºåŠŸèƒ½

 âŒ ç¼ºç‚¹: 

1. **äº§ç”Ÿå¾ˆå¤šå°å¯¹è±¡** â†’ è°ƒè¯•æ—¶è°ƒç”¨æ ˆè¾ƒæ·±
2. **è¿‡åº¦ä½¿ç”¨ä¼šè®©ç³»ç»Ÿå¤æ‚** â†’ â€œå¥—å¨ƒåœ°ç‹±â€
3. **åˆ é™¤è£…é¥°å™¨è¾ƒå›°éš¾** â†’ é€šå¸¸éœ€é‡å»ºå¯¹è±¡é“¾
4. **é…ç½®å¤æ‚å¯¹è±¡æ—¶ä»£ç å†—é•¿** â†’ å¯ç»“åˆ Builder æ¨¡å¼ä¼˜åŒ–

------

 âœ… æ³¨æ„äº‹é¡¹

 1. ğŸ”„ è£…é¥°å™¨å¿…é¡»å®ç°ä¸ç»„ä»¶ç›¸åŒçš„æ¥å£

```
class Decorator : public Component { ... };
```

> âœ… å®¢æˆ·ç«¯æ— éœ€çŸ¥é“æ˜¯å¦è¢«è£…é¥° â†’ é€æ˜æ€§

------

 2. âš ï¸ è£…é¥°å™¨æŒæœ‰ç»„ä»¶çš„æŒ‡é’ˆ/å¼•ç”¨(ç»„åˆ)

```
class MilkDecorator : public Beverage {
    std::unique_ptr<Beverage> beverage; // å…³é”®: ç»„åˆè€Œéç»§æ‰¿åŠŸèƒ½
public:
    MilkDecorator(std::unique_ptr<Beverage> b) : beverage(std::move(b)) {}
    double cost() override { return beverage->cost() + 0.5; }
};
```

3. ğŸš« è£…é¥°å™¨ â‰  ç»§æ‰¿/é€‚é…å™¨/ä»£ç†

4. âœ… æ¨èä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆç®¡ç†ç»„ä»¶ç”Ÿå‘½å‘¨æœŸ

5. âœ… è£…é¥°é¡ºåºå¯èƒ½å½±å“ç»“æœ

```
auto coffee = std::make_unique<Espresso>();
auto withMilk = std::make_unique<MilkDecorator>(std::move(coffee));
auto withSugar = std::make_unique<SugarDecorator>(std::move(withMilk));

// vs

auto coffee2 = std::make_unique<Espresso>();
auto withSugar2 = std::make_unique<SugarDecorator>(std::move(coffee2));
auto withMilk2 = std::make_unique<MilkDecorator>(std::move(withSugar2));
```

ğŸ¯ **æ¨èè¯­: **

> **è£…é¥°å™¨æ¨¡å¼æ˜¯è§£å†³â€œåŠŸèƒ½åŠ¨æ€ç»„åˆâ€é—®é¢˜çš„ä¼˜é›…æ–¹æ¡ˆã€‚å½“ä½ åŒå€¦äº†ç»§æ‰¿å¯¼è‡´çš„ç±»çˆ†ç‚¸, è£…é¥°å™¨æ¨¡å¼å°±æ˜¯ä½ çš„æ•‘æ˜Ÿï¼**

æŒæ¡è£…é¥°å™¨æ¨¡å¼, ä½ å°±èƒ½è®¾è®¡å‡ºé«˜åº¦çµæ´»ã€å¯æ‰©å±•ã€å¯ç»„åˆçš„ç³»ç»Ÿï¼

## ä»£ç 

```
// Decorator.h
#include <iostream>
#include <string>
#include <memory>

// ============ æŠ½è±¡ç»„ä»¶ ============
class Beverage {
public:
    virtual ~Beverage() = default;
    virtual double cost() const = 0;
    virtual std::string getDescription() const = 0;
};

// ============ å…·ä½“ç»„ä»¶ ============
class Espresso : public Beverage {
public:
    double cost() const override {
        return 1.99;
    }

    std::string getDescription() const override {
        return "Espresso";
    }
};

class HouseBlend : public Beverage {
public:
    double cost() const override {
        return 0.89;
    }

    std::string getDescription() const override {
        return "House Blend Coffee";
    }
};

// ============ æŠ½è±¡è£…é¥°å™¨ ============
class CondimentDecorator : public Beverage {
protected:
    std::unique_ptr<Beverage> beverage;

public:
    CondimentDecorator(std::unique_ptr<Beverage> b) : beverage(std::move(b)) {}
    virtual ~CondimentDecorator() = default;
};

// ============ å…·ä½“è£…é¥°å™¨ ============
class Milk : public CondimentDecorator {
public:
    Milk(std::unique_ptr<Beverage> b) : CondimentDecorator(std::move(b)) {}

    double cost() const override {
        return beverage->cost() + 0.10;
    }

    std::string getDescription() const override {
        return beverage->getDescription() + ", Milk";
    }
};

class Mocha : public CondimentDecorator {
public:
    Mocha(std::unique_ptr<Beverage> b) : CondimentDecorator(std::move(b)) {}

    double cost() const override {
        return beverage->cost() + 0.20;
    }

    std::string getDescription() const override {
        return beverage->getDescription() + ", Mocha";
    }
};

class Whip : public CondimentDecorator {
public:
    Whip(std::unique_ptr<Beverage> b) : CondimentDecorator(std::move(b)) {}

    double cost() const override {
        return beverage->cost() + 0.15;
    }

    std::string getDescription() const override {
        return beverage->getDescription() + ", Whip";
    }
};

// ============ å®¢æˆ·ç«¯ ============
#include "Decorator.h"

void printBeverage(const Beverage& b) {
    std::cout << b.getDescription() << " $" << b.cost() << std::endl;
}

int main() {
    std::cout << "=== è£…é¥°å™¨æ¨¡å¼: å’–å•¡è®¢å•ç³»ç»Ÿ ===\n\n";

    // åŸºç¡€å’–å•¡
    auto espresso = std::make_unique<Espresso>();
    printBeverage(*espresso);

    // è£…é¥°: åŠ æ‘©å¡ + æ‰“å¥¶æ³¡
    auto espressoWithMochaWhip = std::make_unique<Whip>(
        std::make_unique<Mocha>(std::move(espresso))
    );
    printBeverage(*espressoWithMochaWhip);

    // å¦ä¸€æ¯: æ··åˆå’–å•¡ + ç‰›å¥¶ + æ‘©å¡ + ç‰›å¥¶
    auto houseBlend = std::make_unique<HouseBlend>();
    auto fancyCoffee = std::make_unique<Milk>(
        std::make_unique<Mocha>(
            std::make_unique<Milk>(std::move(houseBlend))
        )
    );
    printBeverage(*fancyCoffee);

    return 0;
}
```

## PlantUML

```
@startuml

' æŠ½è±¡ç»„ä»¶
abstract class Beverage {
    +cost() : double {abstract}
    +getDescription() : string {abstract}
}

' å…·ä½“ç»„ä»¶
class Espresso {
    +cost() : double
    +getDescription() : string
}

class HouseBlend {
    +cost() : double
    +getDescription() : string
}

' æŠ½è±¡è£…é¥°å™¨
abstract class CondimentDecorator {
    -beverage: unique_ptr<Beverage>
    +cost() : double {abstract}
    +getDescription() : string {abstract}
}

' å…·ä½“è£…é¥°å™¨
class Milk {
    +cost() : double
    +getDescription() : string
}

class Mocha {
    +cost() : double
    +getDescription() : string
}

class Whip {
    +cost() : double
    +getDescription() : string
}

' å…³ç³»
Beverage <|-- Espresso
Beverage <|-- HouseBlend
Beverage <|-- CondimentDecorator

CondimentDecorator <|-- Milk
CondimentDecorator <|-- Mocha
CondimentDecorator <|-- Whip

CondimentDecorator *-- Beverage : "wraps"

note right of CondimentDecorator
    Holds a reference to
    a Beverage (composition).
    This is the DECORATOR core.
end note

note bottom of Milk
    Adds milk cost and
    description to any Beverage.
end note

@enduml
```

![](./picture/10.DecoratorPattern.png)





# 13. å¤–è§‚æ¨¡å¼

## ç®€ä»‹

> **å¤–è§‚æ¨¡å¼(Facade Pattern)** æ˜¯ä¸€ç§**ç»“æ„å‹è®¾è®¡æ¨¡å¼**, å®ƒ**ä¸ºå­ç³»ç»Ÿä¸­çš„ä¸€ç»„æ¥å£æä¾›ä¸€ä¸ªä¸€è‡´çš„ã€ç®€åŒ–çš„é«˜å±‚æ¥å£**, ä½¿å¾—å­ç³»ç»Ÿæ›´å®¹æ˜“ä½¿ç”¨ã€‚

 ğŸ¯ æ ¸å¿ƒæ€æƒ³: 

- **â€œå°è£…å¤æ‚æ€§, æä¾›ç®€å•é—¨é¢â€**
- **å®¢æˆ·ç«¯æ— éœ€äº†è§£å­ç³»ç»Ÿå†…éƒ¨ç»“æ„**
- **é™ä½è€¦åˆ, ç»Ÿä¸€å…¥å£**

> ğŸ’¡ ç»å…¸æ¯”å–»: 
>  **é…’åº—å‰å°** â€”â€” å®¢äººåªéœ€å‘Šè¯‰å‰å°â€œæˆ‘è¦å…¥ä½â€, å‰å°ä¼šåè°ƒå®¢æˆ¿éƒ¨ã€æ¸…æ´éƒ¨ã€å®‰ä¿éƒ¨ç­‰å¤šä¸ªéƒ¨é—¨å®Œæˆå…¥ä½æµç¨‹, å®¢äººæ— éœ€ä¸æ¯ä¸ªéƒ¨é—¨æ‰“äº¤é“ã€‚

------

 ğŸ§© ç»“æ„ç»„æˆ: 

| è§’è‰²                | è¯´æ˜                                                         |
| ------------------- | ------------------------------------------------------------ |
| `Subsystem Classes` | å­ç³»ç»Ÿä¸­çš„å¤šä¸ªå¤æ‚ç±»(å¦‚ `Light`, `Thermostat`, `Security`) |
| `Facade`            | å¤–è§‚ç±», å°è£…å­ç³»ç»Ÿè°ƒç”¨, æä¾›ç®€åŒ–æ¥å£(å¦‚ `turnOnHome()`, `turnOffHome()`) |
| `Client`            | å®¢æˆ·ç«¯, åªä¸ `Facade` äº¤äº’, ä¸ç›´æ¥è®¿é—®å­ç³»ç»Ÿ                 |

> ğŸ“Œ **å…³é”®ç‚¹: **
>  Facade **ä¸å°è£…æ–°åŠŸèƒ½**, åªæ˜¯**ç»„åˆå’Œç®€åŒ–å·²æœ‰åŠŸèƒ½çš„è°ƒç”¨æµç¨‹**ã€‚

------

 âœ… é€‚ç”¨åœºæ™¯

1. **å­ç³»ç»Ÿå¤æ‚, æ¥å£ä¼—å¤š, ä½¿ç”¨å›°éš¾**
2. **å®¢æˆ·ç«¯ä¸å­ç³»ç»Ÿä¹‹é—´å­˜åœ¨è¿‡å¤šç›´æ¥ä¾èµ–**
3. **éœ€è¦ä¸ºå­ç³»ç»Ÿæä¾›ä¸€ä¸ªç»Ÿä¸€ã€ç®€åŒ–çš„è®¿é—®å…¥å£**
4. **åˆ†å±‚æ¶æ„ä¸­, ä¸Šå±‚æ¨¡å—éœ€è¦ç®€åŒ–å¯¹ä¸‹å±‚æ¨¡å—çš„è°ƒç”¨**

ğŸ“Œ **å…¸å‹åº”ç”¨åœºæ™¯: **

- ğŸ  **æ™ºèƒ½å®¶å±…ç³»ç»Ÿ**: ä¸€é”®â€œå›å®¶æ¨¡å¼â€ â†’ å¼€ç¯ + è°ƒæ¸© + è§£é™¤è­¦æŠ¥
- ğŸ› ï¸ **ç¼–è¯‘å™¨å­ç³»ç»Ÿ**: `compile()` â†’ è¯æ³•åˆ†æ + è¯­æ³•åˆ†æ + ä»£ç ç”Ÿæˆ
- ğŸ“¦ **API å°è£…åº“**: å°è£…å¤æ‚çš„ç¬¬ä¸‰æ–¹åº“(å¦‚ OpenGLã€FFmpeg)æä¾›ç®€å•æ¥å£
- ğŸ¦ **é“¶è¡Œç³»ç»Ÿ**: `applyLoan()` â†’ ä¿¡ç”¨æ£€æŸ¥ + é£æ§å®¡æ ¸ + åˆåŒç”Ÿæˆ + æ”¾æ¬¾
- ğŸ® **æ¸¸æˆå¼•æ“å¯åŠ¨**: `startGame()` â†’ åŠ è½½èµ„æº + åˆå§‹åŒ–éŸ³é¢‘ + å¯åŠ¨ç‰©ç†å¼•æ“ + æ˜¾ç¤ºä¸»èœå•

------

 âœ… ä¼˜ç¼ºç‚¹

 âœ… ä¼˜ç‚¹: 

1. **ç®€åŒ–å®¢æˆ·ç«¯ä½¿ç”¨** â†’ éšè—å­ç³»ç»Ÿå¤æ‚æ€§
2. **é™ä½è€¦åˆåº¦** â†’ å®¢æˆ·ç«¯åªä¾èµ–å¤–è§‚, ä¸ä¾èµ–å…·ä½“å­ç³»ç»Ÿ
3. **æé«˜å¯ç»´æŠ¤æ€§** â†’ å­ç³»ç»Ÿå˜åŒ–ä¸å½±å“å®¢æˆ·ç«¯(åªè¦å¤–è§‚æ¥å£ä¸å˜)
4. **ç¬¦åˆè¿ªç±³ç‰¹æ³•åˆ™(æœ€å°‘çŸ¥è¯†åŸåˆ™)** â†’ å®¢æˆ·ç«¯åªéœ€çŸ¥é“å¤–è§‚
5. **ä¾¿äºåˆ†å±‚è®¾è®¡** â†’ æ¯å±‚å¯æä¾›è‡ªå·±çš„å¤–è§‚

 âŒ ç¼ºç‚¹: 

1. **ä¸ç¬¦åˆå¼€é—­åŸåˆ™** â†’ æ–°å¢å­ç³»ç»ŸåŠŸèƒ½å¯èƒ½éœ€è¦ä¿®æ”¹å¤–è§‚ç±»
2. **å¯èƒ½æˆä¸ºâ€œä¸Šå¸ç±»â€** â†’ å¦‚æœå¤–è§‚æ‰¿æ‹…è¿‡å¤šèŒè´£, ä¼šå˜å¾—è‡ƒè‚¿
3. **çµæ´»æ€§å—é™** â†’ å®¢æˆ·ç«¯æ— æ³•ç²¾ç»†æ§åˆ¶å­ç³»ç»Ÿ(é™¤éæä¾›â€œé€ƒç”Ÿèˆ±å£â€)

------

 âœ… æ³¨æ„äº‹é¡¹

 1. ğŸ”„ å¤–è§‚ â‰  å°è£…æ‰€æœ‰åŠŸèƒ½

> å¤–è§‚åº”æä¾›**å¸¸ç”¨ã€é«˜å±‚**æ“ä½œ, ä¸æ˜¯æ›¿ä»£å­ç³»ç»Ÿã€‚
>  åº”å…è®¸å®¢æˆ·ç«¯åœ¨å¿…è¦æ—¶**ç»•è¿‡å¤–è§‚**ç›´æ¥è®¿é—®å­ç³»ç»Ÿ(â€œé€ƒç”Ÿèˆ±å£â€è®¾è®¡)ã€‚


```
class HomeFacade {
    LightSystem light;
    ACSystem ac;
public:
    void turnOnHome() { ... } // ç®€åŒ–æ¥å£

    // é€ƒç”Ÿèˆ±å£: å…è®¸ç›´æ¥è®¿é—®å­ç³»ç»Ÿ
    LightSystem& getLightSystem() { return light; }
};
```

------

 2. ğŸš« å¤–è§‚ â‰  é€‚é…å™¨

| æ¨¡å¼   | ç›®çš„                     |
| ------ | ------------------------ |
| å¤–è§‚   | **ç®€åŒ–æ¥å£, å°è£…å¤æ‚æ€§** |
| é€‚é…å™¨ | **è½¬æ¢æ¥å£, å…¼å®¹ä¸åŒ¹é…** |

> ğŸ’¡ **å¤–è§‚ = â€œç®€åŒ–æ“ä½œâ€, é€‚é…å™¨ = â€œæ¥å£ç¿»è¯‘â€**

------

 3. ğŸš« å¤–è§‚ â‰  ä¸­ä»‹è€…

| æ¨¡å¼   | ç›®çš„                     | äº¤äº’æ–¹å¼                     |
| ------ | ------------------------ | ---------------------------- |
| å¤–è§‚   | **å°è£…å­ç³»ç»Ÿ, å•å‘è°ƒç”¨** | Client â†’ Facade â†’ Subsystems |
| ä¸­ä»‹è€… | **åè°ƒå¯¹è±¡é—´äº¤äº’**       | Objects â†” Mediator â†” Objects |

> ğŸ’¡ **å¤–è§‚æ˜¯â€œé—¨é¢â€, ä¸­ä»‹è€…æ˜¯â€œè°ƒåº¦ä¸­å¿ƒâ€**

------

 4. âœ… å¤–è§‚ç±»åº”å°½é‡ä¿æŒæ— çŠ¶æ€æˆ–è½»çŠ¶æ€

> é¿å…å¤–è§‚ç±»æ‰¿æ‹…ä¸šåŠ¡é€»è¾‘æˆ–çŠ¶æ€ç®¡ç†, å®ƒåªæ˜¯â€œåè°ƒè€…â€ã€‚

------

 5. âœ… å¯è®¾è®¡å¤šå±‚å¤–è§‚(Layered Facade)

```
class LowLevelFacade { ... };     // å°è£…ç¡¬ä»¶é©±åŠ¨
class MidLevelFacade { ... };     // å°è£…ä¸šåŠ¡é€»è¾‘
class HighLevelFacade { ... };    // å°è£…ç”¨æˆ·æ“ä½œ
```

------

 6. âœ… å¤–è§‚ç±»å¯è¢«å¤šä¸ªå®¢æˆ·ç«¯å…±äº«

> é€šå¸¸è®¾è®¡ä¸ºæ— çŠ¶æ€æˆ–ä½¿ç”¨ä¾èµ–æ³¨å…¥, å¯å®‰å…¨å…±äº«ã€‚

 âœ… ä¸€å¥è¯æ€»ç»“: 

> **â€œä½ åªç®¡è¯´â€˜æˆ‘è¦å›å®¶â€™, å‰©ä¸‹çš„äº¤ç»™æˆ‘æ¥åè°ƒï¼â€**

ğŸ¯ **æ¨èè¯­: **

> **å¤–è§‚æ¨¡å¼æ˜¯é™ä½ç³»ç»Ÿå¤æ‚åº¦çš„åˆ©å™¨ã€‚æ— è®ºæ˜¯å°è£…ç¬¬ä¸‰æ–¹åº“ã€ç®€åŒ–å†…éƒ¨æ¨¡å—è°ƒç”¨, è¿˜æ˜¯æä¾›ç”¨æˆ·å‹å¥½æ¥å£, å¤–è§‚æ¨¡å¼éƒ½èƒ½è®©ä½ çš„ä»£ç æ›´æ¸…æ™°ã€æ›´æ˜“ç”¨ï¼**

æŒæ¡å¤–è§‚æ¨¡å¼, ä½ å°±æŒæ¡äº†â€œåŒ–ç¹ä¸ºç®€â€çš„æ¶æ„è‰ºæœ¯ï¼

## ä»£ç 

```
// Facade.h
#include <iostream>
#include <string>

// ============ å­ç³»ç»Ÿç±» ============
class LightSystem {
public:
    void turnOn() { std::cout << "ğŸ’¡ Lights ON\n"; }
    void turnOff() { std::cout << "ğŸ’¡ Lights OFF\n"; }
    void setBrightness(int level) { std::cout << "ğŸ”† Brightness set to " << level << "%\n"; }
};

class ACSystem {
public:
    void turnOn() { std::cout << "â„ï¸ AC ON\n"; }
    void turnOff() { std::cout << "â„ï¸ AC OFF\n"; }
    void setTemperature(int temp) { std::cout << "ğŸŒ¡ï¸ Temperature set to " << temp << "Â°C\n"; }
};

class SecuritySystem {
public:
    void arm() { std::cout << "ğŸ”’ Security System ARMED\n"; }
    void disarm() { std::cout << "ğŸ”“ Security System DISARMED\n"; }
    void triggerAlarm() { std::cout << "ğŸš¨ ALARM TRIGGERED!\n"; }
};

class EntertainmentSystem {
public:
    void turnOnTV() { std::cout << "ğŸ“º TV ON\n"; }
    void turnOffTV() { std::cout << "ğŸ“º TV OFF\n"; }
    void playMusic() { std::cout << "ğŸµ Playing relaxing music...\n"; }
};

// ============ å¤–è§‚ç±» ============
class HomeFacade {
private:
    LightSystem light;
    ACSystem ac;
    SecuritySystem security;
    EntertainmentSystem entertainment;

public:
    // ä¸€é”®å›å®¶æ¨¡å¼
    void activateHomeMode() {
        std::cout << "\n=== ğŸ  Activating HOME Mode ===\n";
        security.disarm();
        light.turnOn();
        light.setBrightness(80);
        ac.turnOn();
        ac.setTemperature(24);
        entertainment.turnOnTV();
        entertainment.playMusic();
    }

    // ä¸€é”®ç¦»å®¶æ¨¡å¼
    void activateAwayMode() {
        std::cout << "\n=== ğŸšª Activating AWAY Mode ===\n";
        light.turnOff();
        ac.turnOff();
        entertainment.turnOffTV();
        security.arm();
    }

    // ä¸€é”®ç¡çœ æ¨¡å¼
    void activateSleepMode() {
        std::cout << "\n=== ğŸ˜´ Activating SLEEP Mode ===\n";
        light.setBrightness(10);
        ac.setTemperature(26);
        entertainment.turnOffTV();
    }

    // é€ƒç”Ÿèˆ±å£: å…è®¸ç›´æ¥è®¿é—®å­ç³»ç»Ÿ
    LightSystem& getLightSystem() { return light; }
    ACSystem& getACSystem() { return ac; }
};

// ============ å®¢æˆ·ç«¯ä½¿ç”¨ ============
#include "Facade.h"

int main() {
    std::cout << "=== å¤–è§‚æ¨¡å¼: æ™ºèƒ½å®¶å±…ç³»ç»Ÿ ===\n";

    HomeFacade home;

    // ç”¨æˆ·åªéœ€æ“ä½œå¤–è§‚, æ— éœ€äº†è§£å­ç³»ç»Ÿç»†èŠ‚
    home.activateHomeMode();
    home.activateSleepMode();
    home.activateAwayMode();

    // ç‰¹æ®Šéœ€æ±‚: ç›´æ¥è°ƒç”¨å­ç³»ç»Ÿ(é€ƒç”Ÿèˆ±å£)
    std::cout << "\n=== ç‰¹æ®Šæ“ä½œ: ç›´æ¥è°ƒå…‰ ===\n";
    home.getLightSystem().setBrightness(50);

    return 0;
}
```

è¾“å‡º

```
=== å¤–è§‚æ¨¡å¼: æ™ºèƒ½å®¶å±…ç³»ç»Ÿ ===

=== ğŸ  Activating HOME Mode ===
ğŸ”“ Security System DISARMED
ğŸ’¡ Lights ON
ğŸ”† Brightness set to 80%
â„ï¸ AC ON
ğŸŒ¡ï¸ Temperature set to 24Â°C
ğŸ“º TV ON
ğŸµ Playing relaxing music...

=== ğŸ˜´ Activating SLEEP Mode ===
ğŸ”† Brightness set to 10%
ğŸŒ¡ï¸ Temperature set to 26Â°C
ğŸ“º TV OFF

=== ğŸšª Activating AWAY Mode ===
ğŸ’¡ Lights OFF
â„ï¸ AC OFF
ğŸ“º TV OFF
ğŸ”’ Security System ARMED

=== ç‰¹æ®Šæ“ä½œ: ç›´æ¥è°ƒå…‰ ===
ğŸ”† Brightness set to 50%
```



## PlantUML

```
@startuml

' å­ç³»ç»Ÿç±»
class LightSystem {
    +turnOn()
    +turnOff()
    +setBrightness(level)
}

class ACSystem {
    +turnOn()
    +turnOff()
    +setTemperature(temp)
}

class SecuritySystem {
    +arm()
    +disarm()
    +triggerAlarm()
}

class EntertainmentSystem {
    +turnOnTV()
    +turnOffTV()
    +playMusic()
}

' å¤–è§‚ç±»
class HomeFacade {
    -light: LightSystem
    -ac: ACSystem
    -security: SecuritySystem
    -entertainment: EntertainmentSystem
    +activateHomeMode()
    +activateAwayMode()
    +activateSleepMode()
    +getLightSystem() : LightSystem&
}

' å®¢æˆ·ç«¯
class Client {
    +main()
}

' å…³ç³»
Client --> HomeFacade : uses
HomeFacade --> LightSystem : uses
HomeFacade --> ACSystem : uses
HomeFacade --> SecuritySystem : uses
HomeFacade --> EntertainmentSystem : uses

note right of HomeFacade
    Provides simplified interface
    to complex subsystem.
    Follows "Facade Pattern".
end note

note bottom of Client
    Only interacts with Facade,
    not with subsystem classes.
end note

@enduml
```

![](./picture/11.FacadePattern.png)


# 14. äº«å…ƒæ¨¡å¼

## ç®€ä»‹

> **äº«å…ƒæ¨¡å¼(Flyweight Pattern)** æ˜¯ä¸€ç§**ç»“æ„å‹è®¾è®¡æ¨¡å¼**, å®ƒ**é€šè¿‡å…±äº«æŠ€æœ¯, æœ‰æ•ˆåœ°æ”¯æŒå¤§é‡ç»†ç²’åº¦å¯¹è±¡çš„å¤ç”¨**, ä»è€Œ**å‡å°‘å†…å­˜å ç”¨å’Œå¯¹è±¡åˆ›å»ºå¼€é”€**ã€‚

 ğŸ¯ æ ¸å¿ƒæ€æƒ³: 

- **â€œå…±äº«ç›¸åŒçŠ¶æ€çš„å¯¹è±¡, é¿å…é‡å¤åˆ›å»ºâ€**
- **åŒºåˆ†å†…éƒ¨çŠ¶æ€(å¯å…±äº«)å’Œå¤–éƒ¨çŠ¶æ€(ä¸å¯å…±äº«)**
- **ä½¿ç”¨â€œäº«å…ƒå·¥å‚â€ç®¡ç†å…±äº«å¯¹è±¡æ± **

> ğŸ’¡ ç»å…¸æ¯”å–»: 
>  **æ–‡å­—å¤„ç†å™¨ä¸­çš„å­—ç¬¦å¯¹è±¡** â€”â€” å­—æ¯ `'A'` åœ¨æ–‡æ¡£ä¸­å‡ºç° 1000 æ¬¡, ä½†å†…å­˜ä¸­åªéœ€åˆ›å»ºä¸€ä¸ª `'A'` å¯¹è±¡, é€šè¿‡å¤–éƒ¨çŠ¶æ€(ä½ç½®ã€é¢œè‰²ã€å­—ä½“å¤§å°)æ¥åŒºåˆ†æ¯æ¬¡æ¸²æŸ“ã€‚

------

 ğŸ§© ç»“æ„ç»„æˆ: 

| è§’è‰²                | è¯´æ˜                                                         |
| ------------------- | ------------------------------------------------------------ |
| `Flyweight`         | æŠ½è±¡äº«å…ƒç±», å®šä¹‰æ¥å£(å¦‚ `render(x, y)`), æ¥å—å¤–éƒ¨çŠ¶æ€å‚æ•°  |
| `ConcreteFlyweight` | å…·ä½“äº«å…ƒç±», å­˜å‚¨**å†…éƒ¨çŠ¶æ€**(å¦‚å­—ç¬¦ã€å›¾ç‰‡ID), å®ç°å…±äº«é€»è¾‘ |
| `FlyweightFactory`  | äº«å…ƒå·¥å‚, åˆ›å»ºå¹¶ç®¡ç†äº«å…ƒå¯¹è±¡æ± (é€šå¸¸ç”¨ `std::map` æˆ– `std::unordered_map`) |
| `Client`            | å®¢æˆ·ç«¯, ç»´æŠ¤**å¤–éƒ¨çŠ¶æ€**(å¦‚ä½ç½®ã€é¢œè‰²), è°ƒç”¨äº«å…ƒå¯¹è±¡       |

> ğŸ“Œ **å…³é”®æ¦‚å¿µ: **
>
> - **å†…éƒ¨çŠ¶æ€(Intrinsic State)**: å­˜å‚¨åœ¨äº«å…ƒå¯¹è±¡å†…éƒ¨, å¯å…±äº«(å¦‚å­—ç¬¦ã€çº¹ç†ID)
> - **å¤–éƒ¨çŠ¶æ€(Extrinsic State)**: ç”±å®¢æˆ·ç«¯ä¼ å…¥, ä¸å¯å…±äº«(å¦‚åæ ‡ã€é¢œè‰²ã€æ—‹è½¬è§’åº¦)

------

 âœ… é€‚ç”¨åœºæ™¯

1. **ç¨‹åºä¸­å­˜åœ¨å¤§é‡ç›¸ä¼¼å¯¹è±¡, é€ æˆå†…å­˜å‹åŠ›**
2. **å¯¹è±¡å¤§éƒ¨åˆ†çŠ¶æ€å¯ä»¥å¤–éƒ¨åŒ–(æå–ä¸ºå‚æ•°)**
3. **å¯¹è±¡å¯è¢«ç¼“å­˜å’Œå¤ç”¨**
4. **æ€§èƒ½æˆ–å†…å­˜æ˜¯å…³é”®ç“¶é¢ˆ**

ğŸ“Œ **å…¸å‹åº”ç”¨åœºæ™¯: **

- ğŸ“ **æ–‡å­—ç¼–è¾‘å™¨/æ’ç‰ˆç³»ç»Ÿ**: å…±äº«å­—ç¬¦å¯¹è±¡(å¦‚ 1000 ä¸ª 'A' â†’ 1 ä¸ªå¯¹è±¡)

- ğŸ®

   

  æ¸¸æˆå¼€å‘

  : 

  - å­å¼¹ã€ç²’å­ã€æ•Œäººç±»å‹(ç›¸åŒç±»å‹çš„å¯¹è±¡å…±äº«çº¹ç†ã€æ¨¡å‹)
  - åœ°å›¾ç“¦ç‰‡ç³»ç»Ÿ(ç›¸åŒåœ°å½¢å…±äº«è´´å›¾)

- ğŸ–¼ï¸ **å›¾å½¢ç•Œé¢ç³»ç»Ÿ**: å›¾æ ‡ã€æŒ‰é’®æ ·å¼å…±äº«

- ğŸ§¬ **ç”Ÿç‰©ä¿¡æ¯å­¦**: å…±äº« DNA ç¢±åŸºå¯¹è±¡(A, T, C, G)

- ğŸ“Š **æ•°æ®å¯è§†åŒ–**: å…±äº«æŸ±çŠ¶å›¾ã€é¥¼å›¾çš„æ ·å¼å¯¹è±¡

------

 âœ… ä¼˜ç¼ºç‚¹

 âœ… ä¼˜ç‚¹: 

1. **æå¤§å‡å°‘å†…å­˜å ç”¨** â†’ å…±äº«å¯¹è±¡, é¿å…é‡å¤åˆ›å»º
2. **æå‡æ€§èƒ½** â†’ å‡å°‘å¯¹è±¡åˆ›å»º/é”€æ¯å¼€é”€
3. **å¤–éƒ¨çŠ¶æ€ä¸å†…éƒ¨çŠ¶æ€åˆ†ç¦»** â†’ èŒè´£æ¸…æ™°
4. **é€‚åˆå¤§è§„æ¨¡å¯¹è±¡ç³»ç»Ÿ** â†’ å¦‚æ¸¸æˆã€å›¾å½¢ã€æ–‡æœ¬å¤„ç†

 âŒ ç¼ºç‚¹: 

1. **ä»£ç å¤æ‚åº¦å¢åŠ ** â†’ éœ€ç®¡ç†å¯¹è±¡æ± ã€åŒºåˆ†å†…å¤–çŠ¶æ€
2. **å¤–éƒ¨çŠ¶æ€éœ€å®¢æˆ·ç«¯ç»´æŠ¤** â†’ å¢åŠ å®¢æˆ·ç«¯è´Ÿæ‹…
3. **çº¿ç¨‹å®‰å…¨é—®é¢˜** â†’ å¤šçº¿ç¨‹è®¿é—®å·¥å‚éœ€åŠ é”(C++ ä¸­)
4. **è°ƒè¯•å›°éš¾** â†’ å¯¹è±¡è¢«å¤šä¸ªå®¢æˆ·ç«¯å…±äº«, çŠ¶æ€è¿½è¸ªå¤æ‚

------

 âœ… æ³¨æ„äº‹é¡¹

 1. ğŸ”„ å¿…é¡»åŒºåˆ†å†…éƒ¨çŠ¶æ€å’Œå¤–éƒ¨çŠ¶æ€


```
class CharacterFlyweight {
    char symbol; // å†…éƒ¨çŠ¶æ€: å¯å…±äº«(å¦‚ 'A')
public:
    void render(int x, int y, Color color); // å¤–éƒ¨çŠ¶æ€: ä½ç½®ã€é¢œè‰²ç”±å®¢æˆ·ç«¯ä¼ å…¥
};
```

> âœ… å†…éƒ¨çŠ¶æ€ = å¯¹è±¡æœ¬è´¨å±æ€§(ä¸å˜æˆ–æå°‘å˜)
>  âœ… å¤–éƒ¨çŠ¶æ€ = ä¸Šä¸‹æ–‡ç›¸å…³å±æ€§(æ¯æ¬¡è°ƒç”¨å¯èƒ½ä¸åŒ)

------

 2. âš ï¸ äº«å…ƒå¯¹è±¡åº”å°½é‡**ä¸å¯å˜(Immutable)**

> ä¸€æ—¦åˆ›å»º, å†…éƒ¨çŠ¶æ€ä¸åº”è¢«ä¿®æ”¹, ç¡®ä¿çº¿ç¨‹å®‰å…¨å’Œå…±äº«å®‰å…¨ã€‚


```
class TreeType { // ä¸å¯å˜äº«å…ƒ
    std::string name;
    Color color;
    Texture texture;
public:
    TreeType(std::string n, Color c, Texture t) : name(n), color(c), texture(t) {}
    void draw(int x, int y) const { ... } // const æ–¹æ³•
};
```

------

 3. ğŸš« äº«å…ƒ â‰  å•ä¾‹

| æ¨¡å¼ | ç›®çš„                 |
| ---- | -------------------- |
| äº«å…ƒ | **å…±äº«å¤§é‡ç›¸ä¼¼å¯¹è±¡** |
| å•ä¾‹ | **ç¡®ä¿å…¨å±€å”¯ä¸€å®ä¾‹** |

> ğŸ’¡ äº«å…ƒæ± ä¸­å¯èƒ½æœ‰å¤šä¸ªä¸åŒäº«å…ƒå¯¹è±¡(å¦‚ 'A', 'B', 'C' å„ä¸€ä¸ª), å•ä¾‹åªæœ‰ä¸€ä¸ªå¯¹è±¡ã€‚

------

 4. âœ… ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆæˆ–å¼•ç”¨ç®¡ç†äº«å…ƒå¯¹è±¡


```
std::shared_ptr<Flyweight> getFlyweight(const std::string& key);
```

> é¿å…è£¸æŒ‡é’ˆ, é˜²æ­¢å†…å­˜æ³„æ¼ã€‚å·¥å‚åº”ç®¡ç†ç”Ÿå‘½å‘¨æœŸã€‚

------

 5. âš ï¸ çº¿ç¨‹å®‰å…¨(C++ å¤šçº¿ç¨‹ç¯å¢ƒ)


```
class FlyweightFactory {
    std::unordered_map<std::string, std::shared_ptr<Flyweight>> pool;
    mutable std::mutex mtx; // ä¿æŠ¤ pool

public:
    std::shared_ptr<Flyweight> getFlyweight(const std::string& key) {
        std::lock_guard<std::mutex> lock(mtx);
        if (pool.find(key) == pool.end()) {
            pool[key] = std::make_shared<ConcreteFlyweight>(key);
        }
        return pool[key];
    }
};
```

------

 6. âœ… äº«å…ƒå·¥å‚åº”æä¾›æ¸…é™¤æœºåˆ¶(å¯é€‰)

> é˜²æ­¢å†…å­˜æ³„æ¼, å¯å®šæœŸæ¸…ç†æœªä½¿ç”¨å¯¹è±¡(å¼•ç”¨è®¡æ•° or LRU ç­–ç•¥)ã€‚

------

 7. âœ… é€‚ç”¨äºâ€œå¤§é‡å¯¹è±¡ + é‡å¤çŠ¶æ€â€åœºæ™¯

> å¦‚æœå¯¹è±¡æ•°é‡å°‘æˆ–çŠ¶æ€å‡ ä¹ä¸é‡å¤, äº«å…ƒæ¨¡å¼åè€Œå¢åŠ å¤æ‚åº¦ã€‚




## ä»£ç 

```
// Flyweight.h
#include <iostream>
#include <string>
#include <unordered_map>
#include <memory>
#include <mutex>

// ============ å¤–éƒ¨çŠ¶æ€: ç”±å®¢æˆ·ç«¯ç»´æŠ¤ ============
struct Position {
    int x, y;
    Position(int x, int y) : x(x), y(y) {}
};

enum class Color { RED, GREEN, BLUE, BLACK };

// ============ æŠ½è±¡äº«å…ƒ ============
class CharacterFlyweight {
public:
    virtual ~CharacterFlyweight() = default;
    virtual void render(const Position& pos, Color color) const = 0;
    virtual char getSymbol() const = 0;
};

// ============ å…·ä½“äº«å…ƒ ============
class ConcreteCharacter : public CharacterFlyweight {
    char symbol; // å†…éƒ¨çŠ¶æ€: å¯å…±äº«

public:
    ConcreteCharacter(char c) : symbol(c) {
        std::cout << "Creating character: '" << symbol << "'\n";
    }

    void render(const Position& pos, Color color) const override {
        std::string colorStr = (color == Color::RED) ? "RED" :
                              (color == Color::GREEN) ? "GREEN" :
                              (color == Color::BLUE) ? "BLUE" : "BLACK";
        std::cout << "Rendering '" << symbol << "' at (" << pos.x << "," << pos.y
                  << ") in " << colorStr << " color.\n";
    }

    char getSymbol() const override { return symbol; }
};

// ============ äº«å…ƒå·¥å‚ ============
class CharacterFactory {
private:
    std::unordered_map<char, std::shared_ptr<CharacterFlyweight>> pool;
    mutable std::mutex mtx;

public:
    std::shared_ptr<CharacterFlyweight> getCharacter(char c) {
        std::lock_guard<std::mutex> lock(mtx);
        if (pool.find(c) == pool.end()) {
            pool[c] = std::make_shared<ConcreteCharacter>(c);
        }
        return pool[c];
    }

    size_t getPoolSize() const {
        std::lock_guard<std::mutex> lock(mtx);
        return pool.size();
    }
};

// ============ å®¢æˆ·ç«¯ ============
#include "Flyweight.h"

int main() {
    std::cout << "=== äº«å…ƒæ¨¡å¼: å­—ç¬¦æ¸²æŸ“ç³»ç»Ÿ ===\n\n";

    CharacterFactory factory;

    // æ¨¡æ‹Ÿæ¸²æŸ“æ–‡æ¡£ä¸­çš„å­—ç¬¦
    std::string document = "AAABBBCCCDDDAAABBB";

    std::cout << "Rendering document: " << document << "\n\n";

    int x = 0, y = 0;
    for (char c : document) {
        auto character = factory.getCharacter(c);
        character->render(Position(x, y), Color::BLACK);
        x += 10; // æ°´å¹³ç§»åŠ¨
        if (x > 50) { x = 0; y += 20; } // æ¢è¡Œ
    }

    std::cout << "\n=== ç»Ÿè®¡ ===\n";
    std::cout << "æ–‡æ¡£é•¿åº¦: " << document.length() << " å­—ç¬¦\n";
    std::cout << "äº«å…ƒæ± å¤§å°: " << factory.getPoolSize() << " ä¸ªå¯¹è±¡\n";
    std::cout << "èŠ‚çœå¯¹è±¡: " << document.length() - factory.getPoolSize() << " ä¸ª\n";

    return 0;
}
```



## PlantUML

```
@startuml

' æŠ½è±¡äº«å…ƒ
abstract class Flyweight {
    +render(extrinsicState) {abstract}
}

' å…·ä½“äº«å…ƒ
class ConcreteFlyweight {
    -intrinsicState
    +render(extrinsicState)
}

' äº«å…ƒå·¥å‚
class FlyweightFactory {
    -pool: Map<Key, Flyweight>
    +getFlyweight(key): Flyweight
}

' å®¢æˆ·ç«¯
class Client {
    -extrinsicState
    +operation()
}

' å…³ç³»
Flyweight <|-- ConcreteFlyweight
FlyweightFactory --> Flyweight : manages pool
Client --> FlyweightFactory : requests
Client --> Flyweight : uses

note right of Flyweight
    Defines interface for
    rendering with extrinsic state.
end note

note right of ConcreteFlyweight
    Stores intrinsic state.
    Immutable recommended.
end note

note bottom of FlyweightFactory
    Creates and manages
    shared flyweight objects.
    Thread-safe in C++.
end note

note top of Client
    Maintains extrinsic state
    and coordinates rendering.
end note

@enduml
```

![](./picture/12.Flyweight Pattern.png)


# 15. ä»£ç†æ¨¡å¼

## ç®€ä»‹

> **ä»£ç†æ¨¡å¼(Proxy Pattern)** æ˜¯ä¸€ç§**ç»“æ„å‹è®¾è®¡æ¨¡å¼**, å®ƒ**ä¸ºå¦ä¸€ä¸ªå¯¹è±¡æä¾›ä¸€ä¸ªæ›¿èº«æˆ–å ä½ç¬¦, ä»¥æ§åˆ¶å¯¹è¿™ä¸ªå¯¹è±¡çš„è®¿é—®**ã€‚

 ğŸ¯ æ ¸å¿ƒæ€æƒ³: 

- **â€œä»£æ›¿çœŸå®å¯¹è±¡, æ§åˆ¶è®¿é—®â€**
- **ä»£ç†ä¸çœŸå®å¯¹è±¡å®ç°ç›¸åŒæ¥å£**
- **å®¢æˆ·ç«¯æ— æ„ŸçŸ¥, ä»¥ä¸ºåœ¨æ“ä½œçœŸå®å¯¹è±¡**

> ğŸ’¡ ç»å…¸æ¯”å–»: 
>  **æ¸¸æˆä»£ç»ƒ** â€”â€” ä½ (å®¢æˆ·ç«¯)ä»¥ä¸ºè‡ªå·±åœ¨æ‰“æ¸¸æˆ, å…¶å®æ˜¯ä»£ç»ƒ(ä»£ç†)åœ¨æ“ä½œä½ çš„è´¦å·(çœŸå®å¯¹è±¡), ä»–å¯ä»¥æ§åˆ¶ä½ ä»€ä¹ˆæ—¶å€™èƒ½ç©ã€èƒ½ä¸èƒ½ç©ã€ç©ä¹‹å‰è¦ä¸è¦äº¤é’±ã€‚

------

 ğŸ§© ç»“æ„ç»„æˆ: 

| è§’è‰²          | è¯´æ˜                                                         |
| ------------- | ------------------------------------------------------------ |
| `Subject`     | æŠ½è±¡ä¸»é¢˜æ¥å£(å¦‚ `IImage`, `IService`)                      |
| `RealSubject` | çœŸå®å¯¹è±¡(å¦‚ `RealImage`, `RealService`), æ‰§è¡Œå®é™…ä¸šåŠ¡é€»è¾‘  |
| `Proxy`       | ä»£ç†å¯¹è±¡, æŒæœ‰å¯¹ `RealSubject` çš„å¼•ç”¨, æ§åˆ¶è®¿é—®(å¦‚å»¶è¿ŸåŠ è½½ã€æƒé™æ£€æŸ¥) |
| `Client`      | å®¢æˆ·ç«¯, é€šè¿‡ `Proxy` è®¿é—® `RealSubject`, æ— æ„ŸçŸ¥              |

> ğŸ“Œ **å…³é”®ç‚¹: **
>  ä»£ç†ä¸çœŸå®å¯¹è±¡**å®ç°åŒä¸€æ¥å£**, å®¢æˆ·ç«¯**æ— éœ€ä¿®æ”¹ä»£ç **å³å¯åˆ‡æ¢ã€‚

------

 âœ… é€‚ç”¨åœºæ™¯

1. **å»¶è¿Ÿåˆå§‹åŒ–(Lazy Initialization)** â€”â€” å¯¹è±¡åˆ›å»ºå¼€é”€å¤§, é¦–æ¬¡ä½¿ç”¨æ—¶æ‰åˆ›å»º
2. **è®¿é—®æ§åˆ¶(Access Control)** â€”â€” æƒé™æ£€æŸ¥ã€ç™»å½•éªŒè¯
3. **è¿œç¨‹ä»£ç†(Remote Proxy)** â€”â€” æœ¬åœ°ä»£è¡¨è¿œç¨‹å¯¹è±¡(å¦‚ RPCã€Web Service)
4. **æ—¥å¿—è®°å½• / ç›‘æ§** â€”â€” è°ƒç”¨å‰åè®°å½•æ—¥å¿—ã€ç»Ÿè®¡è€—æ—¶
5. **ç¼“å­˜ä»£ç†(Caching Proxy)** â€”â€” ç¼“å­˜ç»“æœ, é¿å…é‡å¤è®¡ç®—
6. **æ™ºèƒ½æŒ‡é’ˆ / å¼•ç”¨è®¡æ•°** â€”â€” æ§åˆ¶å¯¹è±¡ç”Ÿå‘½å‘¨æœŸ

ğŸ“Œ **å…¸å‹åº”ç”¨åœºæ™¯: **

- ğŸ–¼ï¸ **å›¾åƒæ‡’åŠ è½½**: å›¾ç‰‡é¦–æ¬¡æ˜¾ç¤ºæ—¶æ‰ä»ç£ç›˜/ç½‘ç»œåŠ è½½
- ğŸ” **æƒé™æ§åˆ¶**: è®¿é—®æ•æ„Ÿæ“ä½œå‰æ£€æŸ¥ç”¨æˆ·æƒé™
- ğŸŒ **è¿œç¨‹æœåŠ¡è°ƒç”¨**: æœ¬åœ°ä»£ç†å°è£…ç½‘ç»œé€šä¿¡
- â±ï¸ **æ€§èƒ½ç›‘æ§**: è®°å½•æ–¹æ³•æ‰§è¡Œæ—¶é—´
- ğŸ’¾ **ç¼“å­˜æ•°æ®åº“æŸ¥è¯¢ç»“æœ**
- ğŸ§µ **çº¿ç¨‹å®‰å…¨ä»£ç†**: ä¸ºéçº¿ç¨‹å®‰å…¨å¯¹è±¡æ·»åŠ é”

------

 âœ… ä¼˜ç¼ºç‚¹

 âœ… ä¼˜ç‚¹: 

1. **æ§åˆ¶è®¿é—®** â†’ å¯æ·»åŠ æƒé™ã€æ—¥å¿—ã€ç¼“å­˜ç­‰é€»è¾‘
2. **å»¶è¿ŸåŠ è½½** â†’ èŠ‚çœå†…å­˜å’Œåˆå§‹åŒ–æ—¶é—´
3. **å®¢æˆ·ç«¯é€æ˜** â†’ æ— éœ€ä¿®æ”¹å®¢æˆ·ç«¯ä»£ç 
4. **èŒè´£åˆ†ç¦»** â†’ ä»£ç†è´Ÿè´£â€œæ§åˆ¶â€, çœŸå®å¯¹è±¡è´Ÿè´£â€œä¸šåŠ¡â€
5. **æ‰©å±•æ€§å¼º** â†’ å¯å åŠ å¤šä¸ªä»£ç†(å¦‚: ç¼“å­˜ä»£ç† + æƒé™ä»£ç†)

 âŒ ç¼ºç‚¹: 

1. **å¢åŠ ç³»ç»Ÿå¤æ‚åº¦** â†’ å¤šä¸€å±‚ä»£ç†ç±»
2. **å¯èƒ½é™ä½æ€§èƒ½** â†’ ä»£ç†å±‚å¢åŠ è°ƒç”¨å¼€é”€(é€šå¸¸å¯å¿½ç•¥)
3. **è°ƒè¯•å›°éš¾** â†’ è°ƒç”¨é“¾å˜é•¿, éœ€è·Ÿè¸ªä»£ç†é€»è¾‘
4. **ç”Ÿå‘½å‘¨æœŸç®¡ç†å¤æ‚** â†’ ä»£ç†å’ŒçœŸå®å¯¹è±¡çš„ææ„é¡ºåºéœ€æ³¨æ„(C++)

------

 âœ… æ³¨æ„äº‹é¡¹

 1. ğŸ”„ ä»£ç† â‰  è£…é¥°å™¨

| æ¨¡å¼   | ç›®çš„                                 |
| ------ | ------------------------------------ |
| ä»£ç†   | **æ§åˆ¶è®¿é—®**(ä½•æ—¶ã€èƒ½å¦ã€å¦‚ä½•è®¿é—®) |
| è£…é¥°å™¨ | **åŠ¨æ€æ·»åŠ åŠŸèƒ½**(å¢å¼ºè¡Œä¸º)         |

> ğŸ’¡ **ä»£ç† = â€œé—¨å«â€, è£…é¥°å™¨ = â€œåŒ…è£…çº¸â€**


```
// ä»£ç†: æ§åˆ¶æ˜¯å¦å…è®¸è®¿é—®
if (user.hasPermission()) realObject->operation();

// è£…é¥°å™¨: å¢å¼ºåŠŸèƒ½
decorated->operation(); // å†…éƒ¨è°ƒç”¨ component->operation() + é¢å¤–é€»è¾‘
```

------

 2. ğŸ”„ ä»£ç† â‰  é€‚é…å™¨

| æ¨¡å¼   | ç›®çš„                   |
| ------ | ---------------------- |
| ä»£ç†   | **ç›¸åŒæ¥å£, æ§åˆ¶è®¿é—®** |
| é€‚é…å™¨ | **è½¬æ¢æ¥å£, å…¼å®¹è°ƒç”¨** |

> ğŸ’¡ ä»£ç†ä¸æ”¹å˜æ¥å£, é€‚é…å™¨æ”¹å˜æ¥å£ã€‚

------

 3. âš ï¸ ä»£ç†åº”æŒæœ‰çœŸå®å¯¹è±¡çš„**æ™ºèƒ½æŒ‡é’ˆæˆ–å¼•ç”¨**


```
class ImageProxy : public IImage {
    std::unique_ptr<RealImage> realImage; // æˆ– shared_ptr
public:
    void display() override {
        if (!realImage) {
            realImage = std::make_unique<RealImage>("huge_image.jpg");
        }
        realImage->display();
    }
};
```

> âœ… é¿å…è£¸æŒ‡é’ˆ, é˜²æ­¢å†…å­˜æ³„æ¼
>  âœ… `unique_ptr`: ä»£ç†ç‹¬å æ‰€æœ‰æƒ
>  âœ… `shared_ptr`: å…è®¸å¤šä¸ªä»£ç†å…±äº«çœŸå®å¯¹è±¡

------

 4. âœ… ä»£ç†å¯ç»„åˆ(ä»£ç†é“¾)


```
// æƒé™ä»£ç† â†’ ç¼“å­˜ä»£ç† â†’ çœŸå®å¯¹è±¡
auto service = std::make_shared<RealService>();
auto cached = std::make_shared<CachingProxy>(service);
auto secured = std::make_shared<SecurityProxy>(cached);
```

------

 5. âš ï¸ æ³¨æ„ææ„é¡ºåº(C++)

> è‹¥ä»£ç†æŒæœ‰çœŸå®å¯¹è±¡, ç¡®ä¿ä»£ç†ææ„æ—¶çœŸå®å¯¹è±¡ä»æœ‰æ•ˆ(é€šå¸¸ä»£ç†è´Ÿè´£é”€æ¯)ã€‚

------

 6. âœ… é€‚ç”¨äºâ€œè®¿é—®æ§åˆ¶â€ã€â€œå»¶è¿ŸåŠ è½½â€ã€â€œè¿œç¨‹è°ƒç”¨â€ç­‰åœºæ™¯

> å¦‚æœåªæ˜¯ç®€å•å°è£…, è€ƒè™‘æ˜¯å¦è¿‡åº¦è®¾è®¡ã€‚



 âœ… ä¸€å¥è¯æ€»ç»“: 

> **ä»£ç†æ¨¡å¼ = â€œå¯¹è±¡çš„æ›¿èº«â€, åœ¨ä¸æ”¹å˜æ¥å£çš„å‰æä¸‹, æ§åˆ¶å¯¹çœŸå®å¯¹è±¡çš„è®¿é—®ã€‚**

> **â€œä½ æƒ³æ“ä½œçœŸå®å¯¹è±¡ï¼Ÿå…ˆè¿‡æˆ‘è¿™å…³ï¼â€**

ğŸ¯ **æ¨èè¯­: **

> **ä»£ç†æ¨¡å¼æ˜¯æ„å»ºå®‰å…¨ã€é«˜æ•ˆã€å¯æ‰©å±•ç³»ç»Ÿçš„å…³é”®æ¨¡å¼ã€‚æ— è®ºæ˜¯å»¶è¿ŸåŠ è½½ã€æƒé™æ§åˆ¶è¿˜æ˜¯è¿œç¨‹è°ƒç”¨, ä»£ç†æ¨¡å¼éƒ½èƒ½è®©ä½ åœ¨ä¸ä¾µå…¥ä¸šåŠ¡ä»£ç çš„å‰æä¸‹, ä¼˜é›…åœ°æ·»åŠ æ§åˆ¶é€»è¾‘ï¼**

æŒæ¡ä»£ç†æ¨¡å¼, ä½ å°±æŒæ¡äº†â€œæ§åˆ¶çš„è‰ºæœ¯â€ï¼

## ä»£ç 

è¿œç¨‹æœåŠ¡ä»£ç†(æ¨¡æ‹Ÿ RPC)

```
#include <iostream>
#include <string>
#include <thread>
#include <chrono>

// æŠ½è±¡è¿œç¨‹æœåŠ¡
class IRemoteService {
public:
    virtual ~IRemoteService() = default;
    virtual std::string getData() = 0;
};

// çœŸå®è¿œç¨‹æœåŠ¡(æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ)
class RealRemoteService : public IRemoteService {
public:
    std::string getData() override {
        std::cout << "ğŸŒ Connecting to remote server...\n";
        std::this_thread::sleep_for(std::chrono::seconds(2)); // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
        return "Data from remote server";
    }
};

// è¿œç¨‹ä»£ç†(æœ¬åœ°å­˜æ ¹)
class RemoteProxy : public IRemoteService {
    mutable std::unique_ptr<RealRemoteService> realService;
    mutable std::string cachedData;
    mutable bool isCached = false;

public:
    std::string getData() override {
        if (!realService) {
            realService = std::make_unique<RealRemoteService>();
        }

        if (!isCached) {
            std::cout << "ğŸ“¡ Proxy: Fetching data for the first time...\n";
            cachedData = realService->getData();
            isCached = true;
        } else {
            std::cout << "ğŸ’¾ Proxy: Returning cached data...\n";
        }

        return cachedData;
    }
};

int main() {
    std::cout << "=== ä»£ç†æ¨¡å¼: è¿œç¨‹æœåŠ¡ä»£ç† ===\n\n";

    RemoteProxy proxy;

    // ç¬¬ä¸€æ¬¡è°ƒç”¨: çœŸå®ç½‘ç»œè¯·æ±‚
    std::cout << "First call: " << proxy.getData() << "\n\n";

    // ç¬¬äºŒæ¬¡è°ƒç”¨: è¿”å›ç¼“å­˜
    std::cout << "Second call: " << proxy.getData() << "\n";

    return 0;
}
```

## PlantUML

```
@startuml

' è®¾ç½®ä¸»é¢˜å’Œæ ·å¼(å¯é€‰)
skinparam class {
    BackgroundColor White
    BorderColor #333333
    FontSize 14
}
skinparam interface {
    BackgroundColor LightBlue
    BorderColor #3333CC
    FontStyle italic
}

' å®šä¹‰æŠ½è±¡æ¥å£
interface IRemoteService {
    +getData() : string
}

' å®šä¹‰å…·ä½“å®ç°ç±»
class RealRemoteService {
    +getData() : string
}

' å®šä¹‰ä»£ç†ç±»
class RemoteProxy {
    -realService : unique_ptr<RealRemoteService>
    -cachedData : string
    -isCached : bool
    +getData() : string
}

' ç»§æ‰¿å…³ç³»
RealRemoteService --|> IRemoteService
RemoteProxy --|> IRemoteService

' ä»£ç†ç±»èšåˆçœŸå®æœåŠ¡(ç»„åˆå…³ç³», ç”¨è±å½¢å®çº¿)
RemoteProxy o-- "1" RealRemoteService : creates and holds

' æ·»åŠ æ³¨é‡Šè¯´æ˜
note right of RemoteProxy
  ä»£ç†æ¨¡å¼å®ç°: 
  - é¦–æ¬¡è°ƒç”¨åˆ›å»ºçœŸå®æœåŠ¡
  - ç¼“å­˜ç»“æœä»¥æé«˜åç»­æ€§èƒ½
  - å¯¹å®¢æˆ·ç«¯é€æ˜
end note

note right of RealRemoteService
  çœŸå®è¿œç¨‹æœåŠ¡: 
  - æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
  - å®é™…æ•°æ®æ¥æº
end note

@enduml
```

![](./picture/13.ProxyPattern.png)



# ğŸ”„è¡Œä¸ºå‹æ¨¡å¼

# 16. ç­–ç•¥æ¨¡å¼

## ç®€ä»‹

> **ç­–ç•¥æ¨¡å¼(Strategy Pattern)** æ˜¯ä¸€ç§**è¡Œä¸ºå‹è®¾è®¡æ¨¡å¼**, å®ƒ**å®šä¹‰ä¸€ç³»åˆ—ç®—æ³•æˆ–è¡Œä¸º, å¹¶å°†æ¯ä¸ªç®—æ³•å°è£…èµ·æ¥, ä½¿å®ƒä»¬å¯ä»¥äº’æ¢, è®©ç®—æ³•çš„å˜åŒ–ç‹¬ç«‹äºä½¿ç”¨å®ƒçš„å®¢æˆ·ç«¯**ã€‚

 ğŸ¯ æ ¸å¿ƒæ€æƒ³: 

- **â€œå°è£…å˜åŒ–, äº’æ¢ç®—æ³•â€**
- **å°†ç®—æ³•æŠ½è±¡ä¸ºç­–ç•¥æ¥å£**
- **å®¢æˆ·ç«¯é€šè¿‡ç»„åˆæ–¹å¼ä½¿ç”¨ä¸åŒç­–ç•¥, è€Œéç»§æ‰¿**

> ğŸ’¡ ç»å…¸æ¯”å–»: 
>  **å¯¼èˆªAppä¸­çš„è·¯çº¿ç­–ç•¥** â€”â€” ä½ å¯ä»¥éšæ—¶åˆ‡æ¢â€œæœ€çŸ­è·¯å¾„â€ã€â€œæœ€å°‘æ”¶è´¹â€ã€â€œé¿å¼€é«˜é€Ÿâ€, è€ŒAppæœ¬èº«ç»“æ„ä¸å˜ã€‚

------

 ğŸ§© ç»“æ„ç»„æˆ: 

| è§’è‰²                    | è¯´æ˜                                                         |
| ----------------------- | ------------------------------------------------------------ |
| `Strategy`              | æŠ½è±¡ç­–ç•¥æ¥å£(å¦‚ `ISortStrategy`, `IPaymentStrategy`)       |
| `ConcreteStrategyA/B/C` | å…·ä½“ç­–ç•¥ç±»(å¦‚ `QuickSort`, `CreditCardPayment`), å®ç°ä¸åŒç®—æ³• |
| `Context`               | ä¸Šä¸‹æ–‡ç±», æŒæœ‰ç­–ç•¥å¯¹è±¡å¼•ç”¨, æä¾›è°ƒç”¨æ¥å£(å¦‚ `Sorter`, `PaymentProcessor`) |
| `Client`                | å®¢æˆ·ç«¯, é€‰æ‹©å¹¶è®¾ç½®å…·ä½“ç­–ç•¥, è§¦å‘è¡Œä¸º                         |

> ğŸ“Œ **å…³é”®ç‚¹: **
>
> - ç­–ç•¥æ¨¡å¼ä½¿ç”¨**ç»„åˆè€Œéç»§æ‰¿**å®ç°ç®—æ³•åˆ‡æ¢
> - å®¢æˆ·ç«¯å†³å®šä½¿ç”¨å“ªä¸ªç­–ç•¥
> - ç­–ç•¥å¯¹è±¡å¯åŠ¨æ€æ›¿æ¢

------

 âœ… é€‚ç”¨åœºæ™¯

1. **å¤šç§ç®—æ³•/è¡Œä¸ºå¯äº’æ¢**(å¦‚æ’åºã€æ”¯ä»˜ã€å‹ç¼©ã€åŠ å¯†)
2. **é¿å…å¤§é‡æ¡ä»¶è¯­å¥(if-else / switch)**
3. **éœ€è¦è¿è¡Œæ—¶åŠ¨æ€åˆ‡æ¢ç®—æ³•**
4. **ç®—æ³•éœ€ç‹¬ç«‹äºä½¿ç”¨å®ƒçš„ç±»**
5. **ä¸åŒç”¨æˆ·/åœºæ™¯éœ€è¦ä¸åŒè¡Œä¸º**

ğŸ“Œ **å…¸å‹åº”ç”¨åœºæ™¯: **

- ğŸ§® **æ’åºç®—æ³•åˆ‡æ¢**: å¿«é€Ÿæ’åºã€å½’å¹¶æ’åºã€å†’æ³¡æ’åº
- ğŸ’³ **æ”¯ä»˜æ–¹å¼**: ä¿¡ç”¨å¡ã€æ”¯ä»˜å®ã€å¾®ä¿¡ã€PayPal
- ğŸ® **æ¸¸æˆè§’è‰²AIè¡Œä¸º**: æ”»å‡»ã€é€ƒè·‘ã€å·¡é€»
- ğŸ§­ **å¯¼èˆªè·¯å¾„è§„åˆ’**: æœ€çŸ­æ—¶é—´ã€æœ€å°‘æ”¶è´¹ã€é¿å¼€é«˜é€Ÿ
- ğŸ“¦ **æ•°æ®å‹ç¼©ç®—æ³•**: ZIPã€GZIPã€LZ4
- ğŸ” **åŠ å¯†ç®—æ³•**: AESã€RSAã€DES

------

 âœ… ä¼˜ç¼ºç‚¹

 âœ… ä¼˜ç‚¹: 

1. **ç®—æ³•å¯è‡ªç”±åˆ‡æ¢** â†’ è¿è¡Œæ—¶åŠ¨æ€æ›´æ¢ç­–ç•¥
2. **é¿å…æ¡ä»¶è¯­å¥** â†’ ä»£ç æ›´æ¸…æ™°ã€æ˜“ç»´æŠ¤
3. **æ‰©å±•æ€§å¼º** â†’ æ–°å¢ç­–ç•¥æ— éœ€ä¿®æ”¹ä¸Šä¸‹æ–‡æˆ–å®¢æˆ·ç«¯
4. **ç¬¦åˆå¼€é—­åŸåˆ™** â†’ å¯¹æ‰©å±•å¼€æ”¾, å¯¹ä¿®æ”¹å…³é—­
5. **èŒè´£åˆ†ç¦»** â†’ ç­–ç•¥ä¸“æ³¨ç®—æ³•, ä¸Šä¸‹æ–‡ä¸“æ³¨åè°ƒ

 âŒ ç¼ºç‚¹: 

1. **å¢åŠ ç±»æ•°é‡** â†’ æ¯ä¸ªç­–ç•¥ä¸€ä¸ªç±»
2. **å®¢æˆ·ç«¯éœ€äº†è§£ç­–ç•¥å·®å¼‚** â†’ éœ€çŸ¥é“é€‰å“ªä¸ªç­–ç•¥åˆé€‚
3. **ç­–ç•¥é—´åˆ‡æ¢å¯èƒ½æœ‰çŠ¶æ€ä¸¢å¤±é£é™©**(è‹¥ç­–ç•¥æœ‰å†…éƒ¨çŠ¶æ€)
4. **è¿‡åº¦è®¾è®¡é£é™©** â†’ ç®€å•åœºæ™¯ç”¨ if-else æ›´ç›´æ¥

------

 âœ… æ³¨æ„äº‹é¡¹

 1. ğŸ”„ ç­–ç•¥æ¨¡å¼ â‰  çŠ¶æ€æ¨¡å¼

| æ¨¡å¼     | ç›®çš„                     | åˆ‡æ¢æ§åˆ¶è€…     |
| -------- | ------------------------ | -------------- |
| ç­–ç•¥æ¨¡å¼ | **å®¢æˆ·ç«¯å†³å®šåˆ‡æ¢ç®—æ³•**   | å®¢æˆ·ç«¯ä¸»åŠ¨è®¾ç½® |
| çŠ¶æ€æ¨¡å¼ | **å¯¹è±¡å†…éƒ¨çŠ¶æ€é©±åŠ¨è¡Œä¸º** | å¯¹è±¡è‡ªèº«åˆ‡æ¢   |

> ğŸ’¡ **ç­–ç•¥ = â€œæˆ‘é€‰å“ªä¸ªç®—æ³•â€, çŠ¶æ€ = â€œæˆ‘ç°åœ¨æ˜¯ä»€ä¹ˆçŠ¶æ€, è¯¥åšä»€ä¹ˆâ€**


```
// ç­–ç•¥: å®¢æˆ·ç«¯è®¾ç½®
context.setStrategy(new QuickSort());

// çŠ¶æ€: å¯¹è±¡æ ¹æ®å†…éƒ¨çŠ¶æ€è‡ªåŠ¨åˆ‡æ¢
state.handle(); // å†…éƒ¨å¯èƒ½åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªçŠ¶æ€
```

------

 2. âš ï¸ ç­–ç•¥å¯¹è±¡åº”å°½é‡**æ— çŠ¶æ€(Stateless)**

> æœ‰çŠ¶æ€ç­–ç•¥åœ¨åˆ‡æ¢æ—¶å¯èƒ½ä¸¢å¤±æ•°æ®, å¢åŠ å¤æ‚åº¦ã€‚


```
// âœ… æ— çŠ¶æ€ç­–ç•¥(æ¨è)
class QuickSort : public ISortStrategy {
public:
    void sort(std::vector<int>& data) override {
        // ä¸ä¿å­˜ä»»ä½•æˆå‘˜å˜é‡
        std::sort(data.begin(), data.end()); // ç®€åŒ–ç¤ºä¾‹
    }
};

// âŒ æœ‰çŠ¶æ€ç­–ç•¥(è°¨æ…ä½¿ç”¨)
class CountingSort : public ISortStrategy {
    int maxVal; // å†…éƒ¨çŠ¶æ€
public:
    void sort(std::vector<int>& data) override { ... }
};
```

------

 3. âœ… ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆç®¡ç†ç­–ç•¥å¯¹è±¡(C++)


```
class Sorter {
    std::unique_ptr<ISortStrategy> strategy;
public:
    void setStrategy(std::unique_ptr<ISortStrategy> s) {
        strategy = std::move(s);
    }
    void execute(std::vector<int>& data) {
        if (strategy) strategy->sort(data);
    }
};
```

> âœ… `unique_ptr`: ç‹¬å æ‰€æœ‰æƒ, ç­–ç•¥ç”±ä¸Šä¸‹æ–‡ç®¡ç†
>  âœ… `shared_ptr`: å¤šä¸ªä¸Šä¸‹æ–‡å…±äº«åŒä¸€ç­–ç•¥

------

 4. âœ… ç­–ç•¥å¯é…ç½®åŒ–(å·¥å‚ + é…ç½®æ–‡ä»¶)


```
std::unique_ptr<ISortStrategy> createStrategy(const std::string& type) {
    if (type == "quick") return std::make_unique<QuickSort>();
    if (type == "merge") return std::make_unique<MergeSort>();
    throw std::invalid_argument("Unknown strategy");
}
```

------

 5. âœ… é€‚ç”¨äºâ€œç®—æ³•æ—â€ã€â€œè¡Œä¸ºæ—â€åœºæ™¯

> å¦‚æœç®—æ³•å·®å¼‚å¤§ã€ä½¿ç”¨é¢‘ç¹ã€éœ€åŠ¨æ€åˆ‡æ¢, ç­–ç•¥æ¨¡å¼æ˜¯é¦–é€‰ã€‚

------

 6. âš ï¸ é¿å…ç­–ç•¥â€œä¸Šå¸ç±»â€

> æ¯ä¸ªç­–ç•¥åº”èŒè´£å•ä¸€, é¿å…ä¸€ä¸ªç­–ç•¥åšå¤ªå¤šäº‹ã€‚

ğŸ¯ **æ¨èè¯­: **

> **ç­–ç•¥æ¨¡å¼æ˜¯æ¶ˆé™¤æ¡ä»¶è¯­å¥ã€å®ç°ç®—æ³•è‡ªç”±åˆ‡æ¢çš„åˆ©å™¨ã€‚æ— è®ºæ˜¯æ’åºã€æ”¯ä»˜ã€AIè¡Œä¸º, åªè¦ä½ æƒ³â€œæ¢ç®—æ³•å¦‚æ¢è¡£æœâ€, ç­–ç•¥æ¨¡å¼å°±æ˜¯ä½ çš„æœ€ä½³é€‰æ‹©ï¼**

æŒæ¡ç­–ç•¥æ¨¡å¼, ä½ å°±æŒæ¡äº†â€œç®—æ³•è‡ªç”±çš„è‰ºæœ¯â€ï¼


## ä»£ç 

```
// Strategy.h
#include <iostream>
#include <vector>
#include <memory>
#include <algorithm>

// ============ æŠ½è±¡ç­–ç•¥ ============
class ISortStrategy {
public:
    virtual ~ISortStrategy() = default;
    virtual void sort(std::vector<int>& data) = 0;
    virtual std::string getName() const = 0;
};

// ============ å…·ä½“ç­–ç•¥ ============
class QuickSort : public ISortStrategy {
public:
    void sort(std::vector<int>& data) override {
        std::sort(data.begin(), data.end()); // ç®€åŒ–, å®é™…åº”å®ç°å¿«æ’
    }
    std::string getName() const override { return "QuickSort"; }
};

class BubbleSort : public ISortStrategy {
public:
    void sort(std::vector<int>& data) override {
        for (size_t i = 0; i < data.size(); ++i) {
            for (size_t j = 0; j < data.size() - i - 1; ++j) {
                if (data[j] > data[j + 1]) {
                    std::swap(data[j], data[j + 1]);
                }
            }
        }
    }
    std::string getName() const override { return "BubbleSort"; }
};

class MergeSort : public ISortStrategy {
public:
    void sort(std::vector<int>& data) override {
        if (data.size() <= 1) return;
        std::vector<int> temp(data.size());
        mergeSortImpl(data, temp, 0, data.size() - 1);
    }

private:
    void mergeSortImpl(std::vector<int>& data, std::vector<int>& temp, int left, int right) {
        if (left >= right) return;
        int mid = left + (right - left) / 2;
        mergeSortImpl(data, temp, left, mid);
        mergeSortImpl(data, temp, mid + 1, right);
        merge(data, temp, left, mid, right);
    }

    void merge(std::vector<int>& data, std::vector<int>& temp, int left, int mid, int right) {
        for (int i = left; i <= right; ++i) temp[i] = data[i];
        int i = left, j = mid + 1, k = left;
        while (i <= mid && j <= right) {
            if (temp[i] <= temp[j]) data[k++] = temp[i++];
            else data[k++] = temp[j++];
        }
        while (i <= mid) data[k++] = temp[i++];
        while (j <= right) data[k++] = temp[j++];
    }

public:
    std::string getName() const override { return "MergeSort"; }
};

// ============ ä¸Šä¸‹æ–‡ ============
class Sorter {
    std::unique_ptr<ISortStrategy> strategy;

public:
    void setStrategy(std::unique_ptr<ISortStrategy> s) {
        strategy = std::move(s);
        std::cout << "ğŸ”„ Strategy set to: " << strategy->getName() << "\n";
    }

    void execute(std::vector<int>& data) {
        if (!strategy) {
            std::cout << "âŒ No strategy set!\n";
            return;
        }
        std::cout << "â–¶ï¸ Executing " << strategy->getName() << "...\n";
        strategy->sort(data);
    }
};

// ============ å·¥å…·å‡½æ•° ============
void printVector(const std::vector<int>& v, const std::string& title) {
    std::cout << title << ": ";
    for (int x : v) std::cout << x << " ";
    std::cout << "\n";
}

// ============ å®¢æˆ·ç«¯ ============
#include "Strategy.h"

int main() {
    std::cout << "=== ç­–ç•¥æ¨¡å¼: æ’åºç®—æ³•åˆ‡æ¢ ===\n\n";

    Sorter sorter;
    std::vector<int> data = {64, 34, 25, 12, 22, 11, 90};

    printVector(data, "Original data");

    // ä½¿ç”¨å†’æ³¡æ’åº
    sorter.setStrategy(std::make_unique<BubbleSort>());
    sorter.execute(data);
    printVector(data, "After BubbleSort");

    // é‡ç½®æ•°æ®
    data = {64, 34, 25, 12, 22, 11, 90};

    // ä½¿ç”¨å¿«é€Ÿæ’åº
    sorter.setStrategy(std::make_unique<QuickSort>());
    sorter.execute(data);
    printVector(data, "After QuickSort");

    // é‡ç½®æ•°æ®
    data = {64, 34, 25, 12, 22, 11, 90};

    // ä½¿ç”¨å½’å¹¶æ’åº
    sorter.setStrategy(std::make_unique<MergeSort>());
    sorter.execute(data);
    printVector(data, "After MergeSort");

    return 0;
}
```



## PlantUML

```
@startuml

' æŠ½è±¡ç­–ç•¥
interface Strategy {
    +algorithmInterface()
}

' å…·ä½“ç­–ç•¥
class ConcreteStrategyA {
    +algorithmInterface()
}

class ConcreteStrategyB {
    +algorithmInterface()
}

class ConcreteStrategyC {
    +algorithmInterface()
}

' ä¸Šä¸‹æ–‡
class Context {
    -strategy: Strategy
    +setStrategy(strategy: Strategy)
    +contextInterface()
}

' å®¢æˆ·ç«¯
class Client {
    +main()
}

' å…³ç³»
Strategy <|-- ConcreteStrategyA
Strategy <|-- ConcreteStrategyB
Strategy <|-- ConcreteStrategyC
Context --> Strategy : uses
Client --> Context : configures
Client --> Strategy : creates

note right of Strategy
    Declares interface
    common to all supported
    algorithms.
end note

note right of ConcreteStrategyA
    Implements the algorithm
    using the Strategy interface.
end note

note bottom of Context
    Maintains a reference to a
    Strategy object and calls
    its algorithmInterface().
end note

note top of Client
    Chooses and sets the
    concrete strategy.
end note

@enduml
```

![](./picture/14.StrategyPattern.png)



# 17. æ¨¡æ¿æ–¹æ³•æ¨¡å¼

## ç®€ä»‹


> C++ æ¨¡æ¿æ–¹æ³•æ¨¡å¼(Template Method Pattern)
> **å®šä¹‰ç®—æ³•éª¨æ¶, å°†æŸäº›æ­¥éª¤å»¶è¿Ÿåˆ°å­ç±»å®ç°ã€‚**
>  â€”â€” çˆ¶ç±»æ§åˆ¶æµç¨‹, å­ç±»å®ç°ç»†èŠ‚ã€‚

------

ğŸ“Œ 1. ä»‹ç»

- **ç±»å‹**: è¡Œä¸ºå‹æ¨¡å¼
- **æ ¸å¿ƒæ€æƒ³**: 
  - åœ¨**æŠ½è±¡åŸºç±»**ä¸­å®šä¹‰ä¸€ä¸ª**æ¨¡æ¿æ–¹æ³•(é€šå¸¸æ˜¯ final æˆ–éè™šå‡½æ•°)**, å®ƒæŒ‰å›ºå®šé¡ºåºè°ƒç”¨å¤šä¸ªæ­¥éª¤ã€‚
  - å…¶ä¸­éƒ¨åˆ†æ­¥éª¤æ˜¯**çº¯è™šå‡½æ•°æˆ–è™šå‡½æ•°**, ç”±å­ç±»å®ç°å…·ä½“è¡Œä¸ºã€‚
  - çˆ¶ç±»æ§åˆ¶â€œä¸å˜çš„æµç¨‹â€, å­ç±»æä¾›â€œå¯å˜çš„å®ç°â€ã€‚
- **å…³é”®è¯**: ç®—æ³•éª¨æ¶ã€ç»§æ‰¿ã€é’©å­æ–¹æ³•ã€å¥½è±ååŸåˆ™(â€œDonâ€™t call us, weâ€™ll call youâ€)

------

ğŸ¯ 2. é€‚ç”¨åœºæ™¯

 âœ” ç®—æ³•ç»“æ„ç¨³å®š, ä½†æŸäº›æ­¥éª¤å®ç°å¯å˜(å¦‚æ³¡èŒ¶/å’–å•¡ã€æ•°æ®å¤„ç†æµç¨‹ã€æ¸¸æˆå…³å¡æµç¨‹)
 âœ” éœ€è¦æ§åˆ¶å­ç±»æ‰©å±•èŒƒå›´, é˜²æ­¢ç ´åç®—æ³•ç»“æ„
 âœ” å¤šä¸ªå­ç±»æœ‰å…¬å…±è¡Œä¸º, å¸Œæœ›é¿å…ä»£ç é‡å¤
 âœ” æ¡†æ¶è®¾è®¡ä¸­, æä¾›æ ‡å‡†æµç¨‹, å…è®¸ç”¨æˆ·è‡ªå®šä¹‰éƒ¨åˆ†æ­¥éª¤

------

âš–ï¸ 3. ä¼˜ç¼ºç‚¹

| ä¼˜ç‚¹                                         | ç¼ºç‚¹                                 |
| -------------------------------------------- | ------------------------------------ |
| âœ… å°è£…ä¸å˜éƒ¨åˆ†, æ‰©å±•å¯å˜éƒ¨åˆ†                 | âŒ ç»§æ‰¿å¯¼è‡´ç±»æ•°é‡è†¨èƒ€                 |
| âœ… æå–å…¬å…±ä»£ç , ä¾¿äºç»´æŠ¤                     | âŒ å­ç±»å½±å“çˆ¶ç±»(è¿åâ€œé‡Œæ°æ›¿æ¢â€é£é™©) |
| âœ… è¡Œä¸ºç”±çˆ¶ç±»æ§åˆ¶, å­ç±»å®ç°ç»†èŠ‚(å¥½è±ååŸåˆ™) | âŒ ä¸é€‚åˆé¢‘ç¹å˜åŒ–çš„ç®—æ³•ç»“æ„           |
| âœ… ç¬¦åˆå¼€é—­åŸåˆ™(æ‰©å±•å­ç±»ä¸æ”¹çˆ¶ç±»)           |                                      |

------

âš ï¸ 4. æ³¨æ„äº‹é¡¹

1. **æ¨¡æ¿æ–¹æ³•å»ºè®®è®¾ä¸º `final`(C++11+)** â†’ é˜²æ­¢å­ç±»é‡å†™éª¨æ¶, ç ´åæµç¨‹ã€‚
2. **æ­¥éª¤æ–¹æ³•å¯è®¾ä¸º `protected`** â†’ ä»…å­ç±»å¯è®¿é—®, å¤–éƒ¨ä¸å¯è°ƒç”¨ã€‚
3. **å¯æä¾›â€œé’©å­æ–¹æ³•(hook)â€** â†’ ç©ºå®ç°è™šå‡½æ•°, å­ç±»å¯é€‰é‡å†™ã€‚
4. **é¿å…åœ¨æ¨¡æ¿æ–¹æ³•ä¸­è°ƒç”¨å¯èƒ½è¢«å­ç±»é‡å†™çš„éfinalè™šå‡½æ•°åˆå§‹åŒ–èµ„æº** â†’ æ„é€ å‡½æ•°ä¸­è°ƒç”¨è™šå‡½æ•°æ˜¯æœªå®šä¹‰è¡Œä¸ºï¼
5. **æ…ç”¨æ·±ç»§æ‰¿** â†’ ä¼˜å…ˆç»„åˆ, ä½†æ¨¡æ¿æ–¹æ³•æ˜¯â€œåˆç†ä½¿ç”¨ç»§æ‰¿â€çš„ç»å…¸åœºæ™¯ã€‚

 ğŸ§  ä¸€å¥è¯æ€»ç»“æ¨¡æ¿æ–¹æ³•: 

> **â€œçˆ¶å®šæµç¨‹, å­å¡«æ­¥éª¤ï¼›é’©å­å¯é€‰, éª¨æ¶ä¸å˜ã€‚â€**

------

âœ… **é€‚ç”¨è¯­è¨€**: C++ã€Javaã€C#ã€Python ç­‰æ”¯æŒç»§æ‰¿å’Œè™šå‡½æ•°çš„è¯­è¨€
âœ… **ç»å…¸åº”ç”¨**: 

- Java `AbstractList`ã€`InputStream`
- C++ æ¡†æ¶ä¸­çš„åˆå§‹åŒ–/å¤„ç†/æ¸…ç†æµç¨‹
- æ¸¸æˆAIè¡Œä¸ºæ ‘ä¸­çš„æ ‡å‡†æ‰§è¡Œæµç¨‹

------

ğŸ“Œ **å­¦ä¹ å»ºè®®**: 

- ä¸**ç­–ç•¥æ¨¡å¼**å¯¹æ¯”: æ¨¡æ¿æ–¹æ³• = **ç»§æ‰¿å®ç°**æµç¨‹å®šåˆ¶ï¼›ç­–ç•¥æ¨¡å¼ = **ç»„åˆå®ç°**ç®—æ³•æ›¿æ¢ã€‚
- ä¸**å·¥å‚æ–¹æ³•**ç»“åˆ: æ¨¡æ¿æ–¹æ³•ä¸­æŸæ­¥å¯è°ƒç”¨å·¥å‚æ–¹æ³•åˆ›å»ºå¯¹è±¡ã€‚

## ä»£ç 

æ³¡é¥®æ–™æµç¨‹

```
#include <iostream>
using namespace std;

// æŠ½è±¡åŸºç±»: å®šä¹‰ç®—æ³•éª¨æ¶
class Beverage {
public:
    // æ¨¡æ¿æ–¹æ³•: å®šä¹‰æµç¨‹, finalé˜²æ­¢è¢«é‡å†™
    void prepareRecipe() final {
        boilWater();
        brew();
        pourInCup();
        if (customerWantsCondiments()) { // é’©å­æ–¹æ³•
            addCondiments();
        }
    }

protected:
    // åŸºæœ¬æ­¥éª¤(éƒ¨åˆ†ç”±å­ç±»å®ç°)
    virtual void brew() = 0;           // çº¯è™š, å¿…é¡»å®ç°
    virtual void addCondiments() = 0;  // çº¯è™š, å¿…é¡»å®ç°

    // å…·ä½“æ­¥éª¤(çˆ¶ç±»å®ç°)
    void boilWater() {
        cout << "Boiling water" << endl;
    }

    void pourInCup() {
        cout << "Pouring into cup" << endl;
    }

    // é’©å­æ–¹æ³•: é»˜è®¤å®ç°, å­ç±»å¯é€‰é‡å†™
    virtual bool customerWantsCondiments() const {
        return true; // é»˜è®¤åŠ è°ƒæ–™
    }
};

// å­ç±»1: æ³¡èŒ¶
class Tea : public Beverage {
protected:
    void brew() override {
        cout << "Steeping the tea" << endl;
    }

    void addCondiments() override {
        cout << "Adding lemon" << endl;
    }
};

// å­ç±»2: å†²å’–å•¡
class Coffee : public Beverage {
protected:
    void brew() override {
        cout << "Dripping coffee through filter" << endl;
    }

    void addCondiments() override {
        cout << "Adding sugar and milk" << endl;
    }

    // é‡å†™é’©å­: è¯¢é—®ç”¨æˆ·æ˜¯å¦è¦è°ƒæ–™
    bool customerWantsCondiments() const override {
        // æ¨¡æ‹Ÿç”¨æˆ·è¾“å…¥
        cout << "Would you like milk and sugar with your coffee (y/n)? ";
        char answer;
        cin >> answer;
        return (answer == 'y' || answer == 'Y');
    }
};

// å®¢æˆ·ç«¯ä½¿ç”¨
int main() {
    cout << "Making tea..." << endl;
    Tea tea;
    tea.prepareRecipe();

    cout << "\nMaking coffee..." << endl;
    Coffee coffee;
    coffee.prepareRecipe();

    return 0;
}
```

## PlantUML

```
@startuml
abstract class Beverage {
    +{final} prepareRecipe() : void
    #boilWater() : void
    #pourInCup() : void
    #{virtual} customerWantsCondiments() : bool
    #{abstract} brew() : void
    #{abstract} addCondiments() : void
}

class Tea {
    #brew() : void
    #addCondiments() : void
}

class Coffee {
    #brew() : void
    #addCondiments() : void
    #customerWantsCondiments() : bool
}

Beverage <|-- Tea
Beverage <|-- Coffee

note right of Beverage
  Template Method Pattern
  prepareRecipe() æ˜¯æ¨¡æ¿æ–¹æ³•
  brew() å’Œ addCondiments() æ˜¯æŠ½è±¡æ­¥éª¤
  customerWantsCondiments() æ˜¯é’©å­æ–¹æ³•
end note

@enduml
```

![](./picture/15.TemplateMethodPattern.png)

# 18. è§‚å¯Ÿè€…æ¨¡å¼

## ç®€ä»‹

> C++ è§‚å¯Ÿè€…æ¨¡å¼(Observer Pattern)
> **å®šä¹‰å¯¹è±¡é—´çš„ä¸€å¯¹å¤šä¾èµ–å…³ç³», å½“ä¸€ä¸ªå¯¹è±¡(ä¸»é¢˜)çŠ¶æ€æ”¹å˜æ—¶, æ‰€æœ‰ä¾èµ–å®ƒçš„å¯¹è±¡(è§‚å¯Ÿè€…)è‡ªåŠ¨æ”¶åˆ°é€šçŸ¥å¹¶æ›´æ–°ã€‚**

------

ğŸ“Œ 1. ä»‹ç»

- **ç±»å‹**: è¡Œä¸ºå‹æ¨¡å¼

- **åˆ«å**: å‘å¸ƒ-è®¢é˜…æ¨¡å¼(Publish-Subscribe, ä½†ä¸¥æ ¼æ¥è¯´æ˜¯å…¶åŒæ­¥ç´§è€¦åˆç‰ˆæœ¬)

- æ ¸å¿ƒè§’è‰²: 
  - `Subject`(ä¸»é¢˜/è¢«è§‚å¯Ÿè€…): ç»´æŠ¤è§‚å¯Ÿè€…åˆ—è¡¨, æä¾›æ³¨å†Œ/ç§»é™¤/é€šçŸ¥æ¥å£ã€‚
  - `Observer`(è§‚å¯Ÿè€…): å®šä¹‰æ›´æ–°æ¥å£, ä¾›ä¸»é¢˜è°ƒç”¨ã€‚

- **é€šä¿¡æ–¹å¼: æ¨æ¨¡å‹(Push) æˆ– æ‹‰æ¨¡å‹(Pull)**
  - æ¨: ä¸»é¢˜ä¸»åŠ¨ä¼ é€’æ•°æ®ç»™è§‚å¯Ÿè€…
  - æ‹‰: è§‚å¯Ÿè€…è‡ªå·±ä»ä¸»é¢˜æ‹‰å–æ•°æ®(ä¸»é¢˜åªå‘â€œæœ‰æ›´æ–°â€ä¿¡å·)

------

ğŸ¯ 2. é€‚ç”¨åœºæ™¯

 âœ” å¯¹è±¡çŠ¶æ€å˜åŒ–éœ€é€šçŸ¥å¤šä¸ªå¯¹è±¡(å¦‚GUIæ§ä»¶ã€æ•°æ®ç»‘å®š)
 âœ” è§£è€¦â€œæ•°æ®å±‚â€ä¸â€œè§†å›¾å±‚â€(MVCä¸­çš„æ ¸å¿ƒæœºåˆ¶)
 âœ” äº‹ä»¶ç³»ç»Ÿã€æ¶ˆæ¯é€šçŸ¥ã€æ—¥å¿—ç›‘å¬ã€è‚¡ç¥¨è¡Œæƒ…æ¨é€
 âœ” é¿å…å¯¹è±¡é—´ç›´æ¥å¼•ç”¨, é™ä½è€¦åˆ

------

âš–ï¸ 3. ä¼˜ç¼ºç‚¹

| ä¼˜ç‚¹                               | ç¼ºç‚¹                                   |
| ---------------------------------- | -------------------------------------- |
| âœ… å»ºç«‹åŠ¨æ€ã€æ¾è€¦åˆçš„ä¸€å¯¹å¤šå…³ç³»     | âŒ é€šçŸ¥é¡ºåºä¸ç¡®å®š(é™¤éæ˜¾å¼æ§åˆ¶)       |
| âœ… æ”¯æŒå¹¿æ’­é€šä¿¡, è‡ªåŠ¨é€šçŸ¥æ‰€æœ‰è§‚å¯Ÿè€… | âŒ å¯èƒ½å¯¼è‡´â€œå†…å­˜æ³„æ¼â€(è§‚å¯Ÿè€…æœªæ³¨é”€)   |
| âœ… ç¬¦åˆå¼€é—­åŸåˆ™(å¯è‡ªç”±å¢åˆ è§‚å¯Ÿè€…) | âŒ è¿‡åº¦ä½¿ç”¨ä¼šå¯¼è‡´ç³»ç»Ÿå¤æ‚ã€éš¾ä»¥è¿½è¸ªä¾èµ– |
| âœ… æ˜“äºæ‰©å±•æ–°è§‚å¯Ÿè€…                 | âŒ åŒæ­¥é€šçŸ¥å¯èƒ½é˜»å¡ä¸»é¢˜(å¯ç”¨å¼‚æ­¥ä¼˜åŒ–) |

------

âš ï¸ 4. æ³¨æ„äº‹é¡¹

1. **è§‚å¯Ÿè€…éœ€åœ¨é”€æ¯å‰ä»ä¸»é¢˜ä¸­æ³¨é”€** â†’ å¦åˆ™ä¸»é¢˜é€šçŸ¥å·²é”€æ¯å¯¹è±¡ â†’ æœªå®šä¹‰è¡Œä¸º(å´©æºƒ)ã€‚

2. **è€ƒè™‘çº¿ç¨‹å®‰å…¨** â†’ å¤šçº¿ç¨‹ç¯å¢ƒä¸‹, æ³¨å†Œ/æ³¨é”€/é€šçŸ¥éœ€åŠ é”ã€‚

3. **é¿å…åœ¨é€šçŸ¥è¿‡ç¨‹ä¸­ä¿®æ”¹è§‚å¯Ÿè€…åˆ—è¡¨** â†’ å¯èƒ½å¯¼è‡´è¿­ä»£å™¨å¤±æ•ˆ â†’ å»ºè®®å¤åˆ¶åˆ—è¡¨æˆ–å»¶è¿Ÿåˆ é™¤ã€‚

4. æ¨ vs æ‹‰æ¨¡å‹é€‰æ‹©: 

   - æ¨: æ•ˆç‡é«˜, ä½†è€¦åˆæ•°æ®ç»“æ„
   - æ‹‰: æ›´çµæ´», ä½†è§‚å¯Ÿè€…éœ€æŒæœ‰ä¸»é¢˜å¼•ç”¨
   
5. **å¯é€‰: ä½¿ç”¨ `std::function` + `std::vector` æ›¿ä»£ç»§æ‰¿æ¥å£** â†’ æ›´è½»é‡, é€‚åˆç®€å•åœºæ™¯(è§ç¤ºä¾‹äºŒ)ã€‚

ğŸ§  ä¸€å¥è¯æ€»ç»“è§‚å¯Ÿè€…æ¨¡å¼: 

> **â€œæˆ‘å˜ä½ çŸ¥, è‡ªåŠ¨é€šçŸ¥ï¼›ä¸€å¯¹å¤šè”, è§£è€¦åˆ©å™¨ã€‚â€**

------

âœ… **ç»å…¸åº”ç”¨**: 

- GUIäº‹ä»¶ç›‘å¬(æŒ‰é’®ç‚¹å‡»ã€çª—å£å…³é—­)
- MVCæ¶æ„ä¸­çš„ Model â†’ View é€šçŸ¥
- æ¸¸æˆæˆå°±ç³»ç»Ÿã€æ—¥å¿—ç³»ç»Ÿã€è‚¡ç¥¨è¡Œæƒ…æ¨é€
- Qt çš„ `Signal/Slot`ã€.NET çš„ `Event`ã€Java çš„ `PropertyChangeListener`

------

ğŸ“Œ **å­¦ä¹ å»ºè®®**: 

- ä¸**å‘å¸ƒ-è®¢é˜…æ¨¡å¼**å¯¹æ¯”: è§‚å¯Ÿè€…æ˜¯åŒæ­¥ã€ç´§è€¦åˆï¼›å‘å¸ƒè®¢é˜…é€šè¿‡æ¶ˆæ¯é˜Ÿåˆ—å¼‚æ­¥è§£è€¦ã€‚
- ä¸**ä¸­ä»‹è€…æ¨¡å¼**å¯¹æ¯”: è§‚å¯Ÿè€…æ˜¯â€œå¹¿æ’­â€, ä¸­ä»‹è€…æ˜¯â€œè°ƒåº¦ä¸­å¿ƒâ€ã€‚

## ä»£ç 

âœ… ç¤ºä¾‹ä¸€: ä¼ ç»Ÿæ¥å£ç»§æ‰¿æ–¹å¼(ç»å…¸GoFé£æ ¼)

```
#include <iostream>
#include <vector>
#include <algorithm>
#include <memory>

// æŠ½è±¡è§‚å¯Ÿè€…æ¥å£
class Observer {
public:
    virtual ~Observer() = default;
    virtual void update(float temperature, float humidity, float pressure) = 0;
};

// æŠ½è±¡ä¸»é¢˜æ¥å£
class Subject {
public:
    virtual ~Subject() = default;
    virtual void registerObserver(std::shared_ptr<Observer> o) = 0;
    virtual void removeObserver(std::shared_ptr<Observer> o) = 0;
    virtual void notifyObservers() = 0;
};

// å…·ä½“ä¸»é¢˜: æ°”è±¡ç«™
class WeatherData : public Subject {
    std::vector<std::weak_ptr<Observer>> observers; // ä½¿ç”¨ weak_ptr é¿å…å¾ªç¯å¼•ç”¨
    float temperature = 0.0f;
    float humidity = 0.0f;
    float pressure = 0.0f;

public:
    void registerObserver(std::shared_ptr<Observer> o) override {
        observers.push_back(o);
    }

    void removeObserver(std::shared_ptr<Observer> o) override {
        observers.erase(
            std::remove_if(observers.begin(), observers.end(),
                [&o](const std::weak_ptr<Observer>& w) {
                    auto p = w.lock();
                    return !p || p == o;
                }),
            observers.end()
        );
    }

    void notifyObservers() override {
        // å¤åˆ¶åˆ°ä¸´æ—¶vector, é¿å…è¿­ä»£ä¸­ä¿®æ”¹
        std::vector<std::shared_ptr<Observer>> validObservers;
        for (auto& w : observers) {
            if (auto obs = w.lock()) {
                validObservers.push_back(obs);
            }
        }
        for (auto& obs : validObservers) {
            obs->update(temperature, humidity, pressure);
        }
    }

    // æ¨¡æ‹Ÿä¼ æ„Ÿå™¨æ•°æ®æ›´æ–°
    void setMeasurements(float temp, float hum, float pres) {
        temperature = temp;
        humidity = hum;
        pressure = pres;
        notifyObservers();
    }
};

// å…·ä½“è§‚å¯Ÿè€…1: å½“å‰çŠ¶å†µæ˜¾ç¤º
class CurrentConditionsDisplay : public Observer {
    float temperature = 0.0f;
    float humidity = 0.0f;
    std::weak_ptr<Subject> weatherData; // å¯é€‰: ç”¨äºæ‹‰æ¨¡å‹

public:
    CurrentConditionsDisplay(std::shared_ptr<Subject> wd) : weatherData(wd) {}

    void update(float temp, float hum, float pres) override {
        temperature = temp;
        humidity = hum;
        display();
    }

    void display() {
        std::cout << "Current conditions: " << temperature
                  << "F degrees and " << humidity << "% humidity\n";
    }
};

// å…·ä½“è§‚å¯Ÿè€…2: ç»Ÿè®¡æ˜¾ç¤º
class StatisticsDisplay : public Observer {
    float maxTemp = 0.0f;
    float minTemp = 200.0f;
    float tempSum = 0.0f;
    int numReadings = 0;

public:
    void update(float temp, float hum, float pres) override {
        tempSum += temp;
        numReadings++;
        if (temp > maxTemp) maxTemp = temp;
        if (temp < minTemp) minTemp = temp;
        display();
    }

    void display() {
        std::cout << "Avg/Max/Min temperature = "
                  << (tempSum / numReadings) << "/" << maxTemp << "/" << minTemp << "\n";
    }
};

// å®¢æˆ·ç«¯ä½¿ç”¨
int main() {
    auto weatherData = std::make_shared<WeatherData>();

    auto currentDisplay = std::make_shared<CurrentConditionsDisplay>(weatherData);
    auto statsDisplay = std::make_shared<StatisticsDisplay>();

    weatherData->registerObserver(currentDisplay);
    weatherData->registerObserver(statsDisplay);

    weatherData->setMeasurements(80, 65, 30.4f);
    weatherData->setMeasurements(82, 70, 29.2f);
    weatherData->setMeasurements(78, 90, 29.2f);

    // è‡ªåŠ¨æ¸…ç†: shared_ptr + weak_ptr ç®¡ç†ç”Ÿå‘½å‘¨æœŸ
    return 0;
}
```

âœ… ç¤ºä¾‹äºŒ: ç°ä»£C++å‡½æ•°å¼é£æ ¼(std::function + lambda)

```
#include <iostream>
#include <vector>
#include <functional>

class WeatherStation {
    std::vector<std::function<void(float, float, float)>> observers;

public:
    void subscribe(std::function<void(float, float, float)> f) {
        observers.push_back(f);
    }

    void unsubscribe(const std::function<void(float, float, float)>& f) {
        observers.erase(
            std::remove(observers.begin(), observers.end(), f),
            observers.end()
        );
    }

    void setMeasurements(float temp, float hum, float pres) {
        for (const auto& f : observers) {
            f(temp, hum, pres);
        }
    }
};

int main() {
    WeatherStation station;

    auto display1 = [](float t, float h, float p) {
        std::cout << "[Display1] Temp: " << t << ", Hum: " << h << "\n";
    };

    auto display2 = [](float t, float h, float p) {
        std::cout << "[Display2] Got update!\n";
    };

    station.subscribe(display1);
    station.subscribe(display2);

    station.setMeasurements(25.5f, 60.0f, 1013.25f);

    return 0;
}
```

## PlantUML

```
@startuml
title Observer Pattern - Classic GoF

interface Subject {
    +registerObserver(o: Observer)
    +removeObserver(o: Observer)
    +notifyObservers()
}

interface Observer {
    +update(temperature: float, humidity: float, pressure: float)
}

class WeatherData {
    -observers: List<Observer>
    -temperature: float
    -humidity: float
    -pressure: float
    +setMeasurements(t,h,p)
}

class CurrentConditionsDisplay {
    -temperature: float
    -humidity: float
    +display()
}

class StatisticsDisplay {
    -maxTemp: float
    -minTemp: float
    -tempSum: float
    -numReadings: int
    +display()
}

Subject <|.. WeatherData
Observer <|.. CurrentConditionsDisplay
Observer <|.. StatisticsDisplay

WeatherData "1" *-- "0..*" Observer : observes >

note right of Subject
  ç»´æŠ¤è§‚å¯Ÿè€…åˆ—è¡¨
  æä¾›æ³¨å†Œ/ç§»é™¤/é€šçŸ¥æ¥å£
end note

note right of Observer
  å®šä¹‰æ›´æ–°æ¥å£
  ç”±å…·ä½“è§‚å¯Ÿè€…å®ç°
end note

@enduml
```

![](./picture/16.ObserverPattern.png)



