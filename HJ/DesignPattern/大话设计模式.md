[TOC]


---

# 1. 23GOF总览

| 分类                   | 作用                             | 数量 | 记忆口诀                           |
| ---------------------- | -------------------------------- | ---- | ---------------------------------- |
| **创建型(Creational)** | 隐藏对象创建细节, 解耦实例化过程 | 5    | 工 单 建 抽 原                     |
| **结构型(Structural)** | 组合类或对象, 形成更大结构       | 7    | 适 桥 组 享 代, 装 外 补结构       |
| **行为型(Behavioral)** | 分配职责, 管理对象间通信         | 11   | 策模观命状, 责链备访中,解迭全收齐 |

> 🎯 **终极口诀(推荐背诵): **
> **创五 结七 行十一, SOLID是根基;
> 工 单 建 抽 原,适 桥 组 享 代;
> 装 外 补结构,策 模 观 命 状;
> 责链 备 访 中,解 迭 全收齐**

---

## 🛠️ 创建型模式(5种)

| 模式         | 简介                             | 特点                                             | 高频重点 |
| ------------ | -------------------------------- | ------------------------------------------------ | -------- |
| **工厂方法** | 定义创建接口, 子类决定实例化     | **单一产品线**; “延迟到子类的 new”               | ✅        |
| **抽象工厂** | 创建相关产品族, 无需指定具体类   | **多产品族**; “工厂的工厂”, 难扩新产品, 易扩新族 | ✅        |
| **单例**     | 全局唯一实例, 提供全局访问点     | **唯一**; 控制资源(如配置、连接池);              | ✅        |
| **建造者**   | 分步构造复杂对象, 分离构造与表示 | **装配线**; 强调过程(如SQL构造器);               | ✅        |
| **原型**     | 通过克隆创建对象                 | **复制**; 避免构造开销;                          |          |

> 💡 **记忆口诀**:   
> **工延子类造单品,
> 单控全局唯一个,
> 建分步骤如装配,
> 抽造一族扩族易,
> 原靠克隆省开销**

---

## 🔌 结构型模式(7种)

| 模式       | 简介                                          | 类比记忆              | 高频重点 |
| ---------- | --------------------------------------------- | --------------------- | -------- |
| **适配器** | 转换接口, 兼容不匹配类                        | **转接头/转换接口**   | ✅        |
| **桥接**   | 抽象与实现分离, 独立变化                      | **遥控器+电视**       |          |
| **组合**   | 树形结构统一处理部分-整体                     | **文件系统/菜单树**   |          |
| **装饰器** | 动态添加功能, 替代继承                        | **层层包装,功能增强** | ✅        |
| **外观**   | 封装子系统, 提供统一入口                      | **一键开机/前台接待** |          |
| **享元**   | 共享对象, 节省内存;关注复用,分离内部/外部状态 | **字符池/子弹池**;    |          |
| **代理**   | 控制对象访问                                  | **经纪人/代理**       | ✅        |

| 对比记忆   | 都包装对象, 但目的不同                | 类比                 |
| ---------- | ------------------------------------- | -------------------- |
| **适配器** | **转换接口**(旧系统兼容)            | “电源插头转换器”     |
| **装饰器** | **增强功能**(动态加料)              | “给蛋糕加奶油和水果” |
| **代理**   | **控制访问**(权限、延迟、日志)      | “经纪人替明星谈合同” |
| 2          |                                       |                      |
| **装饰器** | 包装增强 → 透明接口, 层层叠加         | 装饰器像“穿衣服”     |
| **组合**   | 树形结构 → 部分-整体递归处理          | 组合像“组织结构图”   |
| 3          |                                       |                      |
| **外观**   | 封装子系统 → 简化调用(客户端视角)   | “一键开机按钮”       |
| **中介者** | 封装对象交互 → 降低耦合(对象间通信) | “机场塔台协调飞机”   |

> 💡 **记忆口诀**: 
> 适转接口 旧兼容
> 桥分抽象 与实现
> 组树统一 部与整
> 享池复用 省内存
> 代控访问 如经纪
> 装叠功能 动态加
> 外封子系 一键启**

---

## 🔄 行为型模式(11种)

| 模式         | 简介                       | 特点(含对比 & 类比)                        | 高频重点 |
| ------------ | -------------------------- | ------------------------------------------ | -------- |
| **策略**     | 封装可互换算法             | “导航路线切换”                             | ✅        |
| **模板方法** | 定义算法骨架, 子类实现步骤 | “泡茶流程”;                                | ✅        |
| **观察者**   | 一对多依赖, 状态变更通知   | “订阅号推送”                               | ✅        |
| **责任链**   | 请求沿链传递处理           | “审批流程/异常处理”                        |          |
| **命令**     | 封装请求为对象, 支持撤销   | “遥控器按钮”                               | ✅        |
| **解释器**   | 定义文法并解释表达式       | “简单语言解析器”; 使用较少                 |          |
| **迭代器**   | 遍历聚合对象, 隐藏内部结构 | “通用遍历器”;                              |          |
| **中介者**   | 集中管理对象交互           | “聊天室服务器”                             |          |
| **备忘录**   | 保存/恢复对象状态          | “游戏存档”                                 |          |
| **状态**     | 状态驱动行为自动切换       | “售货机状态”                               | ✅        |
| **访问者**   | 分离操作与对象结构         | “数据结构+多种操作”; 适合稳定结构+多变操作 |          |

| 模式          | 说明                                       | 类比                                      |
| ------------- | ------------------------------------------ | ----------------------------------------- |
| **策略**      | 客户端主动切换 → “我选哪个算法”            | 选择驾驶/骑行/步行                        |
| **状态**      | 对象自动切换 → “我是什么状态, 该做什么”    | 手机充电中/满电/关机自动行为不同          |
| 2             |                                            |                                           |
| **命令**      | 封装“请求” → 支持撤销、排队(动词)        | 遥控器按钮(开/关/音量)                   |
| **策略**      | 封装“算法” → 支持替换(方法)              | 导航路线A/B/C                             |
| 3             |                                            |                                           |
| **模板方法**  | 父类定流程, 子类填步骤 → **继承**          | 父类定义泡茶流程, 子类实现加糖或不加      |
| **策略**      | 注入不同实现 → **组合**                    | 注入 SweetTeaStrategy 或 PlainTeaStrategy |
| 4             |                                            |                                           |
| **观察者**    | 目标直接通知观察者 → 同步、紧耦合          |                                           |
| **发布-订阅** | 过消息队列解耦 → 异步、松耦合(非GoF模式) | GoF只有“观察者”, 发布订阅是其分布式演进   |
| 5             |                                            |                                           |
| **备忘录**    | 保存状态快照 → 恢复(内存消耗大)          | “游戏存档”                                |
| **命令**      | 记录操作+反向操作 → 撤销(轻量)           | “Ctrl+Z”                                  |
| 6             |                                            |                                           |
| **中介者**    | 星型结构, 集中调度 → 降低N对N耦合          | “机场塔台”                                |
| **观察者**    | 广播通知 → 目标与观察者直接耦合            | “微信群@所有人”                           |

> 💡 **记忆口诀**:   
> **策换算法 如导航;✅
> 模定骨架 子填步;✅
> 观推通知 订阅号;✅
> 命封请求 可撤销;✅
> 状驱行为 售货机;✅ 
> 责链审批 逐级传;
> 备存快照 游戏档;
> 访分操作 结构稳;
> 中介调度 塔台控;
> 解文法 语义树;
> 迭遍容器 藏结构.**

> 🔄 **对比强化口诀(辅助记忆)**
> **“策略我选,状态自切”** → 客户选算法 vs 对象自切换
> **“模板继承,策略组合”** → 实现方式对比
> **“命令记操作,备忘录记状态”** → 撤销 vs 恢复
> **“观察者直推,中介者调度”** → 广播 vs 中心化


---

## 📊 高频重点模式推荐

| 类型   | 重点模式                           | 典型应用场景                 |
| ------ | ---------------------------------- | ---------------------------- |
| 创建型 | 工厂方法、单例、建造者             | 框架、工具类、复杂对象构建   |
| 结构型 | 适配器、装饰器、代理               | 系统集成、功能增强、权限控制 |
| 行为型 | 策略、观察者、模板方法、状态、命令 | 业务逻辑、事件驱动、流程控制 |

---

## 🧠 学习建议

1. **按类学习**: 创建 → 结构 → 行为, 理解演进逻辑。
2. **对比记忆**: 重点掌握策略vs状态、装饰器vs代理、命令vs备忘录等。
3. **场景驱动**: 思考“什么问题用什么模式”, 结合Spring/JDK/Qt等框架。
4. **画图+写码**: UML类图 + 最小可运行Demo, 加深理解。
5. **代码实践**: 用 C++/Java/Python 实现最小可运行示例。
6. **优先掌握高频模式**, 避免死记硬背。

---

📌 **结语: **

> 设计模式 = **解决特定问题的思维模板**。  
> 掌握此表 + 口诀 + 对比, 23种模式尽在掌握, 代码设计游刃有余！

---

# 2. 🎯常用设计原则

> ✅ **SOLID + LoD = 面向对象设计黄金法则**
>
> ✅ **掌握这六大原则, 你就掌握了面向对象设计的灵魂！**
>
> ✅ **设计模式是“术”, 这些原则是“道”。**
>
> 🚀 **终极心法: 高内聚, 低耦合, 可扩展, 易维护。**
>
> **💡 记忆口诀: 开里接依迪**

| 中文名                    | 核心思想(一句话)                   |
| ------------------------- | ------------------------------------ |
| 单一职责原则 (SRP-Single Responsibility Principle) | 一个类只做一件事;                    |
| 开闭原则 (OCP - Open/Closed Principle) | 对扩展开放, 对修改关闭;              |
| 里氏替换原则 (LSP - Liskov Substitution Principle) | 子类必须能替换父类而不影响程序正确性;**子换父, 不出错** |
| 接口隔离原则 (ISP - Interface Segregation Principle) | 客户端不应依赖它不需要的接口;**接口小, 不强塞** |
| 依赖倒置原则 (DIP - Dependency Inversion Principle) | 依赖抽象, 不依赖具体; **依赖抽象而非具体** |
| 迪米特法则 (最少知道原则)(LoD - Law of Demeter) | 只与直接朋友通信, 降低耦合; **只聊熟人, 不串门** |

---

## 1️⃣ 单一职责原则

> **一个类, 只负责一件事。**

💡 精炼解释: 

- 职责 = 变化的原因。
- 如果一个类有多个职责, 修改一个可能影响另一个 → 脆弱、难维护。

🧩 C++ 示例: 

```cpp
// ❌ 违反SRP: 一个类既管用户数据, 又管保存到数据库
class User {
    std::string name;
public:
    void setName(std::string n) { name = n; }
    void saveToDB() { /* 连接数据库、执行SQL... */ } // 职责2: 持久化
};

// ✅ 遵循SRP: 拆分职责
class User {
    std::string name;
public:
    void setName(std::string n) { name = n; }
    std::string getName() const { return name; }
};

class UserRepository {
public:
    static void save(const User& user) {
        // 专门负责持久化
    }
};
```

---

## 2️⃣ 开闭原则

> **对扩展开放, 对修改关闭。**

💡 精炼解释: 

- 新增功能 → **扩展**(加新类/策略), 而非**修改**旧代码。
- 通常通过**抽象 + 多态**实现。

🧩 C++ 示例: 

```cpp
// ❌ 违反OCP: 新增支付方式需修改原类
class PaymentProcessor {
public:
    void process(std::string type, double amount) {
        if (type == "Alipay") { /* ... */ }
        else if (type == "WeChat") { /* ... */ }
        // else if (type == "Crypto") { ... } // 每次加新支付都要改这里！
    }
};

// ✅ 遵循OCP: 扩展新类, 不改旧代码
class IPayment {
public:
    virtual ~IPayment() = default;
    virtual void pay(double amount) = 0;
};

class Alipay : public IPayment {
    void pay(double amount) override { /* ... */ }
};

class WeChatPay : public IPayment {
    void pay(double amount) override { /* ... */ }
};

class PaymentProcessor {
    std::unique_ptr<IPayment> strategy;
public:
    void setPayment(std::unique_ptr<IPayment> p) {
        strategy = std::move(p);
    }
    void process(double amount) {
        if (strategy) strategy->pay(amount);
    }
};
// 新增 CryptoPay？只需继承 IPayment, 无需修改 PaymentProcessor！
```

---

## 3️⃣ 里氏替换原则

> **子类必须能替换父类, 且程序行为不变。**

💡 精炼解释: 

- 子类不能破坏父类契约(前置/后置条件、不变量)。
- 不要用继承强行“是-a”关系。

🧩 C++ 示例: 

```cpp
// ❌ 违反LSP: 正方形继承矩形, 但行为不一致
class Rectangle {
protected:
    int width, height;
public:
    virtual void setWidth(int w) { width = w; }
    virtual void setHeight(int h) { height = h; }
    virtual int getArea() { return width * height; }
};

class Square : public Rectangle {
public:
    void setWidth(int w) override { width = height = w; } // 破坏父类契约！
    void setHeight(int h) override { width = height = h; }
};

// 使用时出错: 
void resize(Rectangle& r) {
    r.setWidth(5);
    r.setHeight(4);
    assert(r.getArea() == 20); // 对Square会失败！面积=16 ≠ 20
}

// ✅ 遵循LSP: 正方形不应继承矩形, 或重新设计接口
// → 用组合 or 独立类 or 接口隔离
```

---

## 4️⃣ 接口隔离原则

> **客户端不应被迫依赖它不需要的接口。**

💡 精炼解释: 

- 接口要“小而专”, 不要“大而全”。
- 避免“胖接口”, 按角色拆分。

🧩 C++ 示例: 

```cpp
// ❌ 违反ISP: 一个接口包含所有方法, 有些类用不到
class IBird {
public:
    virtual void fly() = 0;
    virtual void eat() = 0;
    virtual void swim() = 0; // 企鹅不需要！
};

class Penguin : public IBird {
    void fly() override { /* 不能飞, 抛异常？空实现？都不对！ */ }
    void eat() override { /* ... */ }
    void swim() override { /* ... */ }
};

// ✅ 遵循ISP: 按能力拆分接口
class IFlyable { virtual void fly() = 0; };
class ISwimmable { virtual void swim() = 0; };
class IEatable { virtual void eat() = 0; };

class Sparrow : public IFlyable, public IEatable { /* ... */ };
class Penguin : public ISwimmable, public IEatable { /* ... */ };
```

---

## 5️⃣ 依赖倒置原则

> **高层模块不应依赖低层模块, 二者都应依赖抽象。**

💡 精炼解释: 

- 依赖抽象(接口/基类), 不依赖具体实现。
- 控制反转(IoC)的基础。

🧩 C++ 示例: 

```cpp
// ❌ 违反DIP: 高层直接依赖低层具体类
class MySQLDatabase {
public:
    void connect() { /* ... */ }
    void query(std::string sql) { /* ... */ }
};

class UserService {
    MySQLDatabase db; // 紧耦合！换数据库？改代码！
public:
    void getUser(int id) {
        db.query("SELECT * FROM users WHERE id=" + std::to_string(id));
    }
};

// ✅ 遵循DIP: 依赖抽象
class IDatabase {
public:
    virtual ~IDatabase() = default;
    virtual void connect() = 0;
    virtual void query(std::string sql) = 0;
};

class MySQLDatabase : public IDatabase { /* ... */ };
class PostgreSQLDatabase : public IDatabase { /* ... */ };

class UserService {
    std::unique_ptr<IDatabase> db; // 依赖抽象
public:
    UserService(std::unique_ptr<IDatabase> d) : db(std::move(d)) {}
    void getUser(int id) {
        db->query("SELECT * FROM users WHERE id=" + std::to_string(id));
    }
};
// 换数据库？注入不同实现即可, UserService 一行不改！
```

---

## 6️⃣ 迪米特法则

> **只与直接朋友通信, 不和“陌生人”说话。**

💡 精炼解释: 

- “朋友” = 参数、成员、局部变量、this。
- 不要 `a.getB().getC().doSomething()` 链式调用 → 耦合深, 易崩。

🧩 C++ 示例: 

```cpp
// ❌ 违反LoD: 链式调用, 耦合过深
class Engine {
public:
    void start() { /* ... */ }
};

class Car {
    Engine engine;
public:
    Engine& getEngine() { return engine; } // 暴露内部对象！
};

class Driver {
public:
    void drive(Car& car) {
        car.getEngine().start(); // 依赖了Engine！不该知道Car内部结构
    }
};

// ✅ 遵循LoD: 封装内部, 只调用直接接口
class Car {
    Engine engine;
public:
    void start() { engine.start(); } // 封装！Driver 只需知道 Car.start()
};

class Driver {
public:
    void drive(Car& car) {
        car.start(); // 只与Car通信, 不碰Engine
    }
};
```

---

# 🛠️创建型模式

# 3.简单工厂模式

## 简介

**简单工厂模式(Simple Factory Pattern)** 并不是 GoF 23 种设计模式之一,而是一种“编程习惯”或“惯用法”,常被用作工厂方法模式的简化版。

**适用场景**

1. **对象创建逻辑简单,但需要集中管理** - 如根据配置、用户输入、类型字符串等创建不同对象。
2. **客户端不关心具体类,只关心接口** - 解耦客户端与具体实现。
3. **产品类较少,且不太会频繁扩展** - 避免工厂类膨胀。
4. **快速原型或教学示例** - 简单直观,易于理解。

**优缺点**

✅ 优点

- **封装创建逻辑**: 客户端无需知道具体类名,降低耦合。
- **集中管理对象创建**: 便于维护和修改创建逻辑。
- **代码简洁**: 相比工厂方法/抽象工厂更轻量。

❌ 缺点

- **违反开闭原则(OCP)**: 新增产品时必须修改工厂类(需加 `if-else` 或 `switch`)。
- **工厂类职责过重**: 所有产品的创建逻辑集中在一个类中,不易扩展和维护。
- **不是真正的“设计模式”**: 缺乏扩展性和多态性支持(对比工厂方法模式)。

**⚠️ 注意事项**

1. **避免工厂类过于庞大** - 如果产品种类很多,考虑使用**工厂方法模式**或**注册表模式(反射/配置驱动)**。
2. **异常处理要完善** - 对非法输入参数抛出异常或返回空指针,并做好客户端处理。
3. **线程安全问题** - 如果工厂类有状态或使用单例,需考虑多线程环境下的同步。
4. **内存管理** - 示例中使用 `std::unique_ptr` 自动管理资源,避免内存泄漏。
5. **可考虑使用枚举替代字符串** - 提高类型安全性,避免拼写错误: 

**📌总结**

> **简单工厂模式是“工厂模式家族”的入门款,适合产品种类少、变化不频繁的场景。**
>  它让代码更整洁、耦合更低,但不具备良好的扩展性。在需要灵活扩展时,应升级为**工厂方法模式**或**抽象工厂模式**。

## 代码

```
#include <iostream>
#include <memory>
#include <string>

// 抽象产品类
class Product {
public:
    virtual ~Product() = default;
    virtual void operation() = 0;
};

// 具体产品 A
class ConcreteProductA : public Product {
public:
    void operation() override {
        std::cout << "ConcreteProductA::operation() called.\n";
    }
};

// 具体产品 B
class ConcreteProductB : public Product {
public:
    void operation() override {
        std::cout << "ConcreteProductB::operation() called.\n";
    }
};

// 简单工厂类
class SimpleFactory {
public:
    static std::unique_ptr<Product> createProduct(const std::string& type) {
        if (type == "A") {
            return std::make_unique<ConcreteProductA>();
        } else if (type == "B") {
            return std::make_unique<ConcreteProductB>();
        } else {
            throw std::invalid_argument("Unknown product type: " + type);
        }
    }
};

// 客户端代码
int main() {
    try {
        auto productA = SimpleFactory::createProduct("A");
        productA->operation();

        auto productB = SimpleFactory::createProduct("B");
        productB->operation();

        // auto productC = SimpleFactory::createProduct("C"); // 抛出异常
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }

    return 0;
}
```

## PlantUML

```
@startuml
' 简单工厂模式类图

interface Product {
    +operation()
}

class ConcreteProductA {
    +operation()
}

class ConcreteProductB {
    +operation()
}

class SimpleFactory {
    +createProduct(type: string): Product
}

class Client

Client --> SimpleFactory : 使用
SimpleFactory --> Product : 创建
Product <|-- ConcreteProductA
Product <|-- ConcreteProductB

note right of SimpleFactory
  根据传入参数决定
  创建哪个具体产品
end note

@enduml
```

![](./picture/1.SimpleFactoryPattern.png)



# 4. 工厂方法模式

## 简介

**工厂方法模式(Factory Method Pattern)** 是 GoF 23 种经典设计模式之一, 属于 **创建型模式**。

> 它定义一个用于创建对象的**接口(工厂方法)**, 但让**子类决定实例化哪一个类**。工厂方法使一个类的实例化延迟到其子类。

📌 核心思想: **“我不直接创建产品, 我提供一个创建方法, 让子类去实现具体创建逻辑。”**

> 💡 类比: 框架说“你必须提供一个造按钮的方法”, 具体是造 Windows 按钮还是 Mac 按钮, 由子类决定。

与“简单工厂”不同, 工厂方法模式通过**继承 + 多态**实现扩展, 符合**开闭原则**。

**适用场景**

1. **不确定对象创建细节, 希望子类决定** —— 如框架提供接口, 用户实现具体产品。
2. **需要将产品创建与使用解耦** —— 客户端只依赖抽象产品和创建者。
3. **希望支持扩展新产品, 而不修改现有代码** —— 符合开闭原则。
4. **并行产品族结构** —— 如不同平台、不同数据库、不同文件格式的创建。

📌 常见应用: 

- 跨平台 UI 控件(Qt、MFC 等框架)
- 数据库连接工厂(MySQLFactory、PostgreSQLFactory)
- 游戏关卡生成器(EasyLevelFactory、HardLevelFactory)
- 日志记录器(FileLoggerFactory、DBLoggerFactory)
- 插件系统(每个插件提供自己的工厂)

**优缺点**

**✅ 优点**

- **符合开闭原则** —— 新增产品只需新增具体工厂和产品类, 无需修改现有代码。
- **符合单一职责原则** —— 创建逻辑封装在工厂子类中。
- **客户端与具体产品解耦** —— 只依赖抽象接口。
- **支持并行产品族结构** —— 易于组织相关产品。
- **便于单元测试** —— 可轻松 Mock 工厂方法。

**❌ 缺点**

- **类数量增加** —— 每个产品对应一个工厂子类(有时显得“类爆炸”)。
- **结构略复杂** —— 相比“简单工厂”, 多了一层继承结构。
- **客户端需知道具体工厂类** —— 仍需 `new WindowsDialog()`, 可通过“抽象工厂”或配置进一步解耦。

**⚠️ 注意事项**

1. **工厂方法通常为虚函数** —— C++ 中用 `virtual` 标记, 允许子类重写。
2. **返回智能指针管理资源** —— 示例中使用 `std::unique_ptr` 避免内存泄漏。
3. **可结合模板简化(模板工厂方法)** —— 若产品构造简单, 可用 CRTP: 

📌 **一句话总结: **

> **工厂方法 = “我定义创建接口, 你(子类)决定创建谁”, 实现灵活扩展, 拥抱变化。**

## 代码

```
// Shape.h
#include <iostream>
#include <memory>

// 抽象产品
class Shape {
public:
    virtual ~Shape() = default;
    virtual void draw() = 0;
};

// 具体产品: 圆形
class Circle : public Shape {
public:
    void draw() override {
        std::cout << "Drawing a Circle" << std::endl;
    }
};

// 具体产品: 矩形
class Rectangle : public Shape {
public:
    void draw() override {
        std::cout << "Drawing a Rectangle" << std::endl;
    }
};

// 抽象工厂
class ShapeFactory {
public:
    virtual ~ShapeFactory() = default;
    virtual std::unique_ptr<Shape> createShape() = 0; // 工厂方法
};

// 具体工厂: 圆形工厂
class CircleFactory : public ShapeFactory {
public:
    std::unique_ptr<Shape> createShape() override {
        return std::make_unique<Circle>();
    }
};

// 具体工厂: 矩形工厂
class RectangleFactory : public ShapeFactory {
public:
    std::unique_ptr<Shape> createShape() override {
        return std::make_unique<Rectangle>();
    }
};

// 客户端代码
void clientCode(std::unique_ptr<ShapeFactory> factory) {
    auto shape = factory->createShape();
    shape->draw();
}

// main.cpp
#include "Shape.h"

int main() {
    std::cout << "Client: Testing with CircleFactory:\n";
    clientCode(std::make_unique<CircleFactory>());

    std::cout << "\nClient: Testing with RectangleFactory:\n";
    clientCode(std::make_unique<RectangleFactory>());

    return 0;
}
```

## PlantUML

```
@startuml
' 抽象产品
abstract class Shape {
    +draw() : void
}

' 具体产品
class Circle {
    +draw() : void
}

class Rectangle {
    +draw() : void
}

' 抽象工厂
abstract class ShapeFactory {
    +createShape() : std::unique_ptr<Shape>
}

' 具体工厂
class CircleFactory {
    +createShape() : std::unique_ptr<Shape>
}

class RectangleFactory {
    +createShape() : std::unique_ptr<Shape>
}

' 关系
Shape <|-- Circle
Shape <|-- Rectangle

ShapeFactory <|-- CircleFactory
ShapeFactory <|-- RectangleFactory

CircleFactory ..> Circle : creates
RectangleFactory ..> Rectangle : creates

note right of ShapeFactory
    Factory Method
    declares interface
end note

note right of CircleFactory
    overrides to
    create Circle
end note

@enduml
```

![](./picture/2.FactoryMethodPattern.png)



# 5. 抽象工厂模式

## 简介

**抽象工厂模式(Abstract Factory Pattern)** 是 GoF 23 种经典设计模式之一, 属于 **创建型模式**。

> 它提供一个**创建一系列相关或相互依赖对象的接口**, 而无需指定它们具体的类。

📌 核心思想: **“不是造一个产品, 而是造一整套风格一致的产品族。”**

> 💡 类比: 买家具 —— 你选“北欧风格”, 工厂就给你造北欧的沙发+椅子+桌子; 选“工业风”, 就全换成工业风。你不用一个个指定, 工厂打包给你。

抽象工厂是 **工厂方法模式的扩展** —— 工厂方法针对“单一产品”, 抽象工厂针对“产品族”。

**适用场景**

1. **系统需要独立于产品的创建、组合和表示时。**
2. **系统需要由多个产品系列中的一个来配置时。**
3. **强调一系列相关产品对象的设计以便进行联合使用。**
4. **提供一个产品类库, 而只想显示它们的接口, 而不是实现时。**

📌 **典型应用场景: **

- GUI 跨平台组件库(Windows vs Mac vs Linux 风格控件)
- 游戏中不同主题的装备套装(战士套装、法师套装)
- 数据库访问层(MySQLFactory、PostgreSQLFactory 创建 Connection、Command、DataReader)

**✅ 三、优缺点**

**✅ 优点: **

1. **分离具体类的生成, 客户端不依赖具体类。**
2. **易于交换产品系列** —— 只需更换 ConcreteFactory。
3. **有利于产品一致性** —— 确保创建的对象是配套的、兼容的。
4. **符合开闭原则(对扩展开放)** —— 增加新产品族时只需新增工厂和产品类。

**❌ 缺点: **

1. **难以支持新种类的产品** —— 如果要新增一类产品(如新增 TextBox), 需要修改所有工厂接口及其实现。
2. **类数量爆炸** —— 每个产品族 × 每个产品类型 = 大量类。
3. **结构复杂, 小项目不推荐。**

> 💡 抽象工厂适合“产品族稳定、产品类型少、族多”的场景。

**✅ 注意事项**

1. **抽象工厂接口应稳定, 避免频繁增删产品类型。**
2. **C++ 中推荐返回智能指针(`std::unique_ptr`)管理资源。**
3. **工厂通常不持有状态, 可设计为单例或静态工厂。**
4. **避免在工厂中做复杂初始化逻辑, 保持职责单一。**
5. **如果产品类型可能扩展, 可考虑结合“反射”或“注册机制”动态支持。**

📌 **一句话总结: **

> **抽象工厂 = “我给你一套配套产品, 你无需关心它们从哪来, 只需用就对了”。**

## 代码

```
// GUIFactory.h
#include <iostream>
#include <memory>
#include <string>

// 抽象产品: 按钮
class Button {
public:
    virtual ~Button() = default;
    virtual void paint() = 0;
};

// 抽象产品: 复选框
class Checkbox {
public:
    virtual ~Checkbox() = default;
    virtual void paint() = 0;
};

// 抽象工厂
class GUIFactory {
public:
    virtual ~GUIFactory() = default;
    virtual std::unique_ptr<Button> createButton() = 0;
    virtual std::unique_ptr<Checkbox> createCheckbox() = 0;
};

// ==================== Windows 平台产品 ====================

class WinButton : public Button {
public:
    void paint() override {
        std::cout << "Render a button in Windows style." << std::endl;
    }
};

class WinCheckbox : public Checkbox {
public:
    void paint() override {
        std::cout << "Render a checkbox in Windows style." << std::endl;
    }
};

class WinFactory : public GUIFactory {
public:
    std::unique_ptr<Button> createButton() override {
        return std::make_unique<WinButton>();
    }

    std::unique_ptr<Checkbox> createCheckbox() override {
        return std::make_unique<WinCheckbox>();
    }
};

// ==================== Mac 平台产品 ====================

class MacButton : public Button {
public:
    void paint() override {
        std::cout << "Render a button in Mac style." << std::endl;
    }
};

class MacCheckbox : public Checkbox {
public:
    void paint() override {
        std::cout << "Render a checkbox in Mac style." << std::endl;
    }
};

class MacFactory : public GUIFactory {
public:
    std::unique_ptr<Button> createButton() override {
        return std::make_unique<MacButton>();
    }

    std::unique_ptr<Checkbox> createCheckbox() override {
        return std::make_unique<MacCheckbox>();
    }
};

// ==================== 客户端代码 ====================

void clientCode(std::unique_ptr<GUIFactory> factory) {
    auto button = factory->createButton();
    auto checkbox = factory->createCheckbox();

    button->paint();
    checkbox->paint();
}

// main.cpp
#include "GUIFactory.h"

int main() {
    std::cout << "Client: Testing client code with Windows factory:\n";
    clientCode(std::make_unique<WinFactory>());

    std::cout << "\nClient: Testing client code with Mac factory:\n";
    clientCode(std::make_unique<MacFactory>());

    return 0;
}
```

## PlantUML

```
@startuml

' ================= 抽象层 =================
abstract class GUIFactory {
    +createButton() : std::unique_ptr<Button>
    +createCheckbox() : std::unique_ptr<Checkbox>
}

abstract class Button {
    +paint() : void
}

abstract class Checkbox {
    +paint() : void
}

' ================= Windows 产品族 =================
class WinFactory {
    +createButton() : std::unique_ptr<Button>
    +createCheckbox() : std::unique_ptr<Checkbox>
}

class WinButton {
    +paint() : void
}

class WinCheckbox {
    +paint() : void
}

' ================= Mac 产品族 =================
class MacFactory {
    +createButton() : std::unique_ptr<Button>
    +createCheckbox() : std::unique_ptr<Checkbox>
}

class MacButton {
    +paint() : void
}

class MacCheckbox {
    +paint() : void
}

' ================= 继承关系 =================
GUIFactory <|-- WinFactory
GUIFactory <|-- MacFactory

Button <|-- WinButton
Button <|-- MacButton

Checkbox <|-- WinCheckbox
Checkbox <|-- MacCheckbox

' ================= 创建关系 =================
WinFactory ..> WinButton : creates
WinFactory ..> WinCheckbox : creates

MacFactory ..> MacButton : creates
MacFactory ..> MacCheckbox : creates

note right of GUIFactory
    Abstract Factory
    creates a family of products
end note

note right of WinFactory
    Concrete Factory for Windows
end note

@enduml
```

![](./picture\3.AbstractFactoryPattern.png)

# 6. 单例模式

## 简介

> **单例模式(Singleton Pattern)** 是一种创建型设计模式, 它确保一个类**只有一个实例**, 并提供一个**全局访问点**来访问该实例。

**核心思想: **

- **私有化构造函数** → 防止外部 `new`
- **静态成员变量** → 存储唯一实例
- **静态成员函数** → 提供全局访问接口(如 `getInstance()`

**适用场景**

1. **需要全局唯一访问点的对象**, 如: 
   - 配置管理器(ConfigManager)
   - 日志记录器(Logger)
   - 数据库连接池(ConnectionPool)
   - 线程池(ThreadPool)
   - 应用程序上下文(ApplicationContext)
2. **资源需要共享且控制访问数量时**(如许可证、硬件设备驱动)。
3. **避免频繁创建销毁开销大的对象**。

📌 **典型应用场景: **

- 游戏中的“游戏管理器”
- 系统中的“设置中心”
- 多线程环境中的“全局状态管理”

**优缺点**

**✅ 优点: **

1. **确保全局唯一实例, 节省资源。**
2. **提供全局访问点, 使用方便。**
3. **延迟初始化(Lazy Initialization)—— 首次使用才创建。**
4. **可继承扩展(受限, 但可通过模板或依赖注入优化)。**

**❌ 缺点: **

1. **违反单一职责原则** —— 既要管理实例, 又要处理业务逻辑。
2. **隐藏依赖关系** —— 不利于单元测试(Mock 困难)。
3. **多线程环境下需考虑线程安全**(C++11 后可简化)。
4. **生命周期管理困难** —— 何时销毁？谁来销毁？
5. **可能造成“全局状态污染”**, 导致代码耦合度高。

> 💡 现代 C++ 项目中, 单例应谨慎使用, 优先考虑依赖注入(DI)或服务定位器(Service Locator)。

**注意事项(非常重要！)**

1. 🚨 线程安全(Thread Safety)

2. 🚫 禁止拷贝和赋值
3. 🕒 析构顺序问题(“静态析构顺序惨案”)
4. 单元测试困难

**📌 一句话总结: **

> **单例模式 = “我保证全局只有一个我, 谁要用, 找我拿”。**

## 代码

```
// Singleton.h
#pragma once
#include <iostream>

class Singleton {
private:
    // 私有构造
    Singleton() {
        std::cout << "Singleton created!" << std::endl;
    }

    // 禁止拷贝
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

public:
    // C++11 Magic Static: 线程安全 + 延迟初始化 + 自动析构
    static Singleton& getInstance() {
        static Singleton instance;
        return instance;
    }

    void doSomething() {
        std::cout << "Doing something..." << std::endl;
    }

    ~Singleton() {
        std::cout << "Singleton destroyed!" << std::endl;
    }
};

// main.cpp
#include "Singleton.h"

int main() {
    auto& s1 = Singleton::getInstance();
    s1.doSomething();

    auto& s2 = Singleton::getInstance();
    std::cout << (&s1 == &s2 ? "Same instance!" : "Different!") << std::endl;

    return 0;
}
```

## PlantUML

```
@startuml

class Singleton {
    -{static} instance : Singleton*
    -Singleton()
    +{static} getInstance() : Singleton&
    +doSomething() : void
    -{delete} Singleton(const Singleton&)
    -{delete} operator=(const Singleton&)
}

note right of Singleton::getInstance
    C++11 Magic Static:
    - Thread-safe
    - Lazy initialization
    - Auto destruction
end note

note bottom of Singleton
    Ensures only one instance exists
    and provides global access point.
end note

@enduml
```

![](./picture/4.SingletonPattern.png)

# 7. 建造者模式

## 简介

> **建造者模式(Builder Pattern)** 是一种创建型设计模式, 它将一个**复杂对象的构建过程与其表示分离**, 使得同样的构建过程可以创建不同的表示。

🎯 核心思想: 

- 将对象的**构造过程分解为多个步骤**(如 setPartA, setPartB, setPartC…)
- 使用一个“导演”(Director)控制构建流程(可选)
- 最终返回完整构建好的对象

> 💡 适用于: 对象构造复杂、参数多、构造步骤多、需要灵活组合不同部分。

🧩 **结构组成**: 

| 角色              | 说明                                             |
| ----------------- | ------------------------------------------------ |
| `Product`         | 被构建的复杂对象(如汽车、SQL查询、HTML文档)    |
| `Builder`         | 抽象建造者, 定义构建各部分的接口                 |
| `ConcreteBuilder` | 具体建造者, 实现构建步骤, 提供获取最终产品的接口 |
| `Director`        | (可选)指导构建过程, 封装构建流程               |

✅**适用场景**

1. **创建复杂对象, 其构造过程包含多个步骤或部件。**
2. **构造过程必须允许构造不同的表示(如不同配置的汽车、不同风格的文档)。**
3. **对象的构造算法应独立于组成部分和装配方式。**
4. **构造过程需要被复用或标准化(如“标准套餐”、“豪华套餐”)。**

📌 **典型应用场景: **

- 构建 SQL 查询语句(SELECT, FROM, WHERE, GROUP BY…)
- 构建 HTML / XML 文档
- 游戏角色创建(不同装备、属性组合)
- 汽车/电脑配置器(选配 CPU、内存、硬盘…)
- 流式 API(如 std::ostringstream, Qt 的信号槽连接器)

**优缺点**

**✅ 优点: **

1. **分离构造与表示** → 同一构建过程可创建不同产品。
2. **更精细控制构造过程** → 可跳过、重复、条件化某些步骤。
3. **代码可读性高** → 步骤清晰, 易于维护。
4. **支持 Fluent Interface(流式调用)** → 提升 API 体验。
5. **符合开闭原则** → 新增 Builder 不影响原有代码。

**❌ 缺点: **

1. **类数量增加** → 每个产品变体可能需要一个 Builder。
2. **结构略复杂** → 小项目或简单对象不推荐使用。
3. **Director 非必需** → 有时客户端直接调用 Builder 更灵活。

✅**注意事项**

1. **Builder 通常不持有最终产品状态, 而是逐步构建。**
2. **最终产品应提供“获取结果”方法(如 `getProduct()`)。**
3. **可选: 提供“重置”方法, 以便 Builder 重用。**
4. **C++ 中推荐返回 `std::unique_ptr` 或值对象, 避免裸指针。**
5. **支持 Fluent Interface 时, 每个 setter 返回 `\*this`。**
6. **线程安全: Builder 通常非线程安全, 应避免共享。**

> **记忆口诀: **
>
> - **工厂 → “给你一个成品”**
> - **建造者 → “一步步帮你搭出来”**

📌 **终极建议: **

> **现代 C++ 中, 优先考虑 Fluent Builder(流式接口), 它更直观、更易用、更符合直觉。Director 可选, 客户端直接调用 Builder 往往更灵活。**



## 代码

```
// Computer.h
#include <iostream>
#include <string>
#include <memory>

// 产品类: 计算机
class Computer {
private:
    std::string cpu;
    std::string ram;
    std::string storage;
    bool hasGPU = false;
    bool hasSSD = false;

public:
    // 设置器(可选, Builder 也可直接访问私有成员, 或设为 friend)
    void setCPU(const std::string& c) { cpu = c; }
    void setRAM(const std::string& r) { ram = r; }
    void setStorage(const std::string& s) { storage = s; }
    void setGPU(bool g) { hasGPU = g; }
    void setSSD(bool s) { hasSSD = s; }

    void show() const {
        std::cout << "=== Computer Configuration ===\n";
        std::cout << "CPU: " << cpu << "\n";
        std::cout << "RAM: " << ram << "\n";
        std::cout << "Storage: " << storage << "\n";
        std::cout << "GPU: " << (hasGPU ? "Yes" : "No") << "\n";
        std::cout << "SSD: " << (hasSSD ? "Yes" : "No") << "\n";
        std::cout << "=============================\n\n";
    }
};

// 抽象建造者
class ComputerBuilder {
public:
    virtual ~ComputerBuilder() = default;
    virtual void buildCPU() = 0;
    virtual void buildRAM() = 0;
    virtual void buildStorage() = 0;
    virtual void buildGPU() = 0;
    virtual void buildSSD() = 0;
    virtual std::unique_ptr<Computer> getComputer() = 0;
};

// 具体建造者: 游戏电脑
class GamingComputerBuilder : public ComputerBuilder {
private:
    std::unique_ptr<Computer> computer;

public:
    GamingComputerBuilder() {
        computer = std::make_unique<Computer>();
    }

    void buildCPU() override {
        computer->setCPU("Intel i9-13900K");
    }

    void buildRAM() override {
        computer->setRAM("32GB DDR5");
    }

    void buildStorage() override {
        computer->setStorage("2TB NVMe");
    }

    void buildGPU() override {
        computer->setGPU(true);
    }

    void buildSSD() override {
        computer->setSSD(true);
    }

    std::unique_ptr<Computer> getComputer() override {
        return std::move(computer);
    }
};

// 具体建造者: 办公电脑
class OfficeComputerBuilder : public ComputerBuilder {
private:
    std::unique_ptr<Computer> computer;

public:
    OfficeComputerBuilder() {
        computer = std::make_unique<Computer>();
    }

    void buildCPU() override {
        computer->setCPU("Intel i5-13400");
    }

    void buildRAM() override {
        computer->setRAM("16GB DDR4");
    }

    void buildStorage() override {
        computer->setStorage("512GB SSD");
    }

    void buildGPU() override {
        computer->setGPU(false);
    }

    void buildSSD() override {
        computer->setSSD(true);
    }

    std::unique_ptr<Computer> getComputer() override {
        return std::move(computer);
    }
};

// 导演类(可选): 封装构建流程
class ComputerDirector {
public:
    static void constructGamingComputer(ComputerBuilder& builder) {
        builder.buildCPU();
        builder.buildRAM();
        builder.buildStorage();
        builder.buildGPU();
        builder.buildSSD();
    }

    static void constructOfficeComputer(ComputerBuilder& builder) {
        builder.buildCPU();
        builder.buildRAM();
        builder.buildStorage();
        builder.buildSSD();
        // 不装独立显卡
    }
};

// 客户端代码
#include "Computer.h"

int main() {
    // 方式1: 使用 Director
    std::cout << "=== Using Director ===\n";
    GamingComputerBuilder gamingBuilder;
    ComputerDirector::constructGamingComputer(gamingBuilder);
    auto gamingPC = gamingBuilder.getComputer();
    gamingPC->show();

    // 方式2: 客户端直接控制构建步骤(更灵活)
    std::cout << "=== Manual Building ===\n";
    OfficeComputerBuilder officeBuilder;
    officeBuilder.buildCPU();
    officeBuilder.buildRAM();
    officeBuilder.buildStorage();
    officeBuilder.buildSSD();
    // 跳过 buildGPU()
    auto officePC = officeBuilder.getComputer();
    officePC->show();

    return 0;
}
```

✅ 进阶: Fluent Builder(流式接口)

```
class FluentComputerBuilder {
private:
    std::unique_ptr<Computer> computer;

public:
    FluentComputerBuilder() : computer(std::make_unique<Computer>()) {}

    FluentComputerBuilder& withCPU(const std::string& cpu) {
        computer->setCPU(cpu);
        return *this; // 返回自身, 支持链式调用
    }

    FluentComputerBuilder& withRAM(const std::string& ram) {
        computer->setRAM(ram);
        return *this;
    }

    FluentComputerBuilder& withStorage(const std::string& storage) {
        computer->setStorage(storage);
        return *this;
    }

    FluentComputerBuilder& withGPU() {
        computer->setGPU(true);
        return *this;
    }

    std::unique_ptr<Computer> build() {
        return std::move(computer);
    }
};

// 使用方式: 
auto customPC = FluentComputerBuilder()
    .withCPU("AMD Ryzen 9")
    .withRAM("64GB DDR5")
    .withStorage("4TB SSD")
    .withGPU()
    .build();

customPC->show();
```

## PlantUML

```
@startuml

' 产品
class Computer {
    -cpu: string
    -ram: string
    -storage: string
    -hasGPU: bool
    -hasSSD: bool
    +setCPU(cpu: string)
    +setRAM(ram: string)
    +setStorage(storage: string)
    +setGPU(gpu: bool)
    +setSSD(ssd: bool)
    +show() : void
}

' 抽象建造者
abstract class ComputerBuilder {
    +buildCPU() : void
    +buildRAM() : void
    +buildStorage() : void
    +buildGPU() : void
    +buildSSD() : void
    +getComputer() : std::unique_ptr<Computer>
}

' 具体建造者
class GamingComputerBuilder {
    -computer: std::unique_ptr<Computer>
    +buildCPU()
    +buildRAM()
    +buildStorage()
    +buildGPU()
    +buildSSD()
    +getComputer() : std::unique_ptr<Computer>
}

class OfficeComputerBuilder {
    -computer: std::unique_ptr<Computer>
    +buildCPU()
    +buildRAM()
    +buildStorage()
    +buildGPU()
    +buildSSD()
    +getComputer() : std::unique_ptr<Computer>
}

' 导演(可选)
class ComputerDirector {
    +{static} constructGamingComputer(builder: ComputerBuilder&)
    +{static} constructOfficeComputer(builder: ComputerBuilder&)
}

' 关系
ComputerBuilder <|-- GamingComputerBuilder
ComputerBuilder <|-- OfficeComputerBuilder

GamingComputerBuilder ..> Computer : builds
OfficeComputerBuilder ..> Computer : builds

ComputerDirector ..> ComputerBuilder : uses

note right of ComputerBuilder
    Defines steps to build
    a Computer.
end note

note bottom of ComputerDirector
    Optional: Encapsulates
    common build sequences.
end note

@enduml
```

![](./picture/5.BuilderPattern.png)

# 8. 原型模式

## 简介

> **原型模式(Prototype Pattern)** 是一种创建型设计模式, 它通过**复制现有对象(原型)** 来创建新对象, 而不是通过 `new` 调用构造函数。

🎯 **核心思想: **

- **“克隆”代替“构造”**
- 定义一个 `clone()` 接口, 由子类实现具体的复制逻辑
- 客户端不关心对象创建细节, 只需复制原型即可

> 💡 适用于: 对象创建成本高、结构复杂、或需动态配置对象时。

🧩 **结构组成: **

| 角色                | 说明                             |
| ------------------- | -------------------------------- |
| `Prototype`         | 声明克隆接口(如 `clone()`)     |
| `ConcretePrototype` | 实现克隆方法, 返回自身副本       |
| `Client`            | 持有原型对象, 通过克隆创建新对象 |

✅**适用场景**

1. **对象创建成本高(如需从数据库/网络加载、复杂初始化)**
2. **系统需独立于对象的创建、组合和表示**
3. **运行时动态决定创建对象的种类(通过配置原型池)**
4. **避免构建类层次的工厂(用克隆代替工厂)**
5. **需要“对象模板”功能(如游戏中的怪物模板、文档模板)**

📌 **典型应用场景: **

- 游戏中大量相同怪物/道具的生成(克隆模板)
- 图形编辑器中复制复杂图形对象
- 配置管理系统中复制预设配置对象
- 复杂对象初始化后作为“默认模板”供后续复制

✅ **优缺点**

✅ 优点: 

1. **隐藏创建细节** → 客户端无需知道具体类。
2. **性能优化** → 避免重复昂贵初始化。
3. **支持动态配置** → 运行时替换原型对象。
4. **简化对象创建** → 无需对应每个类写工厂。
5. **可结合“原型注册表”实现配置化创建。**

❌ 缺点: 

1. **必须实现克隆方法** → 每个子类都要写 `clone()`。
2. **深拷贝实现复杂** → 涉及指针、资源管理时容易出错。
3. **破坏封装性** → 克隆可能需访问私有成员(可声明为 `friend` 或提供复制构造)。
4. **对“不可变对象”无意义** → 如全是 `const` 成员。

✅ **注意事项(非常重要！)**

1. 🚨 深拷贝 vs 浅拷贝(C++ 核心问题！)

- **浅拷贝(默认)**: 只复制指针值 → 多个对象共享同一块内存 → 危险！
- **深拷贝**: 复制指针指向的内容 → 独立副本 → 安全！

✅ **必须手动实现深拷贝**, 或使用智能指针 + 自定义克隆。

2. 📌 实现 `clone()` 的常见方式: 

方式1: 纯虚函数 + 子类 override(推荐)

方式2: 使用复制构造函数(需暴露或声明为 friend)

3. 🧩 资源管理建议: 

- 使用 `std::unique_ptr` / `std::shared_ptr` 管理动态资源
- 若含裸指针, 必须在 `clone()` 中手动 `new` + 深拷贝
- 考虑使用“复制构造函数 + 赋值操作符”实现 RAII

4. 🧪 可结合“原型注册表”实现动态创建

​	std::map<std::string, std::unique_ptr<Prototype>> prototypeRegistry;

​	客户端通过 key 获取原型并克隆, 实现“配置化对象创建”。

📌 **终极建议: **

> **现代 C++ 中, 若对象不含裸指针或复杂资源, 使用默认复制构造即可; 若含资源, 优先使用智能指针或容器, 避免手动管理内存。原型模式在游戏开发、图形编辑器、配置系统中非常实用！**

掌握原型模式, 你就能高效“克隆”对象, 避免重复初始化开销, 提升系统性能和灵活性！

## 代码

```
// Prototype.h
#include <iostream>
#include <string>
#include <memory>
#include <unordered_map>

// 抽象原型
class EnemyPrototype {
public:
    virtual ~EnemyPrototype() = default;

    // 纯虚克隆函数
    virtual std::unique_ptr<EnemyPrototype> clone() const = 0;

    // 业务方法
    virtual void showInfo() const = 0;
    virtual void fight() const = 0;
};

// 具体原型: 哥布林
class Goblin : public EnemyPrototype {
private:
    std::string name;
    int health;
    int damage;

public:
    Goblin(const std::string& n = "Goblin", int h = 50, int d = 10)
        : name(n), health(h), damage(d) {}

    // 实现深拷贝克隆
    std::unique_ptr<EnemyPrototype> clone() const override {
        return std::make_unique<Goblin>(*this); // 调用复制构造(默认即可, 无指针)
    }

    void showInfo() const override {
        std::cout << "[Goblin] Name: " << name << ", Health: " << health << ", Damage: " << damage << std::endl;
    }

    void fight() const override {
        std::cout << name << " attacks with " << damage << " damage!" << std::endl;
    }

    // 可选: 提供修改方法用于配置模板
    void setHealth(int h) { health = h; }
    void setDamage(int d) { damage = d; }
    void setName(const std::string& n) { name = n; }
};

// 具体原型: 巨魔
class Troll : public EnemyPrototype {
private:
    std::string name;
    int health;
    int damage;
    bool regenerates;

public:
    Troll(const std::string& n = "Troll", int h = 100, int d = 20, bool regen = true)
        : name(n), health(h), damage(d), regenerates(regen) {}

    std::unique_ptr<EnemyPrototype> clone() const override {
        return std::make_unique<Troll>(*this);
    }

    void showInfo() const override {
        std::cout << "[Troll] Name: " << name << ", Health: " << health
                  << ", Damage: " << damage << ", Regen: " << (regenerates ? "Yes" : "No") << std::endl;
    }

    void fight() const override {
        std::cout << name << " smashes for " << damage << " damage!" << std::endl;
        if (regenerates) std::cout << name << " starts regenerating health!\n";
    }
};

// 原型管理器(注册表)
class EnemyPrototypeManager {
private:
    std::unordered_map<std::string, std::unique_ptr<EnemyPrototype>> prototypes;

public:
    void registerPrototype(const std::string& key, std::unique_ptr<EnemyPrototype> prototype) {
        prototypes[key] = std::move(prototype);
    }

    std::unique_ptr<EnemyPrototype> create(const std::string& key) const {
        auto it = prototypes.find(key);
        if (it != prototypes.end() && it->second) {
            return it->second->clone();
        }
        throw std::runtime_error("Prototype not found: " + key);
    }
};

// main.cpp
#include "Prototype.h"

int main() {
    // 创建原型模板
    auto goblinTemplate = std::make_unique<Goblin>("Green Goblin", 60, 15);
    auto trollTemplate = std::make_unique<Troll>("Cave Troll", 120, 25, true);

    // 注册到管理器
    EnemyPrototypeManager manager;
    manager.registerPrototype("goblin", std::move(goblinTemplate));
    manager.registerPrototype("troll", std::move(trollTemplate));

    // 通过克隆创建新对象
    std::cout << "=== Creating enemies via Prototype ===\n";
    auto enemy1 = manager.create("goblin");
    auto enemy2 = manager.create("troll");
    auto enemy3 = manager.create("goblin"); // 再克隆一个哥布林

    enemy1->showInfo();
    enemy1->fight();

    enemy2->showInfo();
    enemy2->fight();

    enemy3->showInfo();
    enemy3->fight();

    return 0;
}
```

✅ 含指针成员的深拷贝示例(重要！)

```
class DeepCopyExample : public EnemyPrototype {
private:
    std::string* name; // 假设用裸指针(实际推荐用 std::string)
    int health;

public:
    DeepCopyExample(const std::string& n = "Default", int h = 100) 
        : health(h) {
        name = new std::string(n);
    }

    // 深拷贝复制构造
    DeepCopyExample(const DeepCopyExample& other)
        : health(other.health) {
        name = new std::string(*other.name); // 深拷贝！
    }

    // 必须重载赋值操作符(Rule of Three)
    DeepCopyExample& operator=(const DeepCopyExample& other) {
        if (this != &other) {
            delete name;
            name = new std::string(*other.name);
            health = other.health;
        }
        return *this;
    }

    ~DeepCopyExample() {
        delete name;
    }

    std::unique_ptr<EnemyPrototype> clone() const override {
        return std::make_unique<DeepCopyExample>(*this); // 调用复制构造
    }

    void showInfo() const override {
        std::cout << "Name: " << *name << ", Health: " << health << std::endl;
    }

    void fight() const override {
        std::cout << *name << " fights!\n";
    }
};
```

## PlantUML

```
@startuml

' 抽象原型
abstract class EnemyPrototype {
    +clone() : std::unique_ptr<EnemyPrototype>
    +showInfo() : void
    +fight() : void
}

' 具体原型
class Goblin {
    -name: string
    -health: int
    -damage: int
    +clone() : std::unique_ptr<EnemyPrototype>
    +showInfo() : void
    +fight() : void
    +setHealth(h: int)
    +setDamage(d: int)
}

class Troll {
    -name: string
    -health: int
    -damage: int
    -regenerates: bool
    +clone() : std::unique_ptr<EnemyPrototype>
    +showInfo() : void
    +fight() : void
}

' 原型管理器
class EnemyPrototypeManager {
    -prototypes: map<string, unique_ptr<EnemyPrototype>>
    +registerPrototype(key: string, prototype: unique_ptr<EnemyPrototype>)
    +create(key: string) : unique_ptr<EnemyPrototype>
}

' 关系
EnemyPrototype <|-- Goblin
EnemyPrototype <|-- Troll

EnemyPrototypeManager o-- EnemyPrototype : holds prototypes

note right of EnemyPrototype::clone
    Pure virtual function
    Subclasses implement
    deep copy logic.
end note

note bottom of EnemyPrototypeManager
    Optional registry for
    dynamic prototype access.
end note

@enduml
```

![](./picture/6.PrototypePattern.png)

# 🔌结构型模式

# 9. 适配器模式

## 简介

> **适配器模式(Adapter Pattern)** 是一种结构型设计模式, 它**将一个类的接口转换成客户期望的另一个接口**, 使得原本由于接口不兼容而不能一起工作的类可以协同工作。

🎯 **核心思想: **

- **“接口转换器”** —— 像电源适配器一样, 把“不匹配的插头”变成“匹配的插头”
- 解决“老接口”与“新需求”之间的不兼容问题
- 不修改原有类, 通过“包装”实现接口转换

> 💡 适用于: 集成第三方库、旧系统改造、接口标准化等场景。

🧩 **结构组成: **

| 角色      | 说明                                            |
| --------- | ----------------------------------------------- |
| `Target`  | 客户端期望的接口(抽象类或接口)                |
| `Adaptee` | 已存在的、但接口不兼容的类(“被适配者”)        |
| `Adapter` | 适配器, 继承/组合 `Adaptee`, 实现 `Target` 接口 |

✅ **适用场景**

1. **使用现有类, 但其接口不符合需求。**
2. **想复用一些现存的类, 但无法修改其源码(如第三方库)。**
3. **创建一个可复用的类, 与其他不相关或不可预见的类协同工作。**
4. **系统数据/接口升级, 需要兼容旧版本接口。**

📌 **典型应用场景: **

- 将旧版日志接口适配到新版统一日志系统
- 将第三方支付 SDK(如支付宝、微信)统一成内部支付接口
- 将不同图形库(OpenGL/DirectX)统一成引擎渲染接口
- 将 C 风格 API 适配成 C++ RAII 接口
- 游戏中不同输入设备(键盘、手柄、触屏)统一成“输入事件”

✅ **优缺点**

✅ 优点: 

1. **提高类的复用性** → 不修改原有代码即可集成。
2. **增强类的透明性和复用性** → 客户端只与 Target 接口交互。
3. **灵活性高** → 可同时适配多个 Adaptee。
4. **符合开闭原则** → 对扩展开放, 对修改关闭。

❌ 缺点: 

1. **增加系统复杂度** → 引入额外的适配器类。
2. **过多适配器会让系统“绕来绕去”** → 调试困难。
3. **性能略有损失** → 多一层调用(通常可忽略)。

✅ **注意事项**

1. 🔄 两种实现方式: 

| 方式           | 说明                         | 优点                 | 缺点                     |
| -------------- | ---------------------------- | -------------------- | ------------------------ |
| **类适配器**   | 通过多重继承实现(C++ 支持) | 效率高, 直接继承     | 不灵活, C++ 多重继承复杂 |
| **对象适配器** | 通过组合 + 委托实现(推荐)  | 灵活, 可适配类的子类 | 多一层对象引用           |

> ✅ **现代 C++ 推荐使用“对象适配器”** —— 更灵活、更安全、更符合组合优于继承原则。

2. ⚠️ 适配器不是万能胶水

- 适配器用于**接口转换**, 不是用于**功能增强**
- 如果两个类语义完全不相关, 强行适配会导致逻辑混乱

3. 📦 适配器可结合“工厂模式”动态选择适配对象

4. 🧩 适配器可“双向适配”

- 有时需要 A→B, 有时需要 B→A, 可设计双向适配器(较少见)

🎯 **推荐语: **

> **当你面对“祖传代码”或“第三方黑盒库”时, 适配器模式是你最好的朋友。它让你在不破坏原有系统的情况下, 优雅地集成新功能。**

掌握适配器模式, 你就能在“接口不兼容”的战场上所向披靡！

## 代码

```
// Target.h - 客户端期望的接口
#pragma once
#include <string>
#include <iostream>

// 目标接口: 统一支付接口
class IPayment {
public:
    virtual ~IPayment() = default;
    virtual bool pay(double amount, const std::string& orderId) = 0;
    virtual std::string getName() const = 0;
};

// ==============================
// Adaptee: 微信支付(第三方库, 不能改)
class WeChatPaySDK {
public:
    // 注意: 接口不兼容！参数顺序、类型、返回值都不同
    int makePayment(const std::string& tradeNo, float price) {
        std::cout << "[WeChatPay] Paying " << price << " for order " << tradeNo << std::endl;
        return 0; // 0=success
    }
};

// ==============================
// Adaptee: 支付宝(第三方库, 不能改)
class AliPaySDK {
public:
    // 接口又不一样！
    bool doPay(float money, const char* orderNum) {
        std::cout << "[AliPay] Paying " << money << " for order " << orderNum << std::endl;
        return true; // true=success
    }
};

// ==============================
// 对象适配器: 微信支付适配器(推荐方式)
class WeChatPayAdapter : public IPayment {
private:
    WeChatPaySDK wechat; // 组合

public:
    bool pay(double amount, const std::string& orderId) override {
        int result = wechat.makePayment(orderId, static_cast<float>(amount));
        return result == 0;
    }

    std::string getName() const override {
        return "WeChat Pay";
    }
};

// ==============================
// 对象适配器: 支付宝适配器
class AliPayAdapter : public IPayment {
private:
    AliPaySDK alipay; // 组合

public:
    bool pay(double amount, const std::string& orderId) override {
        bool result = alipay.doPay(static_cast<float>(amount), orderId.c_str());
        return result;
    }

    std::string getName() const override {
        return "AliPay";
    }
};

// ==============================
// 客户端代码
#include "Target.h"

class PaymentProcessor {
public:
    static void processPayment(IPayment& payment, double amount, const std::string& orderId) {
        std::cout << "Processing payment via " << payment.getName() << "...\n";
        if (payment.pay(amount, orderId)) {
            std::cout << "✅ Payment successful!\n\n";
        } else {
            std::cout << "❌ Payment failed!\n\n";
        }
    }
};

// main.cpp
int main() {
    WeChatPayAdapter wechatAdapter;
    AliPayAdapter aliAdapter;

    PaymentProcessor::processPayment(wechatAdapter, 99.9, "ORDER_12345");
    PaymentProcessor::processPayment(aliAdapter, 199.5, "ORDER_67890");

    return 0;
}
```

✅ 进阶: 带工厂的动态适配器

```
class PaymentAdapterFactory {
public:
    static std::unique_ptr<IPayment> create(const std::string& type) {
        if (type == "wechat") return std::make_unique<WeChatPayAdapter>();
        if (type == "alipay") return std::make_unique<AliPayAdapter>();
        throw std::invalid_argument("Unsupported payment type: " + type);
    }
};

// 使用: 
auto payment = PaymentAdapterFactory::create("wechat");
PaymentProcessor::processPayment(*payment, 50.0, "DYNAMIC_ORDER");
```

## PlantUML

```
@startuml

' 目标接口
interface IPayment {
    +pay(amount: double, orderId: string) : bool
    +getName() : string
}

' 被适配者(微信)
class WeChatPaySDK {
    +makePayment(tradeNo: string, price: float) : int
}

' 被适配者(支付宝)
class AliPaySDK {
    +doPay(money: float, orderNum: char*) : bool
}

' 适配器(对象适配器 - 推荐)
class WeChatPayAdapter {
    -wechat: WeChatPaySDK
    +pay(amount: double, orderId: string) : bool
    +getName() : string
}

class AliPayAdapter {
    -alipay: AliPaySDK
    +pay(amount: double, orderId: string) : bool
    +getName() : string
}

' 客户端
class PaymentProcessor {
    +{static} processPayment(payment: IPayment&, amount: double, orderId: string)
}

' 关系
WeChatPayAdapter ..|> IPayment
AliPayAdapter ..|> IPayment

WeChatPayAdapter *-- WeChatPaySDK : adapts
AliPayAdapter *-- AliPaySDK : adapts

PaymentProcessor --> IPayment : uses

note right of WeChatPayAdapter
    Object Adapter (Composition)
    Recommended in modern C++
end note

note right of AliPayAdapter
    Converts AliPaySDK interface
    to IPayment interface.
end note

@enduml
```

![](./picture/7.AdapterPattern.png)

# 10. 桥接模式

## 简介

> **桥接模式(Bridge Pattern)** 是一种**结构型设计模式**, 它将**抽象部分与实现部分分离**, 使它们可以**独立变化**。

🎯 核心思想: 

- “抽象” 与 “实现” 解耦 → 用**组合代替继承**
- 抽象层持有一个“实现层”的引用(指针)
- 两者可独立扩展, 避免“类爆炸”

> 💡 桥接 = “抽象” 与 “实现” 之间的桥梁 → 动态绑定, 运行时切换实现。

📌 **经典比喻: **

> 电视(抽象)和遥控器(实现)—— 同一个遥控器可以控制不同品牌电视, 同一电视也可配不同遥控器。

🧩 结构组成: 

| 角色                  | 说明                                             |
| --------------------- | ------------------------------------------------ |
| `Abstraction`         | 抽象类, 定义高层控制接口, 持有一个 `Implementor` |
| `RefinedAbstraction`  | 扩展抽象(可选), 如不同形状、不同设备           |
| `Implementor`         | 实现接口, 定义底层操作(如绘制、驱动)           |
| `ConcreteImplementor` | 具体实现, 如 OpenGL、DirectX、Vulkan 渲染器      |

✅ 适用场景

1. **你不希望在抽象和实现之间有固定的绑定关系(继承太死板)**
2. **抽象及其实现都应可通过子类化独立扩展**
3. **对抽象的实现修改不应影响客户端代码**
4. **你想在运行时切换实现(如切换渲染后端、数据库驱动)**
5. **避免“多维度继承”导致的类爆炸(如 Shape × Color × Renderer = N×M×K 个类)**

📌 **典型应用场景: **

- 图形库: Shape(抽象) + Renderer(实现: OpenGL/DirectX/Vulkan)
- 跨平台 UI: Button(抽象) + PlatformImpl(Win/Mac/Linux)
- 数据库驱动: DAO(抽象) + DriverImpl(MySQL/PostgreSQL/SQLite)
- 游戏引擎: GameObject(抽象) + PhysicsEngine(Box2D/Bullet)
- 遥控设备: TV(抽象) + RemoteControl(红外/蓝牙/WiFi)

✅ 优缺点

✅ 优点: 

1. **分离抽象与实现** → 两者可独立扩展, 符合单一职责原则。
2. **避免类爆炸** → N 个抽象 × M 个实现 = N+M 个类, 而不是 N×M。
3. **运行时切换实现** → 灵活, 如切换图形 API、数据库后端。
4. **提高可扩展性** → 新增实现不影响抽象层, 反之亦然。
5. **隐藏实现细节** → 客户端只与抽象层交互。

❌ 缺点: 

1. **增加系统复杂度** → 引入额外层次。
2. **客户端需理解“桥接”概念** → 初学者可能困惑。
3. **仅适用于“抽象-实现”可分离的场景** → 不是万能。

🎯 **推荐语: **

> **桥接模式是解决“多维度变化”问题的利器。当你发现类在多个维度上扩展导致子类爆炸时, 桥接模式就是你的救星！**

掌握桥接模式, 你就能设计出高度灵活、易于扩展的系统架构！

## 代码

```
// Bridge.h
#include <iostream>
#include <memory>
#include <string>

// ============ 实现层 ============
// 抽象实现接口
class Renderer {
public:
    virtual ~Renderer() = default;
    virtual void render(const std::string& shapeType, const std::string& info) = 0;
};

// 具体实现: OpenGL
class OpenGLRenderer : public Renderer {
public:
    void render(const std::string& shapeType, const std::string& info) override {
        std::cout << "[OpenGL] Rendering " << shapeType << ": " << info << std::endl;
    }
};

// 具体实现: DirectX
class DirectXRenderer : public Renderer {
public:
    void render(const std::string& shapeType, const std::string& info) override {
        std::cout << "[DirectX] Drawing " << shapeType << " -> " << info << std::endl;
    }
};

// 具体实现: Vulkan
class VulkanRenderer : public Renderer {
public:
    void render(const std::string& shapeType, const std::string& info) override {
        std::cout << "[Vulkan] 🚀 Ultra-fast rendering of " << shapeType << " (" << info << ")" << std::endl;
    }
};

// ============ 抽象层 ============
// 抽象图形
class Shape {
protected:
    std::unique_ptr<Renderer> renderer; // 桥接核心: 组合而非继承

public:
    Shape(std::unique_ptr<Renderer> r) : renderer(std::move(r)) {}

    virtual ~Shape() = default;

    // 设置渲染器(运行时切换)
    void setRenderer(std::unique_ptr<Renderer> r) {
        renderer = std::move(r);
    }

    virtual void draw() = 0;
    virtual std::string getInfo() const = 0;
    virtual std::string getType() const = 0;
};

// 具体抽象: 圆形
class Circle : public Shape {
private:
    double radius;
    std::string position;

public:
    Circle(double r, const std::string& pos, std::unique_ptr<Renderer> r)
        : Shape(std::move(r)), radius(r), position(pos) {}

    void draw() override {
        if (renderer) {
            renderer->render(getType(), getInfo());
        }
    }

    std::string getInfo() const override {
        return "Radius=" + std::to_string(radius) + ", Pos=" + position;
    }

    std::string getType() const override {
        return "Circle";
    }
};

// 具体抽象: 矩形
class Rectangle : public Shape {
private:
    double width, height;
    std::string position;

public:
    Rectangle(double w, double h, const std::string& pos, std::unique_ptr<Renderer> r)
        : Shape(std::move(r)), width(w), height(h), position(pos) {}

    void draw() override {
        if (renderer) {
            renderer->render(getType(), getInfo());
        }
    }

    std::string getInfo() const override {
        return "W=" + std::to_string(width) + ", H=" + std::to_string(height) + ", Pos=" + position;
    }

    std::string getType() const override {
        return "Rectangle";
    }
};

// 客户端
int main() {
    std::cout << "=== 桥接模式示例: 图形 + 渲染器 ===\n\n";

    // 创建不同渲染器
    auto opengl = std::make_unique<OpenGLRenderer>();
    auto directx = std::make_unique<DirectXRenderer>();
    auto vulkan = std::make_unique<VulkanRenderer>();

    // 创建图形对象, 绑定渲染器
    Circle circle(5.0, "(10,20)", std::make_unique<OpenGLRenderer>());
    Rectangle rect(10.0, 8.0, "(30,40)", std::make_unique<DirectXRenderer>());

    // 绘制
    circle.draw();
    rect.draw();

    std::cout << "\n=== 运行时切换渲染器 ===\n";
    circle.setRenderer(std::make_unique<VulkanRenderer>());
    circle.draw();

    rect.setRenderer(std::make_unique<OpenGLRenderer>());
    rect.draw();

    return 0;
}
```

✅ 进阶: 带工厂的动态桥接

```
class RendererFactory {
public:
    static std::unique_ptr<Renderer> create(const std::string& type) {
        if (type == "opengl") return std::make_unique<OpenGLRenderer>();
        if (type == "directx") return std::make_unique<DirectXRenderer>();
        if (type == "vulkan") return std::make_unique<VulkanRenderer>();
        throw std::invalid_argument("Unknown renderer: " + type);
    }
};

// 使用: 
auto circle = std::make_unique<Circle>(5.0, "(0,0)", RendererFactory::create("vulkan"));
```

## PlantUML

```
@startuml

' 抽象实现接口
interface Renderer {
    +render(shapeType: string, info: string) : void
}

' 具体实现
class OpenGLRenderer {
    +render(shapeType: string, info: string) : void
}

class DirectXRenderer {
    +render(shapeType: string, info: string) : void
}

class VulkanRenderer {
    +render(shapeType: string, info: string) : void
}

' 抽象层
abstract class Shape {
    -renderer: unique_ptr<Renderer>
    +setRenderer(r: unique_ptr<Renderer>)
    +draw() : void {abstract}
    +getInfo() : string {abstract}
    +getType() : string {abstract}
}

' 具体抽象
class Circle {
    -radius: double
    -position: string
    +draw()
    +getInfo() : string
    +getType() : string
}

class Rectangle {
    -width: double
    -height: double
    -position: string
    +draw()
    +getInfo() : string
    +getType() : string
}

' 关系
Shape *-- Renderer : "has a (bridge)"

Renderer <|.. OpenGLRenderer
Renderer <|.. DirectXRenderer
Renderer <|.. VulkanRenderer

Shape <|-- Circle
Shape <|-- Rectangle

note right of Shape
    Holds a reference to
    Renderer (composition).
    This is the BRIDGE.
end note

note bottom of Renderer
    Defines the implementation
    interface. Can be extended
    independently of Shape.
end note

@enduml
```

![](./picture/8.BridgePattern.png)

# 11. 组合模式

## 简介

> **组合模式(Composite Pattern)** 是一种**结构型设计模式**, 它**将对象组合成树形结构以表示“部分-整体”的层次结构**, 使得客户端对单个对象和组合对象的使用具有一致性。

🎯 核心思想: 

- **“部分-整体”统一接口** → 客户端无需区分叶子和容器
- 树形结构: 节点可以是叶子(Leaf)或容器(Composite)
- 递归组合 → 容器可包含叶子或其他容器

> 💡 经典比喻: 
>  **文件系统** —— 文件(叶子)和文件夹(容器)都可被“操作”, 如 `getSize()`、`display()`, 客户端无需关心是文件还是文件夹。

------

 🧩 结构组成: 

| 角色        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| `Component` | 抽象基类, 声明叶子和容器的公共接口(如 `display()`, `getSize()`) |
| `Leaf`      | 叶子节点, 实现 `Component` 接口, 无子节点                    |
| `Composite` | 容器节点, 聚合子节点(`Component*`), 实现相同接口, 内部递归调用子节点 |

------

 ✅ 适用场景

1. **你想表示对象的“部分-整体”层次结构(树形结构)**
2. **希望客户端忽略组合对象与单个对象的差异, 统一处理**
3. **结构在运行时动态变化(如添加/删除子节点)**
4. **需要递归遍历或操作整个结构**

📌 **典型应用场景: **

- 📁 **文件系统**: 文件 + 文件夹
- 🎨 **图形界面**: 控件 + 容器控件(如 GroupBox、Panel)
- 🎮 **游戏对象**: GameObject + 子对象(如角色 + 装备 + 技能)
- 📊 **组织架构**: 员工 + 部门(部门可包含子部门)
- 📜 **XML/HTML DOM 树**: 节点 + 子节点

------

 ✅ 优缺点

 ✅ 优点: 

1. **定义了包含简单对象和复合对象的类层次结构** → 客户端统一处理
2. **简化客户端代码** → 无需判断是叶子还是容器
3. **更容易增加新类型的组件** → 符合开闭原则
4. **支持递归结构** → 天然适合树形数据

 ❌ 缺点: 

1. **设计更复杂** → 需要定义公共接口, 可能包含叶子不需要的方法
2. **类型系统限制** → 某些操作只对容器有意义(如 `addChild`), 叶子调用会出错
3. **可能违反接口隔离原则** → 叶子被迫实现无意义的方法

------

 ✅ 注意事项

 1. 🔄 两种设计风格: 

| 类型                 | 说明                                                       | 优点                         | 缺点                                         |
| -------------------- | ---------------------------------------------------------- | ---------------------------- | -------------------------------------------- |
| **透明方式(推荐)** | `Component` 声明所有方法(包括 `addChild`, `removeChild`) | 客户端完全统一, 无需类型判断 | 叶子需抛异常或空实现无意义方法               |
| **安全方式**         | 只在 `Composite` 中声明管理子节点的方法                    | 类型安全, 编译期检查         | 客户端需 `dynamic_cast` 判断类型, 破坏透明性 |

> ✅ **现代 C++ 推荐“透明方式” + 运行时异常/空操作**, 保持接口一致性。

------

 2. ⚠️ 叶子节点对容器方法的处理: 

```
// 透明方式 - Leaf 实现但抛异常
void addChild(std::unique_ptr<Component>) override {
    throw std::logic_error("Cannot add child to a leaf!");
}

// 或者空实现(静默失败, 不推荐)
void addChild(std::unique_ptr<Component>) override {}
```

> 🚨 **建议抛异常**, 避免静默失败导致调试困难。

------

 3. 🧹 内存管理建议: 

- 使用 `std::unique_ptr<Component>` 管理子节点生命周期
- Composite 析构时自动释放所有子节点
- 避免裸指针和手动 `delete`

------

 4. 🔄 递归操作注意栈溢出

- 超深树结构可能导致栈溢出 → 可改用迭代 + 栈模拟
- 通常业务场景深度有限, 无需过度担心

------

 5. 🧩 可选: 提供迭代器支持

```
class Composite : public Component {
    std::vector<std::unique_ptr<Component>> children;
public:
    using Iterator = decltype(children)::iterator;
    Iterator begin() { return children.begin(); }
    Iterator end() { return children.end(); }
};
```

🎯 **推荐语: **

> **当你需要处理树形结构(如文件系统、UI 控件树、组织架构)时, 组合模式是你最佳选择。它让复杂结构的操作变得简单而优雅！**

掌握组合模式, 你就能轻松驾驭任何“部分-整体”层次结构！

## 代码

```
// Composite.h
#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <stdexcept>

// ============ 抽象组件 ============
class FileSystemComponent {
public:
    virtual ~FileSystemComponent() = default;

    // 通用操作(透明方式)
    virtual void display(const std::string& prefix = "") const = 0;
    virtual size_t getSize() const = 0;
    virtual std::string getName() const = 0;

    // 容器操作(叶子需实现但抛异常)
    virtual void addChild(std::unique_ptr<FileSystemComponent> child) {
        throw std::logic_error("Cannot add child to a leaf node: " + getName());
    }

    virtual void removeChild(const std::string& name) {
        throw std::logic_error("Cannot remove child from a leaf node: " + getName());
    }

    virtual FileSystemComponent* getChild(const std::string& name) {
        throw std::logic_error("Leaf node has no children: " + getName());
    }
};

// ============ 叶子节点: 文件 ============
class File : public FileSystemComponent {
private:
    std::string name;
    size_t size;

public:
    File(const std::string& n, size_t s) : name(n), size(s) {}

    void display(const std::string& prefix = "") const override {
        std::cout << prefix << "📄 " << name << " (" << size << " KB)" << std::endl;
    }

    size_t getSize() const override {
        return size;
    }

    std::string getName() const override {
        return name;
    }
};

// ============ 容器节点: 目录 ============
class Directory : public FileSystemComponent {
private:
    std::string name;
    std::vector<std::unique_ptr<FileSystemComponent>> children;

public:
    Directory(const std::string& n) : name(n) {}

    void display(const std::string& prefix = "") const override {
        std::cout << prefix << "📁 " << name << "/" << std::endl;
        for (const auto& child : children) {
            child->display(prefix + "  "); // 递归显示
        }
    }

    size_t getSize() const override {
        size_t total = 0;
        for (const auto& child : children) {
            total += child->getSize(); // 递归计算
        }
        return total;
    }

    std::string getName() const override {
        return name;
    }

    // 容器特有操作
    void addChild(std::unique_ptr<FileSystemComponent> child) override {
        children.push_back(std::move(child));
    }

    void removeChild(const std::string& name) override {
        auto it = std::remove_if(children.begin(), children.end(),
            [&name](const std::unique_ptr<FileSystemComponent>& child) {
                return child->getName() == name;
            });
        if (it != children.end()) {
            children.erase(it, children.end());
        } else {
            throw std::runtime_error("Child not found: " + name);
        }
    }

    FileSystemComponent* getChild(const std::string& name) override {
        for (auto& child : children) {
            if (child->getName() == name) {
                return child.get();
            }
        }
        return nullptr;
    }
};

// ============ 客户端使用 ============
#include "Composite.h"

int main() {
    std::cout << "=== 组合模式: 文件系统模拟 ===\n\n";

    // 创建根目录
    auto root = std::make_unique<Directory>("root");

    // 添加文件
    root->addChild(std::make_unique<File>("readme.txt", 2));
    root->addChild(std::make_unique<File>("config.json", 1));

    // 创建子目录
    auto docs = std::make_unique<Directory>("documents");
    docs->addChild(std::make_unique<File>("report.pdf", 5000));
    docs->addChild(std::make_unique<File>("notes.txt", 100));

    auto pics = std::make_unique<Directory>("pictures");
    pics->addChild(std::make_unique<File>("photo1.jpg", 3000));
    pics->addChild(std::make_unique<File>("photo2.png", 2500));

    // 将子目录加入根目录
    root->addChild(std::move(docs));
    root->addChild(std::move(pics));

    // 显示整个文件树
    root->display();

    // 计算总大小
    std::cout << "\nTotal size: " << root->getSize() << " KB" << std::endl;

    // 尝试对叶子调用容器方法(应抛异常)
    std::cout << "\n=== 测试叶子节点异常 ===\n";
    auto file = std::make_unique<File>("test.txt", 10);
    try {
        file->addChild(std::make_unique<File>("invalid.txt", 0));
    } catch (const std::exception& e) {
        std::cout << "✅ Caught expected exception: " << e.what() << std::endl;
    }

    return 0;
}
```



## PlantUML

```
@startuml

' 抽象组件(透明方式)
abstract class FileSystemComponent {
    +display(prefix: string) : void {abstract}
    +getSize() : size_t {abstract}
    +getName() : string {abstract}
    +addChild(child: unique_ptr<FileSystemComponent>) : void
    +removeChild(name: string) : void
    +getChild(name: string) : FileSystemComponent*
}

' 叶子节点
class File {
    -name: string
    -size: size_t
    +display(prefix: string) : void
    +getSize() : size_t
    +getName() : string
    +addChild(...) {throws}
    +removeChild(...) {throws}
    +getChild(...) {throws}
}

' 容器节点
class Directory {
    -name: string
    -children: vector<unique_ptr<FileSystemComponent>>
    +display(prefix: string) : void
    +getSize() : size_t
    +getName() : string
    +addChild(child: unique_ptr<FileSystemComponent>) : void
    +removeChild(name: string) : void
    +getChild(name: string) : FileSystemComponent*
}

' 关系
FileSystemComponent <|-- File
FileSystemComponent <|-- Directory

note right of FileSystemComponent
    Transparent Composite:
    Declares all operations,
    Leaf throws on container methods.
end note

note bottom of Directory
    Manages child components
    recursively. Uses composition.
end note

@enduml
```

![](./picture/9.CompositePattern.png)

# 12.装饰器模式

## 简介

> **装饰器模式(Decorator Pattern)** 是一种**结构型设计模式**, 它**动态地给一个对象添加一些额外的职责(功能)**, 就增加功能来说, 装饰器模式相比生成子类更为灵活。

 🎯 核心思想: 

- **“套娃式”增强功能** —— 一层套一层, 每层添加新功能
- **继承是静态的, 装饰是动态的**
- **符合开闭原则** —— 对扩展开放, 对修改关闭

> 💡 经典比喻: 
>  **咖啡 + 配料** —— 基础咖啡(Espresso)可动态添加“牛奶”、“糖”、“巧克力”等装饰, 每加一层, 价格和描述都变化, 但仍然是“一杯咖啡”。

------

 🧩 结构组成: 

| 角色                | 说明                                                        |
| ------------------- | ----------------------------------------------------------- |
| `Component`         | 抽象组件, 定义对象接口(如 `cost()`, `getDescription()`)   |
| `ConcreteComponent` | 具体组件, 被装饰的原始对象                                  |
| `Decorator`         | 抽象装饰器, 继承 `Component`, 持有一个 `Component*`(组合) |
| `ConcreteDecorator` | 具体装饰器, 实现额外功能, 调用被装饰对象的方法并增强        |

------

 ✅ 适用场景

1. **需要在运行时动态、透明地给对象添加职责**
2. **扩展功能的方案有很多, 用继承会导致子类爆炸**
3. **职责可以“叠加”, 且顺序可能影响结果(如加密+压缩 vs 压缩+加密)**
4. **不希望修改原始类代码(如第三方库)**

📌 **典型应用场景: **

- ☕ **咖啡/饮料系统**: 基础饮品 + 各种配料(糖、奶、摩卡)
- 💾 **I/O 流增强**: `std::ostream` → 添加压缩、加密、日志功能
- 🎮 **游戏道具系统**: 基础武器 + 附魔(火焰、冰霜、吸血)
- 🧱 **GUI 控件装饰**: 基础按钮 + 边框装饰、滚动装饰、透明度装饰
- 📦 **网络请求中间件**: 基础请求 + 日志、重试、缓存、认证装饰器

------

 ✅ 优缺点

 ✅ 优点: 

1. **比继承更灵活** → 运行时动态组合功能
2. **避免类爆炸** → N 个功能组合 = N 个装饰器类, 而不是 2^N 个子类
3. **符合开闭原则** → 新增功能不修改原有代码
4. **可叠加、可嵌套** → 功能自由组合
5. **单一职责原则** → 每个装饰器只负责一个增强功能

 ❌ 缺点: 

1. **产生很多小对象** → 调试时调用栈较深
2. **过度使用会让系统复杂** → “套娃地狱”
3. **删除装饰器较困难** → 通常需重建对象链
4. **配置复杂对象时代码冗长** → 可结合 Builder 模式优化

------

 ✅ 注意事项

 1. 🔄 装饰器必须实现与组件相同的接口

```
class Decorator : public Component { ... };
```

> ✅ 客户端无需知道是否被装饰 → 透明性

------

 2. ⚠️ 装饰器持有组件的指针/引用(组合)

```
class MilkDecorator : public Beverage {
    std::unique_ptr<Beverage> beverage; // 关键: 组合而非继承功能
public:
    MilkDecorator(std::unique_ptr<Beverage> b) : beverage(std::move(b)) {}
    double cost() override { return beverage->cost() + 0.5; }
};
```

3. 🚫 装饰器 ≠ 继承/适配器/代理

4. ✅ 推荐使用智能指针管理组件生命周期

5. ✅ 装饰顺序可能影响结果

```
auto coffee = std::make_unique<Espresso>();
auto withMilk = std::make_unique<MilkDecorator>(std::move(coffee));
auto withSugar = std::make_unique<SugarDecorator>(std::move(withMilk));

// vs

auto coffee2 = std::make_unique<Espresso>();
auto withSugar2 = std::make_unique<SugarDecorator>(std::move(coffee2));
auto withMilk2 = std::make_unique<MilkDecorator>(std::move(withSugar2));
```

🎯 **推荐语: **

> **装饰器模式是解决“功能动态组合”问题的优雅方案。当你厌倦了继承导致的类爆炸, 装饰器模式就是你的救星！**

掌握装饰器模式, 你就能设计出高度灵活、可扩展、可组合的系统！

## 代码

```
// Decorator.h
#include <iostream>
#include <string>
#include <memory>

// ============ 抽象组件 ============
class Beverage {
public:
    virtual ~Beverage() = default;
    virtual double cost() const = 0;
    virtual std::string getDescription() const = 0;
};

// ============ 具体组件 ============
class Espresso : public Beverage {
public:
    double cost() const override {
        return 1.99;
    }

    std::string getDescription() const override {
        return "Espresso";
    }
};

class HouseBlend : public Beverage {
public:
    double cost() const override {
        return 0.89;
    }

    std::string getDescription() const override {
        return "House Blend Coffee";
    }
};

// ============ 抽象装饰器 ============
class CondimentDecorator : public Beverage {
protected:
    std::unique_ptr<Beverage> beverage;

public:
    CondimentDecorator(std::unique_ptr<Beverage> b) : beverage(std::move(b)) {}
    virtual ~CondimentDecorator() = default;
};

// ============ 具体装饰器 ============
class Milk : public CondimentDecorator {
public:
    Milk(std::unique_ptr<Beverage> b) : CondimentDecorator(std::move(b)) {}

    double cost() const override {
        return beverage->cost() + 0.10;
    }

    std::string getDescription() const override {
        return beverage->getDescription() + ", Milk";
    }
};

class Mocha : public CondimentDecorator {
public:
    Mocha(std::unique_ptr<Beverage> b) : CondimentDecorator(std::move(b)) {}

    double cost() const override {
        return beverage->cost() + 0.20;
    }

    std::string getDescription() const override {
        return beverage->getDescription() + ", Mocha";
    }
};

class Whip : public CondimentDecorator {
public:
    Whip(std::unique_ptr<Beverage> b) : CondimentDecorator(std::move(b)) {}

    double cost() const override {
        return beverage->cost() + 0.15;
    }

    std::string getDescription() const override {
        return beverage->getDescription() + ", Whip";
    }
};

// ============ 客户端 ============
#include "Decorator.h"

void printBeverage(const Beverage& b) {
    std::cout << b.getDescription() << " $" << b.cost() << std::endl;
}

int main() {
    std::cout << "=== 装饰器模式: 咖啡订单系统 ===\n\n";

    // 基础咖啡
    auto espresso = std::make_unique<Espresso>();
    printBeverage(*espresso);

    // 装饰: 加摩卡 + 打奶泡
    auto espressoWithMochaWhip = std::make_unique<Whip>(
        std::make_unique<Mocha>(std::move(espresso))
    );
    printBeverage(*espressoWithMochaWhip);

    // 另一杯: 混合咖啡 + 牛奶 + 摩卡 + 牛奶
    auto houseBlend = std::make_unique<HouseBlend>();
    auto fancyCoffee = std::make_unique<Milk>(
        std::make_unique<Mocha>(
            std::make_unique<Milk>(std::move(houseBlend))
        )
    );
    printBeverage(*fancyCoffee);

    return 0;
}
```

## PlantUML

```
@startuml

' 抽象组件
abstract class Beverage {
    +cost() : double {abstract}
    +getDescription() : string {abstract}
}

' 具体组件
class Espresso {
    +cost() : double
    +getDescription() : string
}

class HouseBlend {
    +cost() : double
    +getDescription() : string
}

' 抽象装饰器
abstract class CondimentDecorator {
    -beverage: unique_ptr<Beverage>
    +cost() : double {abstract}
    +getDescription() : string {abstract}
}

' 具体装饰器
class Milk {
    +cost() : double
    +getDescription() : string
}

class Mocha {
    +cost() : double
    +getDescription() : string
}

class Whip {
    +cost() : double
    +getDescription() : string
}

' 关系
Beverage <|-- Espresso
Beverage <|-- HouseBlend
Beverage <|-- CondimentDecorator

CondimentDecorator <|-- Milk
CondimentDecorator <|-- Mocha
CondimentDecorator <|-- Whip

CondimentDecorator *-- Beverage : "wraps"

note right of CondimentDecorator
    Holds a reference to
    a Beverage (composition).
    This is the DECORATOR core.
end note

note bottom of Milk
    Adds milk cost and
    description to any Beverage.
end note

@enduml
```

![](./picture/10.DecoratorPattern.png)





# 13. 外观模式

## 简介

> **外观模式(Facade Pattern)** 是一种**结构型设计模式**, 它**为子系统中的一组接口提供一个一致的、简化的高层接口**, 使得子系统更容易使用。

 🎯 核心思想: 

- **“封装复杂性, 提供简单门面”**
- **客户端无需了解子系统内部结构**
- **降低耦合, 统一入口**

> 💡 经典比喻: 
>  **酒店前台** —— 客人只需告诉前台“我要入住”, 前台会协调客房部、清洁部、安保部等多个部门完成入住流程, 客人无需与每个部门打交道。

------

 🧩 结构组成: 

| 角色                | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| `Subsystem Classes` | 子系统中的多个复杂类(如 `Light`, `Thermostat`, `Security`) |
| `Facade`            | 外观类, 封装子系统调用, 提供简化接口(如 `turnOnHome()`, `turnOffHome()`) |
| `Client`            | 客户端, 只与 `Facade` 交互, 不直接访问子系统                 |

> 📌 **关键点: **
>  Facade **不封装新功能**, 只是**组合和简化已有功能的调用流程**。

------

 ✅ 适用场景

1. **子系统复杂, 接口众多, 使用困难**
2. **客户端与子系统之间存在过多直接依赖**
3. **需要为子系统提供一个统一、简化的访问入口**
4. **分层架构中, 上层模块需要简化对下层模块的调用**

📌 **典型应用场景: **

- 🏠 **智能家居系统**: 一键“回家模式” → 开灯 + 调温 + 解除警报
- 🛠️ **编译器子系统**: `compile()` → 词法分析 + 语法分析 + 代码生成
- 📦 **API 封装库**: 封装复杂的第三方库(如 OpenGL、FFmpeg)提供简单接口
- 🏦 **银行系统**: `applyLoan()` → 信用检查 + 风控审核 + 合同生成 + 放款
- 🎮 **游戏引擎启动**: `startGame()` → 加载资源 + 初始化音频 + 启动物理引擎 + 显示主菜单

------

 ✅ 优缺点

 ✅ 优点: 

1. **简化客户端使用** → 隐藏子系统复杂性
2. **降低耦合度** → 客户端只依赖外观, 不依赖具体子系统
3. **提高可维护性** → 子系统变化不影响客户端(只要外观接口不变)
4. **符合迪米特法则(最少知识原则)** → 客户端只需知道外观
5. **便于分层设计** → 每层可提供自己的外观

 ❌ 缺点: 

1. **不符合开闭原则** → 新增子系统功能可能需要修改外观类
2. **可能成为“上帝类”** → 如果外观承担过多职责, 会变得臃肿
3. **灵活性受限** → 客户端无法精细控制子系统(除非提供“逃生舱口”)

------

 ✅ 注意事项

 1. 🔄 外观 ≠ 封装所有功能

> 外观应提供**常用、高层**操作, 不是替代子系统。
>  应允许客户端在必要时**绕过外观**直接访问子系统(“逃生舱口”设计)。


```
class HomeFacade {
    LightSystem light;
    ACSystem ac;
public:
    void turnOnHome() { ... } // 简化接口

    // 逃生舱口: 允许直接访问子系统
    LightSystem& getLightSystem() { return light; }
};
```

------

 2. 🚫 外观 ≠ 适配器

| 模式   | 目的                     |
| ------ | ------------------------ |
| 外观   | **简化接口, 封装复杂性** |
| 适配器 | **转换接口, 兼容不匹配** |

> 💡 **外观 = “简化操作”, 适配器 = “接口翻译”**

------

 3. 🚫 外观 ≠ 中介者

| 模式   | 目的                     | 交互方式                     |
| ------ | ------------------------ | ---------------------------- |
| 外观   | **封装子系统, 单向调用** | Client → Facade → Subsystems |
| 中介者 | **协调对象间交互**       | Objects ↔ Mediator ↔ Objects |

> 💡 **外观是“门面”, 中介者是“调度中心”**

------

 4. ✅ 外观类应尽量保持无状态或轻状态

> 避免外观类承担业务逻辑或状态管理, 它只是“协调者”。

------

 5. ✅ 可设计多层外观(Layered Facade)

```
class LowLevelFacade { ... };     // 封装硬件驱动
class MidLevelFacade { ... };     // 封装业务逻辑
class HighLevelFacade { ... };    // 封装用户操作
```

------

 6. ✅ 外观类可被多个客户端共享

> 通常设计为无状态或使用依赖注入, 可安全共享。

 ✅ 一句话总结: 

> **“你只管说‘我要回家’, 剩下的交给我来协调！”**

🎯 **推荐语: **

> **外观模式是降低系统复杂度的利器。无论是封装第三方库、简化内部模块调用, 还是提供用户友好接口, 外观模式都能让你的代码更清晰、更易用！**

掌握外观模式, 你就掌握了“化繁为简”的架构艺术！

## 代码

```
// Facade.h
#include <iostream>
#include <string>

// ============ 子系统类 ============
class LightSystem {
public:
    void turnOn() { std::cout << "💡 Lights ON\n"; }
    void turnOff() { std::cout << "💡 Lights OFF\n"; }
    void setBrightness(int level) { std::cout << "🔆 Brightness set to " << level << "%\n"; }
};

class ACSystem {
public:
    void turnOn() { std::cout << "❄️ AC ON\n"; }
    void turnOff() { std::cout << "❄️ AC OFF\n"; }
    void setTemperature(int temp) { std::cout << "🌡️ Temperature set to " << temp << "°C\n"; }
};

class SecuritySystem {
public:
    void arm() { std::cout << "🔒 Security System ARMED\n"; }
    void disarm() { std::cout << "🔓 Security System DISARMED\n"; }
    void triggerAlarm() { std::cout << "🚨 ALARM TRIGGERED!\n"; }
};

class EntertainmentSystem {
public:
    void turnOnTV() { std::cout << "📺 TV ON\n"; }
    void turnOffTV() { std::cout << "📺 TV OFF\n"; }
    void playMusic() { std::cout << "🎵 Playing relaxing music...\n"; }
};

// ============ 外观类 ============
class HomeFacade {
private:
    LightSystem light;
    ACSystem ac;
    SecuritySystem security;
    EntertainmentSystem entertainment;

public:
    // 一键回家模式
    void activateHomeMode() {
        std::cout << "\n=== 🏠 Activating HOME Mode ===\n";
        security.disarm();
        light.turnOn();
        light.setBrightness(80);
        ac.turnOn();
        ac.setTemperature(24);
        entertainment.turnOnTV();
        entertainment.playMusic();
    }

    // 一键离家模式
    void activateAwayMode() {
        std::cout << "\n=== 🚪 Activating AWAY Mode ===\n";
        light.turnOff();
        ac.turnOff();
        entertainment.turnOffTV();
        security.arm();
    }

    // 一键睡眠模式
    void activateSleepMode() {
        std::cout << "\n=== 😴 Activating SLEEP Mode ===\n";
        light.setBrightness(10);
        ac.setTemperature(26);
        entertainment.turnOffTV();
    }

    // 逃生舱口: 允许直接访问子系统
    LightSystem& getLightSystem() { return light; }
    ACSystem& getACSystem() { return ac; }
};

// ============ 客户端使用 ============
#include "Facade.h"

int main() {
    std::cout << "=== 外观模式: 智能家居系统 ===\n";

    HomeFacade home;

    // 用户只需操作外观, 无需了解子系统细节
    home.activateHomeMode();
    home.activateSleepMode();
    home.activateAwayMode();

    // 特殊需求: 直接调用子系统(逃生舱口)
    std::cout << "\n=== 特殊操作: 直接调光 ===\n";
    home.getLightSystem().setBrightness(50);

    return 0;
}
```

输出

```
=== 外观模式: 智能家居系统 ===

=== 🏠 Activating HOME Mode ===
🔓 Security System DISARMED
💡 Lights ON
🔆 Brightness set to 80%
❄️ AC ON
🌡️ Temperature set to 24°C
📺 TV ON
🎵 Playing relaxing music...

=== 😴 Activating SLEEP Mode ===
🔆 Brightness set to 10%
🌡️ Temperature set to 26°C
📺 TV OFF

=== 🚪 Activating AWAY Mode ===
💡 Lights OFF
❄️ AC OFF
📺 TV OFF
🔒 Security System ARMED

=== 特殊操作: 直接调光 ===
🔆 Brightness set to 50%
```



## PlantUML

```
@startuml

' 子系统类
class LightSystem {
    +turnOn()
    +turnOff()
    +setBrightness(level)
}

class ACSystem {
    +turnOn()
    +turnOff()
    +setTemperature(temp)
}

class SecuritySystem {
    +arm()
    +disarm()
    +triggerAlarm()
}

class EntertainmentSystem {
    +turnOnTV()
    +turnOffTV()
    +playMusic()
}

' 外观类
class HomeFacade {
    -light: LightSystem
    -ac: ACSystem
    -security: SecuritySystem
    -entertainment: EntertainmentSystem
    +activateHomeMode()
    +activateAwayMode()
    +activateSleepMode()
    +getLightSystem() : LightSystem&
}

' 客户端
class Client {
    +main()
}

' 关系
Client --> HomeFacade : uses
HomeFacade --> LightSystem : uses
HomeFacade --> ACSystem : uses
HomeFacade --> SecuritySystem : uses
HomeFacade --> EntertainmentSystem : uses

note right of HomeFacade
    Provides simplified interface
    to complex subsystem.
    Follows "Facade Pattern".
end note

note bottom of Client
    Only interacts with Facade,
    not with subsystem classes.
end note

@enduml
```

![](./picture/11.FacadePattern.png)


# 14. 享元模式

## 简介

> **享元模式(Flyweight Pattern)** 是一种**结构型设计模式**, 它**通过共享技术, 有效地支持大量细粒度对象的复用**, 从而**减少内存占用和对象创建开销**。

 🎯 核心思想: 

- **“共享相同状态的对象, 避免重复创建”**
- **区分内部状态(可共享)和外部状态(不可共享)**
- **使用“享元工厂”管理共享对象池**

> 💡 经典比喻: 
>  **文字处理器中的字符对象** —— 字母 `'A'` 在文档中出现 1000 次, 但内存中只需创建一个 `'A'` 对象, 通过外部状态(位置、颜色、字体大小)来区分每次渲染。

------

 🧩 结构组成: 

| 角色                | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| `Flyweight`         | 抽象享元类, 定义接口(如 `render(x, y)`), 接受外部状态参数  |
| `ConcreteFlyweight` | 具体享元类, 存储**内部状态**(如字符、图片ID), 实现共享逻辑 |
| `FlyweightFactory`  | 享元工厂, 创建并管理享元对象池(通常用 `std::map` 或 `std::unordered_map`) |
| `Client`            | 客户端, 维护**外部状态**(如位置、颜色), 调用享元对象       |

> 📌 **关键概念: **
>
> - **内部状态(Intrinsic State)**: 存储在享元对象内部, 可共享(如字符、纹理ID)
> - **外部状态(Extrinsic State)**: 由客户端传入, 不可共享(如坐标、颜色、旋转角度)

------

 ✅ 适用场景

1. **程序中存在大量相似对象, 造成内存压力**
2. **对象大部分状态可以外部化(提取为参数)**
3. **对象可被缓存和复用**
4. **性能或内存是关键瓶颈**

📌 **典型应用场景: **

- 📝 **文字编辑器/排版系统**: 共享字符对象(如 1000 个 'A' → 1 个对象)

- 🎮

   

  游戏开发

  : 

  - 子弹、粒子、敌人类型(相同类型的对象共享纹理、模型)
  - 地图瓦片系统(相同地形共享贴图)

- 🖼️ **图形界面系统**: 图标、按钮样式共享

- 🧬 **生物信息学**: 共享 DNA 碱基对象(A, T, C, G)

- 📊 **数据可视化**: 共享柱状图、饼图的样式对象

------

 ✅ 优缺点

 ✅ 优点: 

1. **极大减少内存占用** → 共享对象, 避免重复创建
2. **提升性能** → 减少对象创建/销毁开销
3. **外部状态与内部状态分离** → 职责清晰
4. **适合大规模对象系统** → 如游戏、图形、文本处理

 ❌ 缺点: 

1. **代码复杂度增加** → 需管理对象池、区分内外状态
2. **外部状态需客户端维护** → 增加客户端负担
3. **线程安全问题** → 多线程访问工厂需加锁(C++ 中)
4. **调试困难** → 对象被多个客户端共享, 状态追踪复杂

------

 ✅ 注意事项

 1. 🔄 必须区分内部状态和外部状态


```
class CharacterFlyweight {
    char symbol; // 内部状态: 可共享(如 'A')
public:
    void render(int x, int y, Color color); // 外部状态: 位置、颜色由客户端传入
};
```

> ✅ 内部状态 = 对象本质属性(不变或极少变)
>  ✅ 外部状态 = 上下文相关属性(每次调用可能不同)

------

 2. ⚠️ 享元对象应尽量**不可变(Immutable)**

> 一旦创建, 内部状态不应被修改, 确保线程安全和共享安全。


```
class TreeType { // 不可变享元
    std::string name;
    Color color;
    Texture texture;
public:
    TreeType(std::string n, Color c, Texture t) : name(n), color(c), texture(t) {}
    void draw(int x, int y) const { ... } // const 方法
};
```

------

 3. 🚫 享元 ≠ 单例

| 模式 | 目的                 |
| ---- | -------------------- |
| 享元 | **共享大量相似对象** |
| 单例 | **确保全局唯一实例** |

> 💡 享元池中可能有多个不同享元对象(如 'A', 'B', 'C' 各一个), 单例只有一个对象。

------

 4. ✅ 使用智能指针或引用管理享元对象


```
std::shared_ptr<Flyweight> getFlyweight(const std::string& key);
```

> 避免裸指针, 防止内存泄漏。工厂应管理生命周期。

------

 5. ⚠️ 线程安全(C++ 多线程环境)


```
class FlyweightFactory {
    std::unordered_map<std::string, std::shared_ptr<Flyweight>> pool;
    mutable std::mutex mtx; // 保护 pool

public:
    std::shared_ptr<Flyweight> getFlyweight(const std::string& key) {
        std::lock_guard<std::mutex> lock(mtx);
        if (pool.find(key) == pool.end()) {
            pool[key] = std::make_shared<ConcreteFlyweight>(key);
        }
        return pool[key];
    }
};
```

------

 6. ✅ 享元工厂应提供清除机制(可选)

> 防止内存泄漏, 可定期清理未使用对象(引用计数 or LRU 策略)。

------

 7. ✅ 适用于“大量对象 + 重复状态”场景

> 如果对象数量少或状态几乎不重复, 享元模式反而增加复杂度。




## 代码

```
// Flyweight.h
#include <iostream>
#include <string>
#include <unordered_map>
#include <memory>
#include <mutex>

// ============ 外部状态: 由客户端维护 ============
struct Position {
    int x, y;
    Position(int x, int y) : x(x), y(y) {}
};

enum class Color { RED, GREEN, BLUE, BLACK };

// ============ 抽象享元 ============
class CharacterFlyweight {
public:
    virtual ~CharacterFlyweight() = default;
    virtual void render(const Position& pos, Color color) const = 0;
    virtual char getSymbol() const = 0;
};

// ============ 具体享元 ============
class ConcreteCharacter : public CharacterFlyweight {
    char symbol; // 内部状态: 可共享

public:
    ConcreteCharacter(char c) : symbol(c) {
        std::cout << "Creating character: '" << symbol << "'\n";
    }

    void render(const Position& pos, Color color) const override {
        std::string colorStr = (color == Color::RED) ? "RED" :
                              (color == Color::GREEN) ? "GREEN" :
                              (color == Color::BLUE) ? "BLUE" : "BLACK";
        std::cout << "Rendering '" << symbol << "' at (" << pos.x << "," << pos.y
                  << ") in " << colorStr << " color.\n";
    }

    char getSymbol() const override { return symbol; }
};

// ============ 享元工厂 ============
class CharacterFactory {
private:
    std::unordered_map<char, std::shared_ptr<CharacterFlyweight>> pool;
    mutable std::mutex mtx;

public:
    std::shared_ptr<CharacterFlyweight> getCharacter(char c) {
        std::lock_guard<std::mutex> lock(mtx);
        if (pool.find(c) == pool.end()) {
            pool[c] = std::make_shared<ConcreteCharacter>(c);
        }
        return pool[c];
    }

    size_t getPoolSize() const {
        std::lock_guard<std::mutex> lock(mtx);
        return pool.size();
    }
};

// ============ 客户端 ============
#include "Flyweight.h"

int main() {
    std::cout << "=== 享元模式: 字符渲染系统 ===\n\n";

    CharacterFactory factory;

    // 模拟渲染文档中的字符
    std::string document = "AAABBBCCCDDDAAABBB";

    std::cout << "Rendering document: " << document << "\n\n";

    int x = 0, y = 0;
    for (char c : document) {
        auto character = factory.getCharacter(c);
        character->render(Position(x, y), Color::BLACK);
        x += 10; // 水平移动
        if (x > 50) { x = 0; y += 20; } // 换行
    }

    std::cout << "\n=== 统计 ===\n";
    std::cout << "文档长度: " << document.length() << " 字符\n";
    std::cout << "享元池大小: " << factory.getPoolSize() << " 个对象\n";
    std::cout << "节省对象: " << document.length() - factory.getPoolSize() << " 个\n";

    return 0;
}
```



## PlantUML

```
@startuml

' 抽象享元
abstract class Flyweight {
    +render(extrinsicState) {abstract}
}

' 具体享元
class ConcreteFlyweight {
    -intrinsicState
    +render(extrinsicState)
}

' 享元工厂
class FlyweightFactory {
    -pool: Map<Key, Flyweight>
    +getFlyweight(key): Flyweight
}

' 客户端
class Client {
    -extrinsicState
    +operation()
}

' 关系
Flyweight <|-- ConcreteFlyweight
FlyweightFactory --> Flyweight : manages pool
Client --> FlyweightFactory : requests
Client --> Flyweight : uses

note right of Flyweight
    Defines interface for
    rendering with extrinsic state.
end note

note right of ConcreteFlyweight
    Stores intrinsic state.
    Immutable recommended.
end note

note bottom of FlyweightFactory
    Creates and manages
    shared flyweight objects.
    Thread-safe in C++.
end note

note top of Client
    Maintains extrinsic state
    and coordinates rendering.
end note

@enduml
```

![](./picture/12.Flyweight Pattern.png)


# 15. 代理模式

## 简介

> **代理模式(Proxy Pattern)** 是一种**结构型设计模式**, 它**为另一个对象提供一个替身或占位符, 以控制对这个对象的访问**。

 🎯 核心思想: 

- **“代替真实对象, 控制访问”**
- **代理与真实对象实现相同接口**
- **客户端无感知, 以为在操作真实对象**

> 💡 经典比喻: 
>  **游戏代练** —— 你(客户端)以为自己在打游戏, 其实是代练(代理)在操作你的账号(真实对象), 他可以控制你什么时候能玩、能不能玩、玩之前要不要交钱。

------

 🧩 结构组成: 

| 角色          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| `Subject`     | 抽象主题接口(如 `IImage`, `IService`)                      |
| `RealSubject` | 真实对象(如 `RealImage`, `RealService`), 执行实际业务逻辑  |
| `Proxy`       | 代理对象, 持有对 `RealSubject` 的引用, 控制访问(如延迟加载、权限检查) |
| `Client`      | 客户端, 通过 `Proxy` 访问 `RealSubject`, 无感知              |

> 📌 **关键点: **
>  代理与真实对象**实现同一接口**, 客户端**无需修改代码**即可切换。

------

 ✅ 适用场景

1. **延迟初始化(Lazy Initialization)** —— 对象创建开销大, 首次使用时才创建
2. **访问控制(Access Control)** —— 权限检查、登录验证
3. **远程代理(Remote Proxy)** —— 本地代表远程对象(如 RPC、Web Service)
4. **日志记录 / 监控** —— 调用前后记录日志、统计耗时
5. **缓存代理(Caching Proxy)** —— 缓存结果, 避免重复计算
6. **智能指针 / 引用计数** —— 控制对象生命周期

📌 **典型应用场景: **

- 🖼️ **图像懒加载**: 图片首次显示时才从磁盘/网络加载
- 🔐 **权限控制**: 访问敏感操作前检查用户权限
- 🌐 **远程服务调用**: 本地代理封装网络通信
- ⏱️ **性能监控**: 记录方法执行时间
- 💾 **缓存数据库查询结果**
- 🧵 **线程安全代理**: 为非线程安全对象添加锁

------

 ✅ 优缺点

 ✅ 优点: 

1. **控制访问** → 可添加权限、日志、缓存等逻辑
2. **延迟加载** → 节省内存和初始化时间
3. **客户端透明** → 无需修改客户端代码
4. **职责分离** → 代理负责“控制”, 真实对象负责“业务”
5. **扩展性强** → 可叠加多个代理(如: 缓存代理 + 权限代理)

 ❌ 缺点: 

1. **增加系统复杂度** → 多一层代理类
2. **可能降低性能** → 代理层增加调用开销(通常可忽略)
3. **调试困难** → 调用链变长, 需跟踪代理逻辑
4. **生命周期管理复杂** → 代理和真实对象的析构顺序需注意(C++)

------

 ✅ 注意事项

 1. 🔄 代理 ≠ 装饰器

| 模式   | 目的                                 |
| ------ | ------------------------------------ |
| 代理   | **控制访问**(何时、能否、如何访问) |
| 装饰器 | **动态添加功能**(增强行为)         |

> 💡 **代理 = “门卫”, 装饰器 = “包装纸”**


```
// 代理: 控制是否允许访问
if (user.hasPermission()) realObject->operation();

// 装饰器: 增强功能
decorated->operation(); // 内部调用 component->operation() + 额外逻辑
```

------

 2. 🔄 代理 ≠ 适配器

| 模式   | 目的                   |
| ------ | ---------------------- |
| 代理   | **相同接口, 控制访问** |
| 适配器 | **转换接口, 兼容调用** |

> 💡 代理不改变接口, 适配器改变接口。

------

 3. ⚠️ 代理应持有真实对象的**智能指针或引用**


```
class ImageProxy : public IImage {
    std::unique_ptr<RealImage> realImage; // 或 shared_ptr
public:
    void display() override {
        if (!realImage) {
            realImage = std::make_unique<RealImage>("huge_image.jpg");
        }
        realImage->display();
    }
};
```

> ✅ 避免裸指针, 防止内存泄漏
>  ✅ `unique_ptr`: 代理独占所有权
>  ✅ `shared_ptr`: 允许多个代理共享真实对象

------

 4. ✅ 代理可组合(代理链)


```
// 权限代理 → 缓存代理 → 真实对象
auto service = std::make_shared<RealService>();
auto cached = std::make_shared<CachingProxy>(service);
auto secured = std::make_shared<SecurityProxy>(cached);
```

------

 5. ⚠️ 注意析构顺序(C++)

> 若代理持有真实对象, 确保代理析构时真实对象仍有效(通常代理负责销毁)。

------

 6. ✅ 适用于“访问控制”、“延迟加载”、“远程调用”等场景

> 如果只是简单封装, 考虑是否过度设计。



 ✅ 一句话总结: 

> **代理模式 = “对象的替身”, 在不改变接口的前提下, 控制对真实对象的访问。**

> **“你想操作真实对象？先过我这关！”**

🎯 **推荐语: **

> **代理模式是构建安全、高效、可扩展系统的关键模式。无论是延迟加载、权限控制还是远程调用, 代理模式都能让你在不侵入业务代码的前提下, 优雅地添加控制逻辑！**

掌握代理模式, 你就掌握了“控制的艺术”！

## 代码

远程服务代理(模拟 RPC)

```
#include <iostream>
#include <string>
#include <thread>
#include <chrono>

// 抽象远程服务
class IRemoteService {
public:
    virtual ~IRemoteService() = default;
    virtual std::string getData() = 0;
};

// 真实远程服务(模拟网络延迟)
class RealRemoteService : public IRemoteService {
public:
    std::string getData() override {
        std::cout << "🌐 Connecting to remote server...\n";
        std::this_thread::sleep_for(std::chrono::seconds(2)); // 模拟网络延迟
        return "Data from remote server";
    }
};

// 远程代理(本地存根)
class RemoteProxy : public IRemoteService {
    mutable std::unique_ptr<RealRemoteService> realService;
    mutable std::string cachedData;
    mutable bool isCached = false;

public:
    std::string getData() override {
        if (!realService) {
            realService = std::make_unique<RealRemoteService>();
        }

        if (!isCached) {
            std::cout << "📡 Proxy: Fetching data for the first time...\n";
            cachedData = realService->getData();
            isCached = true;
        } else {
            std::cout << "💾 Proxy: Returning cached data...\n";
        }

        return cachedData;
    }
};

int main() {
    std::cout << "=== 代理模式: 远程服务代理 ===\n\n";

    RemoteProxy proxy;

    // 第一次调用: 真实网络请求
    std::cout << "First call: " << proxy.getData() << "\n\n";

    // 第二次调用: 返回缓存
    std::cout << "Second call: " << proxy.getData() << "\n";

    return 0;
}
```

## PlantUML

```
@startuml

' 设置主题和样式(可选)
skinparam class {
    BackgroundColor White
    BorderColor #333333
    FontSize 14
}
skinparam interface {
    BackgroundColor LightBlue
    BorderColor #3333CC
    FontStyle italic
}

' 定义抽象接口
interface IRemoteService {
    +getData() : string
}

' 定义具体实现类
class RealRemoteService {
    +getData() : string
}

' 定义代理类
class RemoteProxy {
    -realService : unique_ptr<RealRemoteService>
    -cachedData : string
    -isCached : bool
    +getData() : string
}

' 继承关系
RealRemoteService --|> IRemoteService
RemoteProxy --|> IRemoteService

' 代理类聚合真实服务(组合关系, 用菱形实线)
RemoteProxy o-- "1" RealRemoteService : creates and holds

' 添加注释说明
note right of RemoteProxy
  代理模式实现: 
  - 首次调用创建真实服务
  - 缓存结果以提高后续性能
  - 对客户端透明
end note

note right of RealRemoteService
  真实远程服务: 
  - 模拟网络延迟
  - 实际数据来源
end note

@enduml
```

![](./picture/13.ProxyPattern.png)



# 🔄行为型模式

# 16. 策略模式

## 简介

> **策略模式(Strategy Pattern)** 是一种**行为型设计模式**, 它**定义一系列算法或行为, 并将每个算法封装起来, 使它们可以互换, 让算法的变化独立于使用它的客户端**。

 🎯 核心思想: 

- **“封装变化, 互换算法”**
- **将算法抽象为策略接口**
- **客户端通过组合方式使用不同策略, 而非继承**

> 💡 经典比喻: 
>  **导航App中的路线策略** —— 你可以随时切换“最短路径”、“最少收费”、“避开高速”, 而App本身结构不变。

------

 🧩 结构组成: 

| 角色                    | 说明                                                         |
| ----------------------- | ------------------------------------------------------------ |
| `Strategy`              | 抽象策略接口(如 `ISortStrategy`, `IPaymentStrategy`)       |
| `ConcreteStrategyA/B/C` | 具体策略类(如 `QuickSort`, `CreditCardPayment`), 实现不同算法 |
| `Context`               | 上下文类, 持有策略对象引用, 提供调用接口(如 `Sorter`, `PaymentProcessor`) |
| `Client`                | 客户端, 选择并设置具体策略, 触发行为                         |

> 📌 **关键点: **
>
> - 策略模式使用**组合而非继承**实现算法切换
> - 客户端决定使用哪个策略
> - 策略对象可动态替换

------

 ✅ 适用场景

1. **多种算法/行为可互换**(如排序、支付、压缩、加密)
2. **避免大量条件语句(if-else / switch)**
3. **需要运行时动态切换算法**
4. **算法需独立于使用它的类**
5. **不同用户/场景需要不同行为**

📌 **典型应用场景: **

- 🧮 **排序算法切换**: 快速排序、归并排序、冒泡排序
- 💳 **支付方式**: 信用卡、支付宝、微信、PayPal
- 🎮 **游戏角色AI行为**: 攻击、逃跑、巡逻
- 🧭 **导航路径规划**: 最短时间、最少收费、避开高速
- 📦 **数据压缩算法**: ZIP、GZIP、LZ4
- 🔐 **加密算法**: AES、RSA、DES

------

 ✅ 优缺点

 ✅ 优点: 

1. **算法可自由切换** → 运行时动态更换策略
2. **避免条件语句** → 代码更清晰、易维护
3. **扩展性强** → 新增策略无需修改上下文或客户端
4. **符合开闭原则** → 对扩展开放, 对修改关闭
5. **职责分离** → 策略专注算法, 上下文专注协调

 ❌ 缺点: 

1. **增加类数量** → 每个策略一个类
2. **客户端需了解策略差异** → 需知道选哪个策略合适
3. **策略间切换可能有状态丢失风险**(若策略有内部状态)
4. **过度设计风险** → 简单场景用 if-else 更直接

------

 ✅ 注意事项

 1. 🔄 策略模式 ≠ 状态模式

| 模式     | 目的                     | 切换控制者     |
| -------- | ------------------------ | -------------- |
| 策略模式 | **客户端决定切换算法**   | 客户端主动设置 |
| 状态模式 | **对象内部状态驱动行为** | 对象自身切换   |

> 💡 **策略 = “我选哪个算法”, 状态 = “我现在是什么状态, 该做什么”**


```
// 策略: 客户端设置
context.setStrategy(new QuickSort());

// 状态: 对象根据内部状态自动切换
state.handle(); // 内部可能切换到下一个状态
```

------

 2. ⚠️ 策略对象应尽量**无状态(Stateless)**

> 有状态策略在切换时可能丢失数据, 增加复杂度。


```
// ✅ 无状态策略(推荐)
class QuickSort : public ISortStrategy {
public:
    void sort(std::vector<int>& data) override {
        // 不保存任何成员变量
        std::sort(data.begin(), data.end()); // 简化示例
    }
};

// ❌ 有状态策略(谨慎使用)
class CountingSort : public ISortStrategy {
    int maxVal; // 内部状态
public:
    void sort(std::vector<int>& data) override { ... }
};
```

------

 3. ✅ 使用智能指针管理策略对象(C++)


```
class Sorter {
    std::unique_ptr<ISortStrategy> strategy;
public:
    void setStrategy(std::unique_ptr<ISortStrategy> s) {
        strategy = std::move(s);
    }
    void execute(std::vector<int>& data) {
        if (strategy) strategy->sort(data);
    }
};
```

> ✅ `unique_ptr`: 独占所有权, 策略由上下文管理
>  ✅ `shared_ptr`: 多个上下文共享同一策略

------

 4. ✅ 策略可配置化(工厂 + 配置文件)


```
std::unique_ptr<ISortStrategy> createStrategy(const std::string& type) {
    if (type == "quick") return std::make_unique<QuickSort>();
    if (type == "merge") return std::make_unique<MergeSort>();
    throw std::invalid_argument("Unknown strategy");
}
```

------

 5. ✅ 适用于“算法族”、“行为族”场景

> 如果算法差异大、使用频繁、需动态切换, 策略模式是首选。

------

 6. ⚠️ 避免策略“上帝类”

> 每个策略应职责单一, 避免一个策略做太多事。

🎯 **推荐语: **

> **策略模式是消除条件语句、实现算法自由切换的利器。无论是排序、支付、AI行为, 只要你想“换算法如换衣服”, 策略模式就是你的最佳选择！**

掌握策略模式, 你就掌握了“算法自由的艺术”！

## 代码

排序策略

```
// Strategy.h
#include <iostream>
#include <vector>
#include <memory>
#include <algorithm>

// ============ 抽象策略 ============
class ISortStrategy {
public:
    virtual ~ISortStrategy() = default;
    virtual void sort(std::vector<int>& data) = 0;
    virtual std::string getName() const = 0;
};

// ============ 具体策略 ============
class QuickSort : public ISortStrategy {
public:
    void sort(std::vector<int>& data) override {
        std::sort(data.begin(), data.end()); // 简化, 实际应实现快排
    }
    std::string getName() const override { return "QuickSort"; }
};

class BubbleSort : public ISortStrategy {
public:
    void sort(std::vector<int>& data) override {
        for (size_t i = 0; i < data.size(); ++i) {
            for (size_t j = 0; j < data.size() - i - 1; ++j) {
                if (data[j] > data[j + 1]) {
                    std::swap(data[j], data[j + 1]);
                }
            }
        }
    }
    std::string getName() const override { return "BubbleSort"; }
};

class MergeSort : public ISortStrategy {
public:
    void sort(std::vector<int>& data) override {
        if (data.size() <= 1) return;
        std::vector<int> temp(data.size());
        mergeSortImpl(data, temp, 0, data.size() - 1);
    }

private:
    void mergeSortImpl(std::vector<int>& data, std::vector<int>& temp, int left, int right) {
        if (left >= right) return;
        int mid = left + (right - left) / 2;
        mergeSortImpl(data, temp, left, mid);
        mergeSortImpl(data, temp, mid + 1, right);
        merge(data, temp, left, mid, right);
    }

    void merge(std::vector<int>& data, std::vector<int>& temp, int left, int mid, int right) {
        for (int i = left; i <= right; ++i) temp[i] = data[i];
        int i = left, j = mid + 1, k = left;
        while (i <= mid && j <= right) {
            if (temp[i] <= temp[j]) data[k++] = temp[i++];
            else data[k++] = temp[j++];
        }
        while (i <= mid) data[k++] = temp[i++];
        while (j <= right) data[k++] = temp[j++];
    }

public:
    std::string getName() const override { return "MergeSort"; }
};

// ============ 上下文 ============
class Sorter {
    std::unique_ptr<ISortStrategy> strategy;

public:
    void setStrategy(std::unique_ptr<ISortStrategy> s) {
        strategy = std::move(s);
        std::cout << "🔄 Strategy set to: " << strategy->getName() << "\n";
    }

    void execute(std::vector<int>& data) {
        if (!strategy) {
            std::cout << "❌ No strategy set!\n";
            return;
        }
        std::cout << "▶️ Executing " << strategy->getName() << "...\n";
        strategy->sort(data);
    }
};

// ============ 工具函数 ============
void printVector(const std::vector<int>& v, const std::string& title) {
    std::cout << title << ": ";
    for (int x : v) std::cout << x << " ";
    std::cout << "\n";
}

// ============ 客户端 ============
#include "Strategy.h"

int main() {
    std::cout << "=== 策略模式: 排序算法切换 ===\n\n";

    Sorter sorter;
    std::vector<int> data = {64, 34, 25, 12, 22, 11, 90};

    printVector(data, "Original data");

    // 使用冒泡排序
    sorter.setStrategy(std::make_unique<BubbleSort>());
    sorter.execute(data);
    printVector(data, "After BubbleSort");

    // 重置数据
    data = {64, 34, 25, 12, 22, 11, 90};

    // 使用快速排序
    sorter.setStrategy(std::make_unique<QuickSort>());
    sorter.execute(data);
    printVector(data, "After QuickSort");

    // 重置数据
    data = {64, 34, 25, 12, 22, 11, 90};

    // 使用归并排序
    sorter.setStrategy(std::make_unique<MergeSort>());
    sorter.execute(data);
    printVector(data, "After MergeSort");

    return 0;
}
```



## PlantUML

```
@startuml

' 抽象策略
interface Strategy {
    +algorithmInterface()
}

' 具体策略
class ConcreteStrategyA {
    +algorithmInterface()
}

class ConcreteStrategyB {
    +algorithmInterface()
}

class ConcreteStrategyC {
    +algorithmInterface()
}

' 上下文
class Context {
    -strategy: Strategy
    +setStrategy(strategy: Strategy)
    +contextInterface()
}

' 客户端
class Client {
    +main()
}

' 关系
Strategy <|-- ConcreteStrategyA
Strategy <|-- ConcreteStrategyB
Strategy <|-- ConcreteStrategyC
Context --> Strategy : uses
Client --> Context : configures
Client --> Strategy : creates

note right of Strategy
    Declares interface
    common to all supported
    algorithms.
end note

note right of ConcreteStrategyA
    Implements the algorithm
    using the Strategy interface.
end note

note bottom of Context
    Maintains a reference to a
    Strategy object and calls
    its algorithmInterface().
end note

note top of Client
    Chooses and sets the
    concrete strategy.
end note

@enduml
```

![](./picture/14.StrategyPattern.png)



# 17. 模板方法模式

## 简介


> C++ 模板方法模式(Template Method Pattern)
> **定义算法骨架, 将某些步骤延迟到子类实现。**
>  —— 父类控制流程, 子类实现细节。

------

📌 1. 介绍

- **类型**: 行为型模式
- **核心思想**: 
  - 在**抽象基类**中定义一个**模板方法(通常是 final 或非虚函数)**, 它按固定顺序调用多个步骤。
  - 其中部分步骤是**纯虚函数或虚函数**, 由子类实现具体行为。
  - 父类控制“不变的流程”, 子类提供“可变的实现”。
- **关键词**: 算法骨架、继承、钩子方法、好莱坞原则(“Don’t call us, we’ll call you”)

------

🎯 2. 适用场景

 ✔ 算法结构稳定, 但某些步骤实现可变(如泡茶/咖啡、数据处理流程、游戏关卡流程)
 ✔ 需要控制子类扩展范围, 防止破坏算法结构
 ✔ 多个子类有公共行为, 希望避免代码重复
 ✔ 框架设计中, 提供标准流程, 允许用户自定义部分步骤

------

⚖️ 3. 优缺点

| 优点                                         | 缺点                                 |
| -------------------------------------------- | ------------------------------------ |
| ✅ 封装不变部分, 扩展可变部分                 | ❌ 继承导致类数量膨胀                 |
| ✅ 提取公共代码, 便于维护                     | ❌ 子类影响父类(违反“里氏替换”风险) |
| ✅ 行为由父类控制, 子类实现细节(好莱坞原则) | ❌ 不适合频繁变化的算法结构           |
| ✅ 符合开闭原则(扩展子类不改父类)           |                                      |

------

⚠️ 4. 注意事项

1. **模板方法建议设为 `final`(C++11+)** → 防止子类重写骨架, 破坏流程。
2. **步骤方法可设为 `protected`** → 仅子类可访问, 外部不可调用。
3. **可提供“钩子方法(hook)”** → 空实现虚函数, 子类可选重写。
4. **避免在模板方法中调用可能被子类重写的非final虚函数初始化资源** → 构造函数中调用虚函数是未定义行为！
5. **慎用深继承** → 优先组合, 但模板方法是“合理使用继承”的经典场景。

 🧠 一句话总结模板方法: 

> **“父定流程, 子填步骤；钩子可选, 骨架不变。”**

------

✅ **适用语言**: C++、Java、C#、Python 等支持继承和虚函数的语言
✅ **经典应用**: 

- Java `AbstractList`、`InputStream`
- C++ 框架中的初始化/处理/清理流程
- 游戏AI行为树中的标准执行流程

------

📌 **学习建议**: 

- 与**策略模式**对比: 模板方法 = **继承实现**流程定制；策略模式 = **组合实现**算法替换。
- 与**工厂方法**结合: 模板方法中某步可调用工厂方法创建对象。

## 代码

泡饮料流程

```
#include <iostream>
using namespace std;

// 抽象基类: 定义算法骨架
class Beverage {
public:
    // 模板方法: 定义流程, final防止被重写
    void prepareRecipe() final {
        boilWater();
        brew();
        pourInCup();
        if (customerWantsCondiments()) { // 钩子方法
            addCondiments();
        }
    }

protected:
    // 基本步骤(部分由子类实现)
    virtual void brew() = 0;           // 纯虚, 必须实现
    virtual void addCondiments() = 0;  // 纯虚, 必须实现

    // 具体步骤(父类实现)
    void boilWater() {
        cout << "Boiling water" << endl;
    }

    void pourInCup() {
        cout << "Pouring into cup" << endl;
    }

    // 钩子方法: 默认实现, 子类可选重写
    virtual bool customerWantsCondiments() const {
        return true; // 默认加调料
    }
};

// 子类1: 泡茶
class Tea : public Beverage {
protected:
    void brew() override {
        cout << "Steeping the tea" << endl;
    }

    void addCondiments() override {
        cout << "Adding lemon" << endl;
    }
};

// 子类2: 冲咖啡
class Coffee : public Beverage {
protected:
    void brew() override {
        cout << "Dripping coffee through filter" << endl;
    }

    void addCondiments() override {
        cout << "Adding sugar and milk" << endl;
    }

    // 重写钩子: 询问用户是否要调料
    bool customerWantsCondiments() const override {
        // 模拟用户输入
        cout << "Would you like milk and sugar with your coffee (y/n)? ";
        char answer;
        cin >> answer;
        return (answer == 'y' || answer == 'Y');
    }
};

// 客户端使用
int main() {
    cout << "Making tea..." << endl;
    Tea tea;
    tea.prepareRecipe();

    cout << "\nMaking coffee..." << endl;
    Coffee coffee;
    coffee.prepareRecipe();

    return 0;
}
```

## PlantUML

```
@startuml
abstract class Beverage {
    +{final} prepareRecipe() : void
    #boilWater() : void
    #pourInCup() : void
    #{virtual} customerWantsCondiments() : bool
    #{abstract} brew() : void
    #{abstract} addCondiments() : void
}

class Tea {
    #brew() : void
    #addCondiments() : void
}

class Coffee {
    #brew() : void
    #addCondiments() : void
    #customerWantsCondiments() : bool
}

Beverage <|-- Tea
Beverage <|-- Coffee

note right of Beverage
  Template Method Pattern
  prepareRecipe() 是模板方法
  brew() 和 addCondiments() 是抽象步骤
  customerWantsCondiments() 是钩子方法
end note

@enduml
```

![](./picture/15.TemplateMethodPattern.png)

# 18. 观察者模式

## 简介

> C++ 观察者模式(Observer Pattern)
> **定义对象间的一对多依赖关系, 当一个对象(主题)状态改变时, 所有依赖它的对象(观察者)自动收到通知并更新。**

------

📌 1. 介绍

- **类型**: 行为型模式

- **别名**: 发布-订阅模式(Publish-Subscribe, 但严格来说是其同步紧耦合版本)

- 核心角色: 
  - `Subject`(主题/被观察者): 维护观察者列表, 提供注册/移除/通知接口。
  - `Observer`(观察者): 定义更新接口, 供主题调用。

- **通信方式: 推模型(Push) 或 拉模型(Pull)**
  - 推: 主题主动传递数据给观察者
  - 拉: 观察者自己从主题拉取数据(主题只发“有更新”信号)

------

🎯 2. 适用场景

 ✔ 对象状态变化需通知多个对象(如GUI控件、数据绑定)
 ✔ 解耦“数据层”与“视图层”(MVC中的核心机制)
 ✔ 事件系统、消息通知、日志监听、股票行情推送
 ✔ 避免对象间直接引用, 降低耦合

------

⚖️ 3. 优缺点

| 优点                               | 缺点                                   |
| ---------------------------------- | -------------------------------------- |
| ✅ 建立动态、松耦合的一对多关系     | ❌ 通知顺序不确定(除非显式控制)       |
| ✅ 支持广播通信, 自动通知所有观察者 | ❌ 可能导致“内存泄漏”(观察者未注销)   |
| ✅ 符合开闭原则(可自由增删观察者) | ❌ 过度使用会导致系统复杂、难以追踪依赖 |
| ✅ 易于扩展新观察者                 | ❌ 同步通知可能阻塞主题(可用异步优化) |

------

⚠️ 4. 注意事项

1. **观察者需在销毁前从主题中注销** → 否则主题通知已销毁对象 → 未定义行为(崩溃)。

2. **考虑线程安全** → 多线程环境下, 注册/注销/通知需加锁。

3. **避免在通知过程中修改观察者列表** → 可能导致迭代器失效 → 建议复制列表或延迟删除。

4. 推 vs 拉模型选择: 

   - 推: 效率高, 但耦合数据结构
   - 拉: 更灵活, 但观察者需持有主题引用
   
5. **可选: 使用 `std::function` + `std::vector` 替代继承接口** → 更轻量, 适合简单场景(见示例二)。

🧠 一句话总结观察者模式: 

> **“我变你知, 自动通知；一对多联, 解耦利器。”**

------

✅ **经典应用**: 

- GUI事件监听(按钮点击、窗口关闭)
- MVC架构中的 Model → View 通知
- 游戏成就系统、日志系统、股票行情推送
- Qt 的 `Signal/Slot`、.NET 的 `Event`、Java 的 `PropertyChangeListener`

------

📌 **学习建议**: 

- 与**发布-订阅模式**对比: 观察者是同步、紧耦合；发布订阅通过消息队列异步解耦。
- 与**中介者模式**对比: 观察者是“广播”, 中介者是“调度中心”。

## 代码

✅ 示例一: 传统接口继承方式(经典GoF风格)

```
#include <iostream>
#include <vector>
#include <algorithm>
#include <memory>

// 抽象观察者接口
class Observer {
public:
    virtual ~Observer() = default;
    virtual void update(float temperature, float humidity, float pressure) = 0;
};

// 抽象主题接口
class Subject {
public:
    virtual ~Subject() = default;
    virtual void registerObserver(std::shared_ptr<Observer> o) = 0;
    virtual void removeObserver(std::shared_ptr<Observer> o) = 0;
    virtual void notifyObservers() = 0;
};

// 具体主题: 气象站
class WeatherData : public Subject {
    std::vector<std::weak_ptr<Observer>> observers; // 使用 weak_ptr 避免循环引用
    float temperature = 0.0f;
    float humidity = 0.0f;
    float pressure = 0.0f;

public:
    void registerObserver(std::shared_ptr<Observer> o) override {
        observers.push_back(o);
    }

    void removeObserver(std::shared_ptr<Observer> o) override {
        observers.erase(
            std::remove_if(observers.begin(), observers.end(),
                [&o](const std::weak_ptr<Observer>& w) {
                    auto p = w.lock();
                    return !p || p == o;
                }),
            observers.end()
        );
    }

    void notifyObservers() override {
        // 复制到临时vector, 避免迭代中修改
        std::vector<std::shared_ptr<Observer>> validObservers;
        for (auto& w : observers) {
            if (auto obs = w.lock()) {
                validObservers.push_back(obs);
            }
        }
        for (auto& obs : validObservers) {
            obs->update(temperature, humidity, pressure);
        }
    }

    // 模拟传感器数据更新
    void setMeasurements(float temp, float hum, float pres) {
        temperature = temp;
        humidity = hum;
        pressure = pres;
        notifyObservers();
    }
};

// 具体观察者1: 当前状况显示
class CurrentConditionsDisplay : public Observer {
    float temperature = 0.0f;
    float humidity = 0.0f;
    std::weak_ptr<Subject> weatherData; // 可选: 用于拉模型

public:
    CurrentConditionsDisplay(std::shared_ptr<Subject> wd) : weatherData(wd) {}

    void update(float temp, float hum, float pres) override {
        temperature = temp;
        humidity = hum;
        display();
    }

    void display() {
        std::cout << "Current conditions: " << temperature
                  << "F degrees and " << humidity << "% humidity\n";
    }
};

// 具体观察者2: 统计显示
class StatisticsDisplay : public Observer {
    float maxTemp = 0.0f;
    float minTemp = 200.0f;
    float tempSum = 0.0f;
    int numReadings = 0;

public:
    void update(float temp, float hum, float pres) override {
        tempSum += temp;
        numReadings++;
        if (temp > maxTemp) maxTemp = temp;
        if (temp < minTemp) minTemp = temp;
        display();
    }

    void display() {
        std::cout << "Avg/Max/Min temperature = "
                  << (tempSum / numReadings) << "/" << maxTemp << "/" << minTemp << "\n";
    }
};

// 客户端使用
int main() {
    auto weatherData = std::make_shared<WeatherData>();

    auto currentDisplay = std::make_shared<CurrentConditionsDisplay>(weatherData);
    auto statsDisplay = std::make_shared<StatisticsDisplay>();

    weatherData->registerObserver(currentDisplay);
    weatherData->registerObserver(statsDisplay);

    weatherData->setMeasurements(80, 65, 30.4f);
    weatherData->setMeasurements(82, 70, 29.2f);
    weatherData->setMeasurements(78, 90, 29.2f);

    // 自动清理: shared_ptr + weak_ptr 管理生命周期
    return 0;
}
```

✅ 示例二: 现代C++函数式风格(std::function + lambda)

```
#include <iostream>
#include <vector>
#include <functional>

class WeatherStation {
    std::vector<std::function<void(float, float, float)>> observers;

public:
    void subscribe(std::function<void(float, float, float)> f) {
        observers.push_back(f);
    }

    void unsubscribe(const std::function<void(float, float, float)>& f) {
        observers.erase(
            std::remove(observers.begin(), observers.end(), f),
            observers.end()
        );
    }

    void setMeasurements(float temp, float hum, float pres) {
        for (const auto& f : observers) {
            f(temp, hum, pres);
        }
    }
};

int main() {
    WeatherStation station;

    auto display1 = [](float t, float h, float p) {
        std::cout << "[Display1] Temp: " << t << ", Hum: " << h << "\n";
    };

    auto display2 = [](float t, float h, float p) {
        std::cout << "[Display2] Got update!\n";
    };

    station.subscribe(display1);
    station.subscribe(display2);

    station.setMeasurements(25.5f, 60.0f, 1013.25f);

    return 0;
}
```

## PlantUML

```
@startuml
title Observer Pattern - Classic GoF

interface Subject {
    +registerObserver(o: Observer)
    +removeObserver(o: Observer)
    +notifyObservers()
}

interface Observer {
    +update(temperature: float, humidity: float, pressure: float)
}

class WeatherData {
    -observers: List<Observer>
    -temperature: float
    -humidity: float
    -pressure: float
    +setMeasurements(t,h,p)
}

class CurrentConditionsDisplay {
    -temperature: float
    -humidity: float
    +display()
}

class StatisticsDisplay {
    -maxTemp: float
    -minTemp: float
    -tempSum: float
    -numReadings: int
    +display()
}

Subject <|.. WeatherData
Observer <|.. CurrentConditionsDisplay
Observer <|.. StatisticsDisplay

WeatherData "1" *-- "0..*" Observer : observes >

note right of Subject
  维护观察者列表
  提供注册/移除/通知接口
end note

note right of Observer
  定义更新接口
  由具体观察者实现
end note

@enduml
```

![](./picture/16.ObserverPattern.png)



# 19.迭代器模式

## 简介

> 🔄 C++ 迭代器模式(Iterator Pattern)
> **提供一种方法顺序访问聚合对象中的各个元素, 而又不暴露其内部表示。**

------

📌 1. 介绍

- **类型**: 行为型模式
- 核心思想 : 
  - 将**遍历逻辑**从**聚合对象**中抽离 → 封装到**迭代器对象**中。
  - 客户端通过统一接口访问元素 → **无需知道容器内部结构**。
- **关键词**: 遍历、封装、统一接口、解耦

> 💡 **C++ STL 中的 `begin()` / `end()` / `++it` / `\*it` 就是迭代器模式的经典实现！**

------

🎯 2. 适用场景

 ✔ 需要遍历不同数据结构(数组、链表、树、图)但不想暴露内部结构
 ✔ 希望提供多种遍历方式(前序、后序、层序、反向)
 ✔ 解耦“数据存储”与“数据访问”逻辑
 ✔ 符合“单一职责原则”——容器管存储, 迭代器管遍历

------

⚖️ 3. 优缺点

| 优点                                 | 缺点                                       |
| ------------------------------------ | ------------------------------------------ |
| ✅ 支持多种遍历策略(如正向/反向)    | ❌ 增加类数量(每个容器可能需配多个迭代器) |
| ✅ 简化聚合类接口(无需暴露内部结构) | ❌ 迭代过程中容器修改可能导致未定义行为     |
| ✅ 符合开闭原则(可扩展新迭代器)     | ❌ 性能略低于直接访问(函数调用开销)       |
| ✅ 统一访问接口, 客户端代码更简洁     |                                            |

------

⚠️ 4. 注意事项

1. **迭代器失效问题**: 在遍历过程中修改容器(如删除元素)可能导致迭代器失效 → 行为未定义！

2. **线程安全**: 多线程下遍历+修改需加锁或使用并发安全容器。

3. **现代C++建议**: 优先使用 STL 的 `std::begin()`, `std::end()`, 范围for循环 → 更安全高效。

4. 迭代器分类(C++ STL): 

   - 输入/输出迭代器
   - 前向/双向/随机访问迭代器
   - 根据容器能力提供不同能力迭代器
   
5. **避免过度设计**: 简单容器直接用索引或STL即可, 不必手写迭代器。

🧠 一句话总结迭代器模式: 

> **“遍历不问出处, 统一接口走路；STL早已内嵌, 手写只为领悟。”**

------

✅ **经典应用**: 

- C++ STL 所有容器(`vector`, `list`, `map`...)的 `iterator`
- Java `Collection.iterator()`
- Python `__iter__()` / `__next__()`
- 数据库结果集遍历(ResultSet)

## 代码

手写迭代器 + STL风格接口

🎯 场景: 实现一个“书架(BookShelf)”容器, 支持正向遍历

```
#include <iostream>
#include <vector>
#include <memory>
#include <string>

// === 聚合元素 ===
class Book {
    std::string name;
public:
    Book(const std::string& n) : name(n) {}
    const std::string& getName() const { return name; }
};

// === 抽象迭代器接口 ===
class Iterator {
public:
    virtual ~Iterator() = default;
    virtual bool hasNext() const = 0;
    virtual std::shared_ptr<Book> next() = 0;
};

// === 具体聚合类: 书架 ===
class BookShelf {
    std::vector<std::shared_ptr<Book>> books;

public:
    void addBook(std::shared_ptr<Book> book) {
        books.push_back(book);
    }

    size_t size() const {
        return books.size();
    }

    // 获取迭代器(STL风格)
    class IteratorImpl : public Iterator {
        const BookShelf& shelf;
        size_t index = 0;

    public:
        IteratorImpl(const BookShelf& s) : shelf(s) {}

        bool hasNext() const override {
            return index < shelf.size();
        }

        std::shared_ptr<Book> next() override {
            if (!hasNext()) {
                throw std::out_of_range("No more books");
            }
            return shelf.books[index++];
        }
    };

    // STL风格接口
    IteratorImpl begin() const {
        return IteratorImpl(*this);
    }

    IteratorImpl end() const {
        auto it = IteratorImpl(*this);
        it.index = size(); // 指向末尾
        return it;
    }

    // 传统模式接口(可选)
    std::unique_ptr<Iterator> createIterator() const {
        return std::make_unique<IteratorImpl>(*this);
    }
};

// === 客户端使用 ===
int main() {
    BookShelf shelf;
    shelf.addBook(std::make_shared<Book>("《设计模式》"));
    shelf.addBook(std::make_shared<Book>("《C++ Primer》"));
    shelf.addBook(std::make_shared<Book>("《重构》"));

    std::cout << "=== 传统迭代器模式 ===\n";
    auto it = shelf.createIterator();
    while (it->hasNext()) {
        std::cout << "Book: " << it->next()->getName() << "\n";
    }

    std::cout << "\n=== STL风格迭代器(推荐) ===\n";
    for (auto it = shelf.begin(); it.hasNext(); ) {
        std::cout << "Book: " << it.next()->getName() << "\n";
    }

    std::cout << "\n=== 范围for循环(需定义begin/end全局函数)===\n";
    // 注: 要支持范围for, 需定义非成员 begin/end(或成员函数)
    // 此处为演示, 手动模拟: 
    auto b = shelf.begin();
    auto e = shelf.end();
    for (auto current = b; !(current.index == e.index); ) {
        std::cout << "Book: " << current.next()->getName() << "\n";
    }

    return 0;
}
```

## PlantUML

```
@startuml

' === 聚合元素: Book ===
class Book {
    - name : std::string
    + getName() : const std::string&
}

' === 抽象迭代器接口 ===
class Iterator {
    {abstract} + hasNext() : bool
    {abstract} + next() : std::shared_ptr<Book>
}

' === 具体聚合类: BookShelf ===
class BookShelf {
    - books : std::vector<std::shared_ptr<Book>>
    + addBook(book : std::shared_ptr<Book>)
    + size() : size_t
    + createIterator() : std::unique_ptr<Iterator>
    + begin() : IteratorImpl
    + end() : IteratorImpl
}

' === 嵌套的具体迭代器实现 ===
class BookShelf::IteratorImpl {
    - shelf : const BookShelf&
    - index : size_t
    + hasNext() : bool
    + next() : std::shared_ptr<Book>
}

' === 关系 ===
BookShelf o-- "1..*" Book : contains
BookShelf --> Iterator : creates
BookShelf::IteratorImpl --|> Iterator : implements
BookShelf::IteratorImpl .. BookShelf : nested in
Iterator <|.. BookShelf::IteratorImpl : implements

' === 客户端(可选，用于说明使用关系)===
class Client {
    note right
        使用 BookShelf 和 Iterator
        遍历书籍
    end note
}

Client --> BookShelf : uses
Client --> Iterator : uses

@enduml
```

![](./picture/17.IteratorPattern.png)


# 20.责任链模式

## 简介

> ⛓️ C++ 责任链模式(Chain of Responsibility Pattern)
> **将请求沿着处理者链传递, 直到有一个处理者处理它为止。**

------

📌 1. 介绍

- **类型**: 行为型模式

- 核心思想: 
  - 多个对象**组成一条链**, 每个对象都有机会处理请求。
  - 请求发送者**无需知道谁处理**, 只需将请求发给链上第一个对象。
  - 对象可**自行决定是否处理 + 是否传递给下一个**。

- **关键词**: 链式传递、解耦、动态处理、审批流、中间件

> 💡 **类比**: 公司请假审批(组长→经理→总监)、异常处理(try-catch 链)、Web 中间件(Express/Koa 中间件)

------

🎯 2. 适用场景

 ✔ 多个对象可处理同一请求, 但具体由谁处理在运行时决定
 ✔ 想在不明确指定接收者的情况下, 向多个对象中的一个提交请求
 ✔ 请求的处理者集合应被动态指定或扩展
 ✔ 实现“审批流程”、“日志过滤”、“权限校验”、“异常处理”等链式结构

------

⚖️ 3. 优缺点

| 优点                               | 缺点                           |
| ---------------------------------- | ------------------------------ |
| ✅ 降低请求发送者与接收者耦合度     | ❌ 请求可能未被处理(链断裂)   |
| ✅ 增强灵活性: 可动态增删节点       | ❌ 性能开销: 链过长时逐个判断   |
| ✅ 易于扩展新处理者(符合开闭原则) | ❌ 调试困难: 请求路径不直观     |
| ✅ 支持多个对象处理同一请求(可选) | ❌ 递归或循环引用可能导致栈溢出 |

------

⚠️ 4. 注意事项

1. **避免无限循环**: 确保链有终点(最后一个节点要么处理, 要么抛异常/日志)。

2. **默认兜底处理者**: 建议链尾设置“默认处理器”或“日志记录器”, 避免请求无人处理。

3. **线程安全**: 若链结构动态变化(如多线程增删节点), 需加锁或使用不可变链。

4. 纯责任链 vs 非纯责任链: 
   - **纯**: 一个对象处理后, **不再传递**(如审批通过即终止)
   - **非纯**: 处理后**仍可传递**(如日志记录+权限校验+业务处理)

5. 现代C++建议: 
   - 可用 `std::vector<std::function<bool(Request&)>>` 实现轻量级函数式责任链。
   - 或用智能指针管理节点生命周期(如 `std::unique_ptr<Handler>`)。

🧠 一句话总结责任链模式: 

> **“请求进链, 逐级判断；能者处理, 不能则传；无人接手, 兜底要设。”**

------

✅ **经典应用**: 

- Web 框架中间件(如 Express.js、Koa)
- 日志系统(ConsoleLogger → FileLogger → DBLogger)
- 权限校验(Token校验 → 角色校验 → 操作权限校验)
- 异常处理(try-catch 链)
- 游戏AI行为树(条件判断链)

## 代码

请假审批流程

🎯 场景: 员工请假 → 组长 → 经理 → 总监 逐级审批

```
#include <iostream>
#include <memory>
#include <string>

// === 请求类: 请假申请 ===
struct LeaveRequest {
    std::string employee;
    int days;
    LeaveRequest(const std::string& emp, int d) : employee(emp), days(d) {}
};

// === 抽象处理者 ===
class Handler {
protected:
    std::unique_ptr<Handler> nextHandler;

public:
    virtual ~Handler() = default;

    // 设置下一个处理器
    void setNext(std::unique_ptr<Handler> next) {
        nextHandler = std::move(next);
    }

    // 处理请求(模板方法)
    virtual void handleRequest(const LeaveRequest& request) {
        if (canHandle(request)) {
            doHandle(request);
        } else if (nextHandler) {
            std::cout << getName() << " 无权处理, 转交下一级...\n";
            nextHandler->handleRequest(request);
        } else {
            std::cout << "⚠️  所有上级均无法处理此请假申请！\n";
        }
    }

protected:
    virtual std::string getName() const = 0;
    virtual bool canHandle(const LeaveRequest& request) const = 0;
    virtual void doHandle(const LeaveRequest& request) = 0;
};

// === 具体处理者: 组长 ===
class TeamLeader : public Handler {
protected:
    std::string getName() const override { return "组长"; }
    bool canHandle(const LeaveRequest& request) const override {
        return request.days <= 1;
    }
    void doHandle(const LeaveRequest& request) override {
        std::cout << "✅ 组长批准了 " << request.employee << " 的 " << request.days << " 天假期。\n";
    }
};

// === 具体处理者: 经理 ===
class Manager : public Handler {
protected:
    std::string getName() const override { return "经理"; }
    bool canHandle(const LeaveRequest& request) const override {
        return request.days <= 3;
    }
    void doHandle(const LeaveRequest& request) override {
        std::cout << "✅ 经理批准了 " << request.employee << " 的 " << request.days << " 天假期。\n";
    }
};

// === 具体处理者: 总监 ===
class Director : public Handler {
protected:
    std::string getName() const override { return "总监"; }
    bool canHandle(const LeaveRequest& request) const override {
        return request.days <= 7; // 最高批7天
    }
    void doHandle(const LeaveRequest& request) override {
        std::cout << "✅ 总监批准了 " << request.employee << " 的 " << request.days << " 天假期。\n";
    }
};

// === 客户端使用 ===
int main() {
    // 构建责任链: 组长 → 经理 → 总监
    auto leader = std::make_unique<TeamLeader>();
    auto manager = std::make_unique<Manager>();
    auto director = std::make_unique<Director>();

    leader->setNext(std::move(manager));
    leader->nextHandler->setNext(std::move(director)); // 注意: manager已被move, 只能通过next访问

    // 发起请求
    std::cout << "=== 请假1天 ===\n";
    leader->handleRequest(LeaveRequest("张三", 1));

    std::cout << "\n=== 请假3天 ===\n";
    leader->handleRequest(LeaveRequest("李四", 3));

    std::cout << "\n=== 请假5天 ===\n";
    leader->handleRequest(LeaveRequest("王五", 5));

    std::cout << "\n=== 请假10天 ===\n";
    leader->handleRequest(LeaveRequest("赵六", 10));

    return 0;
}
```

## PlantUML

```
@startuml
title Chain of Responsibility Pattern

class Handler {
    -nextHandler: Handler*
    +setNext(Handler*)
    +handleRequest(request)
    {abstract} +canHandle(request) : bool
    {abstract} +doHandle(request)
    {abstract} +getName() : string
}

class TeamLeader {
    +canHandle() : bool
    +doHandle()
    +getName() : string
}

class Manager {
    +canHandle() : bool
    +doHandle()
    +getName() : string
}

class Director {
    +canHandle() : bool
    +doHandle()
    +getName() : string
}

class LeaveRequest {
    -employee: string
    -days: int
}

class Client

Handler <|-- TeamLeader
Handler <|-- Manager
Handler <|-- Director

Handler "0..1" --> "0..1" Handler : nextHandler

Client --> Handler : sends request
Client --> LeaveRequest : creates

note right of Handler
  抽象处理者
  持有下一个处理器指针
  模板方法handleRequest
end note

note right of TeamLeader
  处理 <=1 天假期
end note

@enduml
```
![](./picture/18.ChainOfResponsibilityPattern.png)


# 21.命令模式

## 简介

> 📜 命令模式(Command Pattern)
> **将“请求”封装为对象, 从而使你可以用不同的请求对客户进行参数化、排队、记录日志, 以及支持可撤销的操作。**

------

📌 1. 介绍

- **类型**: 行为型模式

- 核心思想
  - 将**一个操作(方法调用)封装成对象** → 即“命令对象”。
  - 调用者(Invoker)与接收者(Receiver)**解耦** → 通过命令对象通信。
  - 支持**撤销(Undo)、重做(Redo)、队列、日志、事务**等高级功能。

- **关键词**: 请求封装、解耦、撤销、队列、宏命令

> 💡 **类比**: 遥控器按钮(命令对象)→ 控制电视(接收者)；餐厅点餐(命令)→ 厨师(接收者)执行。

------

🎯 2. 适用场景

 ✔ 需要参数化对象操作(如回调、事件处理)
 ✔ 需要支持撤销/重做功能(如编辑器、游戏)
 ✔ 需要将操作排队或记录日志(如任务队列、事务)
 ✔ 需要将请求发送者与接收者解耦(如GUI按钮绑定不同操作)
 ✔ 实现“宏命令”或“批量操作”

------

⚖️ 3. 优缺点

| 优点                             | 缺点                                                  |
| -------------------------------- | ----------------------------------------------------- |
| ✅ 解耦调用者与接收者             | ❌ 类爆炸: 每个命令一个类(可用 `std::function` 缓解) |
| ✅ 支持撤销、重做、日志、队列     | ❌ 增加系统复杂度(小系统可能过度设计)                |
| ✅ 易于扩展新命令(符合开闭原则) | ❌ 内存开销: 命令对象需保存状态用于撤销                |
| ✅ 支持组合命令(宏命令)         |                                                       |

------

⚠️ 4. 注意事项

1. 撤销状态保存
   - 简单命令: 保存执行前状态(备忘录模式配合)
   - 复杂命令: 记录反向操作(如“移动→反向移动”)

2. 线程安全
   - 命令队列多线程消费时需加锁
   - 撤销栈需考虑并发访问

3. 现代C++建议
   - 可用 `std::function<void()>` + Lambda 实现轻量命令, 避免类爆炸。
   - 用 `std::unique_ptr<Command>` 管理命令生命周期。

4. 命令 vs 函数对象
   - 命令模式更强调“结构化封装 + 可撤销 + 可记录”
   - 函数对象(Functor)更轻量, 适合无状态回调

5. **避免过度设计**: 简单回调直接用函数指针或Lambda即可。

🧠 一句话总结命令模式: 

> **“请求封装成对象, 调用接收两不愁；撤销重做排队走, 宏命令也不愁。”**

------

✅ **经典应用**: 

- GUI 按钮/菜单命令(Qt、MFC)
- 编辑器撤销/重做(Ctrl+Z / Ctrl+Y)
- 游戏技能/道具系统
- 任务调度系统(支持暂停、取消、重试)
- 数据库事务(commit / rollback)

## 代码

智能家居遥控器 + 撤销功能

🎯 场景: 遥控器控制灯、音响；支持撤销上一条命令

```
#include <iostream>
#include <memory>
#include <vector>
#include <stack>

// === 抽象命令接口 ===
class Command {
public:
    virtual ~Command() = default;
    virtual void execute() = 0;
    virtual void undo() = 0; // 支持撤销
};

// === 接收者: 灯 ===
class Light {
    std::string location;
    bool isOn = false;

public:
    Light(const std::string& loc) : location(loc) {}

    void on() {
        isOn = true;
        std::cout << location << " 灯已打开\n";
    }

    void off() {
        isOn = false;
        std::cout << location << " 灯已关闭\n";
    }

    bool getState() const { return isOn; }
};

// === 接收者: 音响 ===
class Stereo {
    std::string location;
    int volume = 0;

public:
    Stereo(const std::string& loc) : location(loc) {}

    void on() {
        std::cout << location << " 音响已打开\n";
    }

    void off() {
        std::cout << location << " 音响已关闭\n";
    }

    void setVolume(int vol) {
        volume = vol;
        std::cout << location << " 音量设为 " << volume << "\n";
    }

    int getVolume() const { return volume; }
};

// === 具体命令: 开灯 ===
class LightOnCommand : public Command {
    Light& light;
    bool prevState; // 用于撤销

public:
    LightOnCommand(Light& l) : light(l), prevState(l.getState()) {}

    void execute() override {
        prevState = light.getState(); // 保存执行前状态
        light.on();
    }

    void undo() override {
        if (prevState) {
            light.on();
        } else {
            light.off();
        }
    }
};

// === 具体命令: 关灯 ===
class LightOffCommand : public Command {
    Light& light;
    bool prevState;

public:
    LightOffCommand(Light& l) : light(l), prevState(l.getState()) {}

    void execute() override {
        prevState = light.getState();
        light.off();
    }

    void undo() override {
        if (prevState) {
            light.on();
        } else {
            light.off();
        }
    }
};

// === 具体命令: 设置音量 ===
class StereoSetVolumeCommand : public Command {
    Stereo& stereo;
    int prevVolume;

public:
    StereoSetVolumeCommand(Stereo& s, int vol) : stereo(s), prevVolume(s.getVolume()) {
        targetVolume = vol;
    }

private:
    int targetVolume;

public:
    void execute() override {
        prevVolume = stereo.getVolume();
        stereo.setVolume(targetVolume);
    }

    void undo() override {
        stereo.setVolume(prevVolume);
    }
};

// === 调用者: 遥控器 ===
class RemoteControl {
    std::vector<std::unique_ptr<Command>> onCommands;
    std::vector<std::unique_ptr<Command>> offCommands;
    std::stack<Command*> commandHistory; // 撤销历史
    static const int NUM_SLOTS = 3;

public:
    RemoteControl() {
        onCommands.resize(NUM_SLOTS);
        offCommands.resize(NUM_SLOTS);
    }

    void setCommand(int slot, std::unique_ptr<Command> onCmd, std::unique_ptr<Command> offCmd) {
        onCommands[slot] = std::move(onCmd);
        offCommands[slot] = std::move(offCmd);
    }

    void pressOnButton(int slot) {
        if (slot < onCommands.size() && onCommands[slot]) {
            onCommands[slot]->execute();
            commandHistory.push(onCommands[slot].get());
        }
    }

    void pressOffButton(int slot) {
        if (slot < offCommands.size() && offCommands[slot]) {
            offCommands[slot]->execute();
            commandHistory.push(offCommands[slot].get());
        }
    }

    void pressUndo() {
        if (!commandHistory.empty()) {
            std::cout << "↩️  正在撤销...\n";
            commandHistory.top()->undo();
            commandHistory.pop();
        } else {
            std::cout << "⚠️  无操作可撤销\n";
        }
    }
};

// === 客户端使用 ===
int main() {
    RemoteControl remote;

    Light livingRoomLight("客厅");
    Light kitchenLight("厨房");
    Stereo stereo("客厅");

    // 设置命令
    remote.setCommand(0,
        std::make_unique<LightOnCommand>(livingRoomLight),
        std::make_unique<LightOffCommand>(livingRoomLight)
    );

    remote.setCommand(1,
        std::make_unique<LightOnCommand>(kitchenLight),
        std::make_unique<LightOffCommand>(kitchenLight)
    );

    remote.setCommand(2,
        std::make_unique<StereoSetVolumeCommand>(stereo, 11),
        std::make_unique<StereoSetVolumeCommand>(stereo, 0)
    );

    std::cout << "=== 测试操作 ===\n";
    remote.pressOnButton(0); // 开客厅灯
    remote.pressOnButton(2); // 音响音量11
    remote.pressOffButton(1); // 关厨房灯

    std::cout << "\n=== 撤销操作 ===\n";
    remote.pressUndo(); // 撤销关厨房灯 → 开厨房灯
    remote.pressUndo(); // 撤销音响音量11 → 恢复原音量
    remote.pressUndo(); // 撤销开客厅灯 → 关客厅灯

    std::cout << "\n=== 再次撤销(应无操作)===\n";
    remote.pressUndo();

    return 0;
}
```

输出

```
=== 测试操作 ===
客厅 灯已打开
客厅 音量设为 11
厨房 灯已关闭

=== 撤销操作 ===
↩️  正在撤销...
厨房 灯已打开
↩️  正在撤销...
客厅 音量设为 0
↩️  正在撤销...
客厅 灯已关闭

=== 再次撤销(应无操作)===
⚠️  无操作可撤销
```

## PlantUML

```
@startuml
title Command Pattern

interface Command {
    +execute()
    +undo()
}

class Light {
    -location: string
    -isOn: bool
    +on()
    +off()
    +getState() : bool
}

class Stereo {
    -location: string
    -volume: int
    +on()
    +off()
    +setVolume(int)
    +getVolume() : int
}

class LightOnCommand {
    -light: Light&
    -prevState: bool
    +execute()
    +undo()
}

class LightOffCommand {
    -light: Light&
    -prevState: bool
    +execute()
    +undo()
}

class StereoSetVolumeCommand {
    -stereo: Stereo&
    -prevVolume: int
    -targetVolume: int
    +execute()
    +undo()
}

class RemoteControl {
    -onCommands: vector<Command*>
    -offCommands: vector<Command*>
    -commandHistory: stack<Command*>
    +setCommand(slot, onCmd, offCmd)
    +pressOnButton(slot)
    +pressOffButton(slot)
    +pressUndo()
}

class Client

Command <|.. LightOnCommand
Command <|.. LightOffCommand
Command <|.. StereoSetVolumeCommand

LightOnCommand --> Light
LightOffCommand --> Light
StereoSetVolumeCommand --> Stereo

RemoteControl --> Command : holds

Client --> RemoteControl : uses
Client --> Light : creates
Client --> Stereo : creates

note right of Command
  封装一个请求为对象
  支持execute/undo
end note

note right of RemoteControl
  调用者Invoker
  持有命令对象
  支持撤销历史
end note

@enduml
```

![](./picture/19.CommandPattern.png)


# 22.备忘录模式

## 简介

> 📸 备忘录模式(Memento Pattern)
> **在不破坏封装性的前提下, 捕获一个对象的内部状态, 并在该对象之外保存这个状态, 以便以后可将该对象恢复到原先保存的状态。**

------

📌 1. 介绍

- **类型**: 行为型模式

- 核心角色
  - **Originator(原发器)**: 要被保存/恢复状态的对象。
  - **Memento(备忘录)**: 存储 Originator 的内部状态(通常为私有或受限访问)。
  - **Caretaker(负责人)**: 负责保存和管理 Memento, 但**不能修改或查看其内容**。

- **关键词**: 状态快照、撤销恢复、游戏存档、封装性

> 💡 **类比**: 游戏“存档/读档”、编辑器“撤销历史”、数据库“事务回滚点”。

------

🎯 2. 适用场景

 ✔ 需要保存对象在某一时刻的状态, 以便后续恢复(如撤销操作)
 ✔ 不希望暴露对象内部细节, 但又要外部保存其状态
 ✔ 实现“检查点”、“历史快照”、“事务回滚”功能
 ✔ 与**命令模式**配合实现多级撤销(每个命令保存一个备忘录)

------

⚖️ 3. 优缺点

| 优点                                          | 缺点                                       |
| --------------------------------------------- | ------------------------------------------ |
| ✅ 保持封装性: 状态由 Originator 自己管理      | ❌ 内存开销大: 保存多个快照可能占用大量内存 |
| ✅ 支持撤销、恢复、历史版本                    | ❌ 复杂对象序列化困难(需深拷贝)           |
| ✅ 简化 Originator 职责: 状态保存/恢复逻辑分离 | ❌ 频繁保存影响性能                         |
| ✅ 易于扩展: 可配合命令模式实现多级撤销        |                                            |

------

⚠️ 4. 注意事项

1. 深拷贝 vs 浅拷贝
   - 若 Originator 包含指针或动态资源, Memento **必须深拷贝**, 否则恢复时可能悬空或冲突。

2. 内存管理
   - 避免无限制保存快照 → 可设置最大历史数或自动清理。
   - 用 `std::unique_ptr<Memento>` 或 `std::vector<Memento>` 管理生命周期。

3. 封装性保护
   - Memento 类应**仅允许 Originator 访问其内部数据**(C++ 中可用 `friend` 类或嵌套类实现)。

4. 现代C++建议
   - 可用 `std::any`、`std::variant` 或序列化库(如 nlohmann/json)实现通用 Memento。
   - 对简单状态, 可用 `std::tuple` 或结构体直接保存。

5. 对比命令模式撤销
   - **命令模式**: 记录“操作+反向操作” → 轻量, 适合简单撤销
   - **备忘录模式**: 记录“完整状态快照” → 重量, 适合复杂状态恢复

🧠 一句话总结备忘录模式: 

> **“状态快照存外部, 恢复原状不暴露；封装完整是核心, 内存代价要认领。”**

------

✅ **经典应用**: 

- 游戏存档/读档系统
- 编辑器多级撤销(如 Photoshop 历史面板)
- 数据库事务保存点(SAVEPOINT)
- 虚拟机快照
- 配置回滚系统

## 代码

文本编辑器 + 多级撤销

🎯 场景: 文本编辑器支持保存历史状态, 可撤销到任意历史版本

```
#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <stack>

// === Originator: 文本编辑器 ===
class TextEditor {
    std::string content;

public:
    void type(const std::string& text) {
        content += text;
    }

    void erase(size_t len) {
        if (len <= content.length()) {
            content.erase(content.length() - len);
        }
    }

    std::string getContent() const {
        return content;
    }

    // === Memento: 嵌套类, 仅 TextEditor 可访问内部 ===
    class Memento {
        std::string state;
        friend class TextEditor; // 关键: 只有 TextEditor 能读写 state

        Memento(const std::string& s) : state(s) {}
    public:
        // 对 Caretaker 暴露只读接口(可选)
        std::string getStateSnapshot() const { return state; }
    };

    // 保存当前状态
    std::unique_ptr<Memento> save() const {
        return std::make_unique<Memento>(content);
    }

    // 恢复到指定状态
    void restore(const Memento& memento) {
        content = memento.state;
    }
};

// === Caretaker: 历史管理器 ===
class History {
    std::stack<std::unique_ptr<TextEditor::Memento>> snapshots;

public:
    void push(std::unique_ptr<TextEditor::Memento> memento) {
        snapshots.push(std::move(memento));
    }

    std::unique_ptr<TextEditor::Memento> pop() {
        if (snapshots.empty()) return nullptr;
        auto memento = std::move(snapshots.top());
        snapshots.pop();
        return memento;
    }

    bool isEmpty() const {
        return snapshots.empty();
    }
};

// === 客户端使用 ===
int main() {
    TextEditor editor;
    History history;

    auto saveSnapshot = [&]() {
        history.push(editor.save());
        std::cout << "💾 保存快照: \"" << editor.getContent() << "\"\n";
    };

    auto undo = [&]() {
        auto memento = history.pop();
        if (memento) {
            editor.restore(*memento);
            std::cout << "↩️  撤销到: \"" << editor.getContent() << "\"\n";
        } else {
            std::cout << "⚠️  无历史记录可恢复\n";
        }
    };

    std::cout << "=== 开始编辑 ===\n";
    editor.type("Hello");
    saveSnapshot();

    editor.type(", World!");
    saveSnapshot();

    editor.type(" How are you?");
    saveSnapshot();

    std::cout << "\n=== 当前内容: \"" << editor.getContent() << "\"\n";

    std::cout << "\n=== 执行撤销 ===\n";
    undo(); // 撤销 " How are you?"
    undo(); // 撤销 ", World!"

    std::cout << "\n=== 再次输入 ===\n";
    editor.type(" C++ Programmer!");
    saveSnapshot();

    std::cout << "\n=== 最终内容: \"" << editor.getContent() << "\"\n";

    return 0;
}
```

```
=== 开始编辑 ===
💾 保存快照: "Hello"
💾 保存快照: "Hello, World!"
💾 保存快照: "Hello, World! How are you?"

=== 当前内容: "Hello, World! How are you?"

=== 执行撤销 ===
↩️  撤销到: "Hello, World!"
↩️  撤销到: "Hello"

=== 再次输入 ===
💾 保存快照: "Hello C++ Programmer!"

=== 最终内容: "Hello C++ Programmer!"
```

## PlantUML

```
@startuml
title Memento Pattern

class TextEditor {
    -content: string
    +type(text)
    +erase(len)
    +getContent() : string
    +save() : Memento*
    +restore(memento)
}

class TextEditor.Memento {
    -state: string
    +getStateSnapshot() : string
}

class History {
    -snapshots: stack<Memento*>
    +push(memento)
    +pop() : Memento*
    +isEmpty() : bool
}

class Client

TextEditor +-- Memento : creates
TextEditor --> Memento : restores from
History --> Memento : holds (cannot modify)
Client --> TextEditor : uses
Client --> History : manages snapshots

note right of TextEditor.Memento
  仅TextEditor可访问内部state
  保护封装性
end note

note right of History
  Caretaker角色
  仅保存/弹出, 不修改内容
end note

@enduml
```

![](./picture/20.MementoPattern.png)


# 23.状态模式

## 简介

> 🔄 状态模式(State Pattern)
> **允许对象在其内部状态改变时改变其行为, 对象看起来似乎修改了它的类。**

------

📌 1. 介绍

- **类型**: 行为型模式

- 核心思想
  - 将**对象的行为封装到不同的“状态类”中**。
  - 对象(Context)**持有当前状态对象**, 行为委托给当前状态处理。
  - **状态转换由状态类自身或 Context 控制** → 行为随状态自动切换。

- **关键词**: 状态驱动行为、行为切换、状态机、避免大量 if-else

> 💡 **类比**: 电梯(开门/关门/运行/停止)、游戏角色(站立/奔跑/攻击/死亡)、订单状态(待支付→已支付→发货→完成)

------

🎯 2. 适用场景

 ✔ 对象行为依赖于它的状态, 且必须在运行时根据状态改变行为
 ✔ 代码中包含大量与对象状态有关的条件语句(if-else / switch)
 ✔ 需要将“状态相关行为”局部化, 避免状态逻辑散落在各处
 ✔ 实现有限状态机(FSM)或工作流引擎

------

⚖️ 3. 优缺点

| 优点                                          | 缺点                                         |
| --------------------------------------------- | -------------------------------------------- |
| ✅ 消除大量条件分支, 代码更清晰                | ❌ 增加类数量(每个状态一个类)               |
| ✅ 符合开闭原则: 新增状态不修改原有代码        | ❌ 状态间转换逻辑可能复杂(需设计好转换规则) |
| ✅ 状态职责清晰, 易于维护和测试                | ❌ 过度设计: 简单状态用 enum + switch 更轻量  |
| ✅ 支持状态间灵活转换(可由状态或Context控制) |                                              |

------

⚠️ 4. 注意事项

1. 状态转换控制权
   - **由状态类控制**: 更灵活, 但状态类需知道其他状态(耦合)
   - **由 Context 控制**: 更安全, 状态类职责单一(推荐)

2. 避免循环依赖
   - 状态类不应直接持有 Context 强引用 → 可用弱引用或接口。

3. 状态对象共享
   - 若状态无成员变量 → 可设为单例, 节省内存。

4. 现代C++建议
   - 用 `std::unique_ptr<State>` 管理状态生命周期。
   - 用 `enum class` + `switch` 实现简单状态机 → 更高效。
   - 复杂状态机可用状态模式 + 策略模式组合。

5. 对比策略模式
   - **策略模式**: 客户端主动切换算法
   - **状态模式**: 对象根据自身状态自动切换行为

🧠 一句话总结状态模式: 

> **“状态驱动行为变, 委托状态来实现；告别满屏if-else, 状态切换更体面。”**

------

✅ **经典应用**: 

- 电梯控制系统
- 游戏角色状态(站立/奔跑/攻击/死亡)
- 订单状态机(待支付→已支付→发货→完成→退款)
- TCP连接状态(CLOSED → LISTEN → ESTABLISHED → ...)
- UI控件状态(按钮: 正常/悬停/按下/禁用)

## 代码

电梯控制系统

🎯 场景: 电梯有“开门”、“关门”、“运行”、“停止”四种状态, 不同状态下可执行不同操作

```
#include <iostream>
#include <memory>
#include <string>

// 前向声明
class Elevator;

// === 抽象状态接口 ===
class ElevatorState {
public:
    virtual ~ElevatorState() = default;
    virtual void openDoor(Elevator& elevator) = 0;
    virtual void closeDoor(Elevator& elevator) = 0;
    virtual void run(Elevator& elevator) = 0;
    virtual void stop(Elevator& elevator) = 0;
    virtual std::string getName() const = 0;
};

// === 具体状态类 ===
class OpeningState : public ElevatorState {
public:
    void openDoor(Elevator& elevator) override {
        std::cout << "🚪 门已打开, 无需重复操作\n";
    }

    void closeDoor(Elevator& elevator) override {
        std::cout << "✅ 门已关闭\n";
        elevator.setState(std::make_unique<StoppingState>());
    }

    void run(Elevator& elevator) override {
        std::cout << "❌ 门未关, 不能运行！\n";
    }

    void stop(Elevator& elevator) override {
        std::cout << "⏸️  电梯已停止, 门开着\n";
    }

    std::string getName() const override { return "开门状态"; }
};

class ClosingState : public ElevatorState {
public:
    void openDoor(Elevator& elevator) override {
        std::cout << "✅ 门重新打开\n";
        elevator.setState(std::make_unique<OpeningState>());
    }

    void closeDoor(Elevator& elevator) override {
        std::cout << "✅ 门已关闭\n";
        elevator.setState(std::make_unique<StoppingState>());
    }

    void run(Elevator& elevator) override {
        std::cout << "❌ 门正在关闭中, 不能运行！\n";
    }

    void stop(Elevator& elevator) override {
        std::cout << "⏸️  电梯已停止, 门正在关闭\n";
    }

    std::string getName() const override { return "关门状态"; }
};

class RunningState : public ElevatorState {
public:
    void openDoor(Elevator& elevator) override {
        std::cout << "❌ 电梯运行中, 禁止开门！\n";
    }

    void closeDoor(Elevator& elevator) override {
        std::cout << "✅ 门已关闭(运行中保持关闭)\n";
    }

    void run(Elevator& elevator) override {
        std::cout << "🚀 电梯正在运行\n";
    }

    void stop(Elevator& elevator) override {
        std::cout << "✅ 电梯已停止\n";
        elevator.setState(std::make_unique<StoppingState>());
    }

    std::string getName() const override { return "运行状态"; }
};

class StoppingState : public ElevatorState {
public:
    void openDoor(Elevator& elevator) override {
        std::cout << "✅ 门已打开\n";
        elevator.setState(std::make_unique<OpeningState>());
    }

    void closeDoor(Elevator& elevator) override {
        std::cout << "✅ 门已关闭(保持关闭)\n";
    }

    void run(Elevator& elevator) override {
        std::cout << "🚀 电梯开始运行\n";
        elevator.setState(std::make_unique<RunningState>());
    }

    void stop(Elevator& elevator) override {
        std::cout << "⏸️  电梯已停止\n";
    }

    std::string getName() const override { return "停止状态"; }
};

// === Context: 电梯 ===
class Elevator {
    std::unique_ptr<ElevatorState> currentState;

public:
    Elevator() {
        // 初始状态: 停止
        currentState = std::make_unique<StoppingState>();
    }

    void setState(std::unique_ptr<ElevatorState> state) {
        std::cout << "🔄 状态切换: " << currentState->getName() << " → " << state->getName() << "\n";
        currentState = std::move(state);
    }

    void openDoor() {
        std::cout << "\n[操作] 开门 → ";
        currentState->openDoor(*this);
    }

    void closeDoor() {
        std::cout << "\n[操作] 关门 → ";
        currentState->closeDoor(*this);
    }

    void run() {
        std::cout << "\n[操作] 运行 → ";
        currentState->run(*this);
    }

    void stop() {
        std::cout << "\n[操作] 停止 → ";
        currentState->stop(*this);
    }

    std::string getCurrentStateName() const {
        return currentState->getName();
    }
};

// === 客户端使用 ===
int main() {
    Elevator elevator;

    std::cout << "=== 电梯初始状态: " << elevator.getCurrentStateName() << " ===\n";

    elevator.openDoor();   // → 开门状态
    elevator.closeDoor();  // → 停止状态
    elevator.run();        // → 运行状态
    elevator.openDoor();   // 非法操作
    elevator.stop();       // → 停止状态
    elevator.run();        // → 运行状态
    elevator.stop();       // → 停止状态

    std::cout << "\n=== 最终状态: " << elevator.getCurrentStateName() << " ===\n";

    return 0;
}
```

```
=== 电梯初始状态: 停止状态 ===

[操作] 开门 → ✅ 门已打开
🔄 状态切换: 停止状态 → 开门状态

[操作] 关门 → ✅ 门已关闭
🔄 状态切换: 开门状态 → 停止状态

[操作] 运行 → 🚀 电梯开始运行
🔄 状态切换: 停止状态 → 运行状态

[操作] 开门 → ❌ 电梯运行中, 禁止开门！

[操作] 停止 → ✅ 电梯已停止
🔄 状态切换: 运行状态 → 停止状态

[操作] 运行 → 🚀 电梯开始运行
🔄 状态切换: 停止状态 → 运行状态

[操作] 停止 → ✅ 电梯已停止
🔄 状态切换: 运行状态 → 停止状态

=== 最终状态: 停止状态 ===
```

## PlantUML

```
@startuml
title State Pattern

class Elevator {
    -currentState: ElevatorState*
    +setState(state)
    +openDoor()
    +closeDoor()
    +run()
    +stop()
    +getCurrentStateName() : string
}

interface ElevatorState {
    +openDoor(elevator)
    +closeDoor(elevator)
    +run(elevator)
    +stop(elevator)
    +getName() : string
}

class OpeningState {
    +openDoor()
    +closeDoor()
    +run()
    +stop()
    +getName()
}

class ClosingState {
    +openDoor()
    +closeDoor()
    +run()
    +stop()
    +getName()
}

class RunningState {
    +openDoor()
    +closeDoor()
    +run()
    +stop()
    +getName()
}

class StoppingState {
    +openDoor()
    +closeDoor()
    +run()
    +stop()
    +getName()
}

Elevator --> ElevatorState : currentState
ElevatorState <|.. OpeningState
ElevatorState <|.. ClosingState
ElevatorState <|.. RunningState
ElevatorState <|.. StoppingState

note right of Elevator
  Context角色
  持有当前状态对象
  行为委托给状态处理
end note

note right of ElevatorState
  状态接口
  所有状态必须实现
end note

@enduml
```

![](./picture/21.StatePattern.png)

# 24.访问者模式

## 简介

> 👤 访问者模式(Visitor Pattern)
> **将作用于某种数据结构中各元素的操作分离出来封装成独立的类, 使其可以在不改变各元素类的前提下定义作用于这些元素的新操作。**

------

📌 1. 介绍

- **类型**: 行为型模式

- 核心思想
  - 数据结构(Element)稳定, 但**操作(行为)经常变化** → 将“操作”从“数据结构”中解耦。
  - 通过“双分派”(Double Dispatch)实现: Element 接收 Visitor, Visitor 根据 Element 类型调用对应方法。

- **关键词**: 双分派、操作与数据结构解耦、扩展新操作、遍历复杂结构

> 💡 **类比**: 
> - 医院: 病人(Element)不动, 不同医生(Visitor)来巡诊(开药/做手术/心理咨询)
> - 税务系统: 员工类型(工程师/经理/销售)固定, 不同访问者计算“个税”、“社保”、“奖金”

------

🎯 2. 适用场景

 ✔ 数据结构相对稳定, 但需频繁新增操作(如导出、打印、序列化、统计)
 ✔ 需要对一个复杂对象结构(如组合模式)中的对象执行多种不同操作
 ✔ 希望在不修改 Element 类的情况下增加新行为(符合开闭原则)
 ✔ 实现“操作”与“数据结构”的彻底分离

------

⚖️ 3. 优缺点

| 优点                                                | 缺点                                                         |
| --------------------------------------------------- | ------------------------------------------------------------ |
| ✅ 符合开闭原则: 新增操作无需修改 Element 类         | ❌ 新增 Element 类需修改所有 Visitor → 违反开闭原则           |
| ✅ 聚合相关操作: 所有访问逻辑集中在一个 Visitor 类中 | ❌ 破坏封装性: Visitor 需访问 Element 内部数据(常需设为 friend) |
| ✅ 易于增加新操作(只需新增 Visitor 类)             | ❌ 双分派在 C++ 中需手动实现(无动态多分派)                  |
| ✅ 适合复杂对象结构(如树、图、组合模式)            | ❌ 学习成本高, 结构复杂                                       |

------

⚠️ 4. 注意事项

1. 双分派实现
   - C++ 无原生多分派 → 需 Element 调用 `visitor.visit(*this)` 实现第二次分派。

2. 封装性破坏
   - Visitor 常需访问 Element 私有成员 → 可将 Visitor 设为 Element 的 `friend`, 或提供 `public` 接口。

3. 新增 Element 的代价
   - 每新增一个 Element 类 → 所有 Visitor 类需增加对应 `visit()` 方法 → **不适合 Element 频繁变化的场景**。

4. 现代C++建议
   - 用 `std::variant` + `std::visit` 实现轻量级访问者(C++17)。
   - 用 Lambda + 函数对象替代传统 Visitor 类(更灵活)。

5. 与迭代器模式对比
   - 迭代器: 遍历元素
   - 访问者: 对每个元素执行特定操作(常配合迭代器使用)

🧠 一句话总结访问者模式: 

> **“元素稳定操作变, 访问者来解耦；双分派是核心, 新增操作不用改元素。”**

------

✅ **经典应用**: 

- 编译器: AST(抽象语法树)遍历(语义分析、代码生成、优化)
- 文档处理: 对不同文档元素(段落/表格/图片)执行“渲染”、“统计字数”、“导出PDF”
- 游戏: 对不同游戏对象(敌人/道具/地形)执行“碰撞检测”、“渲染”、“存档”
- 财务系统: 对不同资产类型计算“折旧”、“税率”、“风险值”

## 代码

公司员工薪资统计系统

🎯 场景: 公司有“工程师”、“经理”、“销售”三种员工, 需支持“计算总薪资”、“打印员工信息”、“导出到JSON”等操作

```
#include <iostream>
#include <vector>
#include <string>
#include <memory>
#include <iomanip>

// === 前向声明 ===
class Engineer;
class Manager;
class Salesman;

// === 抽象访问者 ===
class Visitor {
public:
    virtual ~Visitor() = default;
    virtual void visit(Engineer& engineer) = 0;
    virtual void visit(Manager& manager) = 0;
    virtual void visit(Salesman& salesman) = 0;
};

// === 抽象元素(员工) ===
class Employee {
public:
    virtual ~Employee() = default;
    virtual void accept(Visitor& visitor) = 0; // 双分派关键
    virtual std::string getName() const = 0;
    virtual double getBaseSalary() const = 0;
};

// === 具体元素: 工程师 ===
class Engineer : public Employee {
    std::string name;
    double baseSalary;
    int overtimeHours; // 加班小时

public:
    Engineer(const std::string& n, double salary, int hours)
        : name(n), baseSalary(salary), overtimeHours(hours) {}

    void accept(Visitor& visitor) override {
        visitor.visit(*this); // 双分派: 调用具体 visit(Engineer&)
    }

    std::string getName() const override { return name; }
    double getBaseSalary() const override { return baseSalary; }
    int getOvertimeHours() const { return overtimeHours; }
    double getOvertimePay() const { return overtimeHours * 50.0; } // 加班费每小时50
};

// === 具体元素: 经理 ===
class Manager : public Employee {
    std::string name;
    double baseSalary;
    double bonusRate; // 奖金比例

public:
    Manager(const std::string& n, double salary, double rate)
        : name(n), baseSalary(salary), bonusRate(rate) {}

    void accept(Visitor& visitor) override {
        visitor.visit(*this);
    }

    std::string getName() const override { return name; }
    double getBaseSalary() const override { return baseSalary; }
    double getBonusRate() const { return bonusRate; }
    double getBonus() const { return baseSalary * bonusRate; }
};

// === 具体元素: 销售 ===
class Salesman : public Employee {
    std::string name;
    double baseSalary;
    double salesAmount; // 销售额
    double commissionRate; // 提成比例

public:
    Salesman(const std::string& n, double salary, double amount, double rate)
        : name(n), baseSalary(salary), salesAmount(amount), commissionRate(rate) {}

    void accept(Visitor& visitor) override {
        visitor.visit(*this);
    }

    std::string getName() const override { return name; }
    double getBaseSalary() const override { return baseSalary; }
    double getSalesAmount() const { return salesAmount; }
    double getCommissionRate() const { return commissionRate; }
    double getCommission() const { return salesAmount * commissionRate; }
};

// === 具体访问者1: 薪资计算器 ===
class SalaryCalculator : public Visitor {
    double totalSalary = 0.0;

public:
    void visit(Engineer& engineer) override {
        double salary = engineer.getBaseSalary() + engineer.getOvertimePay();
        totalSalary += salary;
        std::cout << "🧰 工程师 " << engineer.getName() << " 薪资: ¥" << salary << "\n";
    }

    void visit(Manager& manager) override {
        double salary = manager.getBaseSalary() + manager.getBonus();
        totalSalary += salary;
        std::cout << "👔 经理 " << manager.getName() << " 薪资: ¥" << salary << "\n";
    }

    void visit(Salesman& salesman) override {
        double salary = salesman.getBaseSalary() + salesman.getCommission();
        totalSalary += salary;
        std::cout << "🛍️  销售 " << salesman.getName() << " 薪资: ¥" << salary << "\n";
    }

    double getTotalSalary() const { return totalSalary; }
};

// === 具体访问者2: 员工信息打印机 ===
class EmployeePrinter : public Visitor {
public:
    void visit(Engineer& engineer) override {
        std::cout << "🧰 工程师: " << engineer.getName()
                  << " | 基本工资: ¥" << engineer.getBaseSalary()
                  << " | 加班: " << engineer.getOvertimeHours() << "小时\n";
    }

    void visit(Manager& manager) override {
        std::cout << "👔 经理: " << manager.getName()
                  << " | 基本工资: ¥" << manager.getBaseSalary()
                  << " | 奖金率: " << manager.getBonusRate() * 100 << "%\n";
    }

    void visit(Salesman& salesman) override {
        std::cout << "🛍️  销售: " << salesman.getName()
                  << " | 基本工资: ¥" << salesman.getBaseSalary()
                  << " | 销售额: ¥" << salesman.getSalesAmount()
                  << " | 提成率: " << salesman.getCommissionRate() * 100 << "%\n";
    }
};

// === 公司类(对象结构) ===
class Company {
    std::vector<std::unique_ptr<Employee>> employees;

public:
    void addEmployee(std::unique_ptr<Employee> emp) {
        employees.push_back(std::move(emp));
    }

    void accept(Visitor& visitor) {
        for (auto& emp : employees) {
            emp->accept(visitor); // 双分派触发
        }
    }
};

// === 客户端使用 ===
int main() {
    Company company;

    // 添加员工
    company.addEmployee(std::make_unique<Engineer>("张三", 8000, 10));
    company.addEmployee(std::make_unique<Manager>("李四", 15000, 0.2));
    company.addEmployee(std::make_unique<Salesman>("王五", 6000, 200000, 0.05));

    std::cout << "=== 员工信息 ===\n";
    EmployeePrinter printer;
    company.accept(printer);

    std::cout << "\n=== 薪资计算 ===\n";
    SalaryCalculator calculator;
    company.accept(calculator);
    std::cout << "\n💰 公司总薪资支出: ¥" << std::fixed << std::setprecision(2)
              << calculator.getTotalSalary() << "\n";

    return 0;
}
```

输出

```
=== 员工信息 ===
🧰 工程师: 张三 | 基本工资: ¥8000 | 加班: 10小时
👔 经理: 李四 | 基本工资: ¥15000 | 奖金率: 20%
🛍️  销售: 王五 | 基本工资: ¥6000 | 销售额: ¥200000 | 提成率: 5%

=== 薪资计算 ===
🧰 工程师 张三 薪资: ¥8500
👔 经理 李四 薪资: ¥18000
🛍️  销售 王五 薪资: ¥16000

💰 公司总薪资支出: ¥42500.00
```

## PlantUML

```
@startuml
title Visitor Pattern

interface Visitor {
    +visit(engineer: Engineer)
    +visit(manager: Manager)
    +visit(salesman: Salesman)
}

abstract class Employee {
    +accept(visitor: Visitor)
    +getName() : string
    +getBaseSalary() : double
}

class Engineer {
    -name: string
    -baseSalary: double
    -overtimeHours: int
    +getOvertimeHours() : int
    +getOvertimePay() : double
}

class Manager {
    -name: string
    -baseSalary: double
    -bonusRate: double
    +getBonusRate() : double
    +getBonus() : double
}

class Salesman {
    -name: string
    -baseSalary: double
    -salesAmount: double
    -commissionRate: double
    +getSalesAmount() : double
    +getCommissionRate() : double
    +getCommission() : double
}

class SalaryCalculator {
    -totalSalary: double
    +getTotalSalary() : double
}

class EmployeePrinter

class Company {
    -employees: vector<Employee*>
    +addEmployee(emp)
    +accept(visitor)
}

Visitor <|.. SalaryCalculator
Visitor <|.. EmployeePrinter

Employee <|-- Engineer
Employee <|-- Manager
Employee <|-- Salesman

Company --> Employee : contains
Company --> Visitor : accepts

note right of Visitor
  抽象访问者
  定义对每种元素的操作
end note

note right of Employee
  抽象元素
  accept方法实现双分派
end note

note right of Company
  对象结构(Object Structure)
  管理元素集合, 提供遍历
end note

@enduml
```

![](./picture/22.VisitorPattern.png)


# 25.中介者模式

## 简介

🧩 中介者模式(Mediator Pattern)

> **用一个中介对象来封装一系列对象之间的交互。中介者使各对象不需要显式地相互引用, 从而使其耦合松散, 而且可以独立地改变它们之间的交互。**

------

📌 1. 介绍

- **类型**: 行为型模式

- 核心思想
  - 对象之间**不直接通信**, 而是通过“中介者”协调。
  - **降低对象间的耦合度**, 将“多对多”依赖 → “多对一”(所有对象依赖中介者)。

- **关键词**: 解耦、集中控制、通信枢纽、避免网状依赖

> 💡 **类比**: 
> - 机场塔台(中介者)协调所有飞机起降(对象)
> - 聊天室服务器(中介者)转发用户消息(对象)
> - GUI框架中, 对话框(中介者)协调按钮、文本框、列表框交互

------

🎯 2. 适用场景

 ✔ 对象之间存在复杂的网状引用关系, 导致系统结构混乱、难以维护
 ✔ 想复用一个对象, 但其需要与很多其他对象交互 → 通过中介者统一管理
 ✔ 想封装对象间的复杂通信逻辑, 使其可独立变化
 ✔ 实现“发布-订阅”、“事件总线”、“聊天室”、“GUI组件联动”

------

⚖️ 3. 优缺点

| 优点                               | 缺点                                       |
| ---------------------------------- | ------------------------------------------ |
| ✅ 降低对象间耦合度, 符合迪米特法则 | ❌ 中介者可能变得过于复杂和庞大(上帝对象) |
| ✅ 集中管理交互逻辑, 便于维护和扩展 | ❌ 中介者承担过多职责, 违反单一职责原则     |
| ✅ 对象可独立变化, 复用性高         | ❌ 系统性能可能受影响(所有交互经中介者)   |
| ✅ 易于增加新对象或新交互规则       | ❌ 调试困难(交互路径变长)                 |

------

⚠️ 4. 注意事项

1. 避免“上帝中介者”
   - 中介者不应承担过多业务逻辑 → 可拆分为多个中介者或配合其他模式(如命令模式)。

2. 对象注册机制
   - 对象应能动态注册/注销到中介者 → 用 `std::vector<std::weak_ptr<Colleague>>` 避免循环引用。

3. 现代C++建议
   - 用 `std::function` + Lambda 实现灵活的消息处理。
   - 用 `std::unordered_map<std::string, std::function<...>>` 实现“消息路由”。

4. 与观察者模式对比
   - **观察者**: 一对多“发布-订阅”, 被观察者主动通知
   - **中介者**: 多对多“协调通信”, 中介者主动调度

5. 性能考虑
   - 高频通信场景 → 考虑直接通信或事件队列优化

🧠 一句话总结中介者模式: 

> **“对象通信找中介, 解耦网状依赖；集中控制是核心, 避免直接引用。”**

------

✅ **经典应用**: 

- GUI框架: 对话框协调按钮、文本框、下拉框联动
- 聊天室/即时通讯系统
- 机场塔台调度飞机起降
- 游戏AI: AI指挥官协调多个单位行动
- MVC架构中, Controller 作为中介者协调 Model 和 View

## 代码

聊天室系统

🎯 场景: 多个用户加入聊天室, 通过聊天室中介者发送/接收消息, 用户之间不直接通信

```
#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <algorithm>

// === 前向声明 ===
class ChatRoom;

// === 抽象同事类(用户) ===
class User {
protected:
    std::string name;
    ChatRoom* chatRoom; // 持有中介者引用

public:
    User(const std::string& n) : name(n), chatRoom(nullptr) {}
    virtual ~User() = default;

    void setChatRoom(ChatRoom* room) { chatRoom = room; }
    std::string getName() const { return name; }

    // 发送消息(委托给中介者)
    void sendMessage(const std::string& message) {
        if (chatRoom) {
            chatRoom->sendMessage(this, message);
        }
    }

    // 接收消息(由中介者调用)
    virtual void receiveMessage(const std::string& from, const std::string& message) {
        std::cout << "📩 [" << name << "] 收到来自 " << from << " 的消息: \"" << message << "\"\n";
    }
};

// === 具体同事类: 普通用户 ===
class NormalUser : public User {
public:
    using User::User;
};

// === 具体同事类: VIP用户(消息带⭐) ===
class VIPUser : public User {
public:
    using User::User;

    void receiveMessage(const std::string& from, const std::string& message) override {
        std::cout << "⭐ [" << name << "] 收到VIP消息 from " << from << ": \"" << message << "\"\n";
    }
};

// === 中介者: 聊天室 ===
class ChatRoom {
    std::vector<std::shared_ptr<User>> users;

public:
    void addUser(std::shared_ptr<User> user) {
        user->setChatRoom(this);
        users.push_back(user);
        std::cout << "✅ 用户 \"" << user->getName() << "\" 加入聊天室\n";
    }

    void removeUser(const std::string& name) {
        users.erase(
            std::remove_if(users.begin(), users.end(),
                [&](const std::shared_ptr<User>& u) { return u->getName() == name; }),
            users.end()
        );
        std::cout << "❌ 用户 \"" << name << "\" 离开聊天室\n";
    }

    // 核心: 中介者负责消息分发
    void sendMessage(User* sender, const std::string& message) {
        std::cout << "\n📤 [" << sender->getName() << "] 发送: \"" << message << "\"\n";
        for (auto& user : users) {
            if (user.get() != sender) { // 不发给自己
                user->receiveMessage(sender->getName(), message);
            }
        }
    }

    void broadcastSystemMessage(const std::string& msg) {
        std::cout << "\n📢 系统广播: " << msg << "\n";
        for (auto& user : users) {
            user->receiveMessage("系统", msg);
        }
    }

    size_t getUserCount() const { return users.size(); }
};

// === 客户端使用 ===
int main() {
    ChatRoom chatRoom;

    // 创建用户
    auto alice = std::make_shared<NormalUser>("Alice");
    auto bob = std::make_shared<VIPUser>("Bob");
    auto charlie = std::make_shared<NormalUser>("Charlie");

    // 加入聊天室
    chatRoom.addUser(alice);
    chatRoom.addUser(bob);
    chatRoom.addUser(charlie);

    std::cout << "\n=== 开始聊天 ===\n";
    alice->sendMessage("大家好, 我是Alice！");
    bob->sendMessage("我是VIP用户Bob ⭐");
    charlie->sendMessage("我是Charlie, 很高兴认识大家！");

    std::cout << "\n=== 系统广播 ===\n";
    chatRoom.broadcastSystemMessage("服务器将在5分钟后维护, 请保存聊天记录。");

    std::cout << "\n=== 用户离开 ===\n";
    chatRoom.removeUser("Alice");
    bob->sendMessage("Alice离开了...");

    std::cout << "\n=== 当前在线人数: " << chatRoom.getUserCount() << " ===\n";

    return 0;
}
```

输出

```
✅ 用户 "Alice" 加入聊天室
✅ 用户 "Bob" 加入聊天室
✅ 用户 "Charlie" 加入聊天室

=== 开始聊天 ===

📤 [Alice] 发送: "大家好, 我是Alice！"
⭐ [Bob] 收到VIP消息 from Alice: "大家好, 我是Alice！"
📩 [Charlie] 收到来自 Alice 的消息: "大家好, 我是Alice！"

📤 [Bob] 发送: "我是VIP用户Bob ⭐"
📩 [Alice] 收到来自 Bob 的消息: "我是VIP用户Bob ⭐"
📩 [Charlie] 收到来自 Bob 的消息: "我是VIP用户Bob ⭐"

📤 [Charlie] 发送: "我是Charlie, 很高兴认识大家！"
📩 [Alice] 收到来自 Charlie 的消息: "我是Charlie, 很高兴认识大家！"
⭐ [Bob] 收到VIP消息 from Charlie: "我是Charlie, 很高兴认识大家！"

=== 系统广播 ===

📢 系统广播: 服务器将在5分钟后维护, 请保存聊天记录。
📩 [Alice] 收到来自 系统 的消息: "服务器将在5分钟后维护, 请保存聊天记录。"
⭐ [Bob] 收到VIP消息 from 系统: "服务器将在5分钟后维护, 请保存聊天记录。"
📩 [Charlie] 收到来自 系统 的消息: "服务器将在5分钟后维护, 请保存聊天记录。"

=== 用户离开 ===
❌ 用户 "Alice" 离开聊天室

📤 [Bob] 发送: "Alice离开了..."
📩 [Charlie] 收到来自 Bob 的消息: "Alice离开了..."

=== 当前在线人数: 2 ===
```

## PlantUML

```
@startuml
title Mediator Pattern

interface Mediator {
    +sendMessage(sender, message)
    +addUser(user)
    +removeUser(name)
}

class ChatRoom {
    -users: vector<shared_ptr<User>>
    +sendMessage(sender, message)
    +addUser(user)
    +removeUser(name)
    +broadcastSystemMessage(msg)
    +getUserCount() : size_t
}

abstract class User {
    -name: string
    -chatRoom: ChatRoom*
    +sendMessage(message)
    +receiveMessage(from, message)
    +getName() : string
    +setChatRoom(room)
}

class NormalUser {
    +receiveMessage(from, message)
}

class VIPUser {
    +receiveMessage(from, message)
}

Mediator <|.. ChatRoom

User <|-- NormalUser
User <|-- VIPUser

ChatRoom --> User : manages
User --> ChatRoom : holds reference

note right of Mediator
  中介者接口
  定义对象间交互协议
end note

note right of ChatRoom
  具体中介者
  集中管理所有用户和消息分发
end note

note right of User
  抽象同事类
  通过中介者通信, 不直接引用其他同事
end note

@enduml
```

![](./picture/23.MediatorPattern.png)


# 26.解释器模式

## 简介

> 🧮 解释器模式(Interpreter Pattern)
> **给定一个语言, 定义它的文法的一种表示, 并定义一个解释器, 这个解释器使用该表示来解释语言中的句子。**

------

📌 1. 介绍

- **类型**: 行为型模式

- 核心思想
  - 将**语法规则**抽象为类(终结符表达式、非终结符表达式)。
  - 构建**抽象语法树(AST)**, 通过递归解释执行。
  - 适用于**简单语言**或**特定领域语言(DSL)** 的解析与执行。

- **关键词**: 文法、解释器、AST、递归解释、终结符/非终结符

> 💡 **类比**: 
>
> - 计算器解释 “1 + 2 * 3”
> - 正则表达式引擎解释 “a*b+”
> - SQL 解析器解释 “SELECT * FROM users WHERE age > 18”

------

🎯 2. 适用场景

 ✔ 需要解释执行**简单语法规则**(如数学表达式、布尔表达式、配置规则)
 ✔ 语法规则**相对稳定**, 但需要频繁解释不同“句子”
 ✔ 实现**特定领域语言(DSL)**, 如规则引擎、配置语言、脚本语言子集
 ✔ 语法可表示为**树形结构(AST)**

> ❗ **不适用于复杂语言(如完整编程语言)** → 应使用专业解析器生成工具(如 ANTLR, Bison)

------

⚖️ 3. 优缺点

| 优点                                  | 缺点                                              |
| ------------------------------------- | ------------------------------------------------- |
| ✅ 易于改变和扩展文法(新增表达式类)  | ❌ 复杂文法会导致类爆炸(每个规则一个类)          |
| ✅ 实现文法较直观(类结构 ≈ 语法规则) | ❌ 执行效率较低(递归解释, 无优化)                |
| ✅ 易于实现解释器(递归调用)          | ❌ 维护困难(文法变更需修改多个类)                |
| ✅ 适合简单DSL或配置规则引擎           | ❗ 仅适合简单语法, 复杂语法应使用 Parser Generator |

------

⚠️ 4. 注意事项

1. 文法复杂度控制
   - 仅适用于**简单文法**(如四则运算、布尔逻辑)。
   - 复杂文法 → 用 **ANTLR / Bison / Boost.Spirit**。

2. 性能优化
   - 可加入“缓存解释结果”或“编译为字节码”提升性能。

3. 现代C++建议
   - 用 `std::variant` + `std::visit` 实现轻量表达式树(C++17)。
   - 用 Lambda 表达式构建动态规则。

4. 与策略模式对比
   - 策略: 算法切换
   - 解释器: 语法规则解释

5. 扩展性
   - 新增运算符 → 新增 Expression 子类, 符合开闭原则。

🧠 一句话总结解释器模式: 

> **“文法变类树, 解释递归走；适合小DSL, 复杂语法莫强求。”**

------

✅ **经典应用**: 

- 计算器(四则运算表达式)
- 布尔规则引擎(权限控制、风控规则)
- 正则表达式简化版
- SQL WHERE 条件解析
- 配置文件规则解析(如 Nginx rewrite 规则)

## 代码

布尔表达式解释器

🎯 场景: 解释执行布尔表达式, 如 `(true and false) or true`

```
#include <iostream>
#include <string>
#include <memory>
#include <map>
#include <sstream>
#include <cctype>

// === 抽象表达式接口 ===
class Expression {
public:
    virtual ~Expression() = default;
    virtual bool interpret(const std::map<std::string, bool>& context) const = 0;
};

// === 终结符表达式: 布尔常量 ===
class BooleanExpression : public Expression {
    bool value;

public:
    explicit BooleanExpression(bool v) : value(v) {}

    bool interpret(const std::map<std::string, bool>&) const override {
        return value;
    }
};

// === 终结符表达式: 变量 ===
class VariableExpression : public Expression {
    std::string name;

public:
    explicit VariableExpression(const std::string& n) : name(n) {}

    bool interpret(const std::map<std::string, bool>& context) const override {
        auto it = context.find(name);
        if (it != context.end()) {
            return it->second;
        }
        throw std::runtime_error("Undefined variable: " + name);
    }
};

// === 非终结符表达式: AND ===
class AndExpression : public Expression {
    std::unique_ptr<Expression> left;
    std::unique_ptr<Expression> right;

public:
    AndExpression(std::unique_ptr<Expression> l, std::unique_ptr<Expression> r)
        : left(std::move(l)), right(std::move(r)) {}

    bool interpret(const std::map<std::string, bool>& context) const override {
        return left->interpret(context) && right->interpret(context);
    }
};

// === 非终结符表达式: OR ===
class OrExpression : public Expression {
    std::unique_ptr<Expression> left;
    std::unique_ptr<Expression> right;

public:
    OrExpression(std::unique_ptr<Expression> l, std::unique_ptr<Expression> r)
        : left(std::move(l)), right(std::move(r)) {}

    bool interpret(const std::map<std::string, bool>& context) const override {
        return left->interpret(context) || right->interpret(context);
    }
};

// === 非终结符表达式: NOT ===
class NotExpression : public Expression {
    std::unique_ptr<Expression> expr;

public:
    explicit NotExpression(std::unique_ptr<Expression> e) : expr(std::move(e)) {}

    bool interpret(const std::map<std::string, bool>& context) const override {
        return !expr->interpret(context);
    }
};

// === 简单词法分析器 + 语法解析器(支持: true, false, and, or, not, 变量名, 括号) ===
class ExpressionParser {
    std::string input;
    size_t pos = 0;

    // 跳过空白字符
    void skipWhitespace() {
        while (pos < input.size() && std::isspace(input[pos])) {
            ++pos;
        }
    }

    // 获取下一个Token
    std::string nextToken() {
        skipWhitespace();
        if (pos >= input.size()) return "";

        if (std::isalpha(input[pos])) {
            std::string token;
            while (pos < input.size() && std::isalnum(input[pos])) {
                token += input[pos++];
            }
            return token;
        }

        return std::string(1, input[pos++]); // 单字符:  ( ) and or not
    }

    // 递归下降解析器
    std::unique_ptr<Expression> parseExpression() {
        auto expr = parseOr();
        return expr;
    }

    std::unique_ptr<Expression> parseOr() {
        auto left = parseAnd();
        std::string token = nextToken();
        if (token == "or") {
            auto right = parseOr();
            return std::make_unique<OrExpression>(std::move(left), std::move(right));
        }
        pos -= token.size(); // 回退
        return left;
    }

    std::unique_ptr<Expression> parseAnd() {
        auto left = parseNot();
        std::string token = nextToken();
        if (token == "and") {
            auto right = parseAnd();
            return std::make_unique<AndExpression>(std::move(left), std::move(right));
        }
        pos -= token.size();
        return left;
    }

    std::unique_ptr<Expression> parseNot() {
        std::string token = nextToken();
        if (token == "not") {
            auto expr = parsePrimary();
            return std::make_unique<NotExpression>(std::move(expr));
        }
        pos -= token.size();
        return parsePrimary();
    }

    std::unique_ptr<Expression> parsePrimary() {
        std::string token = nextToken();
        if (token == "(") {
            auto expr = parseExpression();
            std::string close = nextToken();
            if (close != ")") {
                throw std::runtime_error("Expected ')'");
            }
            return expr;
        } else if (token == "true") {
            return std::make_unique<BooleanExpression>(true);
        } else if (token == "false") {
            return std::make_unique<BooleanExpression>(false);
        } else if (std::isalpha(token[0])) {
            return std::make_unique<VariableExpression>(token);
        } else {
            throw std::runtime_error("Unexpected token: " + token);
        }
    }

public:
    explicit ExpressionParser(const std::string& str) : input(str) {}

    std::unique_ptr<Expression> parse() {
        pos = 0;
        return parseExpression();
    }
};

// === 客户端使用 ===
int main() {
    // 测试表达式
    std::vector<std::string> testExpressions = {
        "true and false",
        "(true or false) and true",
        "not false",
        "x and y",
        "(x or y) and not z"
    };

    // 上下文变量值
    std::map<std::string, bool> context = {
        {"x", true},
        {"y", false},
        {"z", true}
    };

    for (const auto& exprStr : testExpressions) {
        try {
            ExpressionParser parser(exprStr);
            auto expression = parser.parse();

            bool result = expression->interpret(context);
            std::cout << "✅ 表达式: " << exprStr
                      << " → 结果: " << (result ? "true" : "false") << "\n";

        } catch (const std::exception& e) {
            std::cout << "❌ 解析错误: " << exprStr << " → " << e.what() << "\n";
        }
    }

    return 0;
}
```

输出

```
✅ 表达式: true and false → 结果: false
✅ 表达式: (true or false) and true → 结果: true
✅ 表达式: not false → 结果: true
✅ 表达式: x and y → 结果: false
✅ 表达式: (x or y) and not z → 结果: false
```



## PlantUML

```
@startuml
title Interpreter Pattern

interface Expression {
    +interpret(context: Map<String,Bool>) : bool
}

class BooleanExpression {
    -value: bool
    +interpret(context) : bool
}

class VariableExpression {
    -name: string
    +interpret(context) : bool
}

class AndExpression {
    -left: Expression*
    -right: Expression*
    +interpret(context) : bool
}

class OrExpression {
    -left: Expression*
    -right: Expression*
    +interpret(context) : bool
}

class NotExpression {
    -expr: Expression*
    +interpret(context) : bool
}

class ExpressionParser {
    -input: string
    -pos: size_t
    +parse() : unique_ptr<Expression>
    -parseExpression()
    -parseOr()
    -parseAnd()
    -parseNot()
    -parsePrimary()
    -nextToken() : string
    -skipWhitespace()
}

Expression <|.. BooleanExpression
Expression <|.. VariableExpression
Expression <|.. AndExpression
Expression <|.. OrExpression
Expression <|.. NotExpression

ExpressionParser --> Expression : creates

note right of Expression
  抽象表达式接口
  所有表达式必须实现interpret
end note

note right of BooleanExpression
  终结符表达式: 布尔常量
end note

note right of VariableExpression
  终结符表达式: 变量
end note

note right of AndExpression
  非终结符表达式: AND
end note

note right of ExpressionParser
  简单词法分析器 + 语法解析器
  构建抽象语法树(AST)
end note

@enduml
```

![](./picture/24.InterpreterPattern.png)