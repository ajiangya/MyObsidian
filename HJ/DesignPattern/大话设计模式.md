[TOC]


---

# 1. 23GOFæ€»è§ˆ

| åˆ†ç±»                   | ä½œç”¨                             | æ•°é‡ | è®°å¿†å£è¯€                           |
| ---------------------- | -------------------------------- | ---- | ---------------------------------- |
| **åˆ›å»ºå‹(Creational)** | éšè—å¯¹è±¡åˆ›å»ºç»†èŠ‚, è§£è€¦å®ä¾‹åŒ–è¿‡ç¨‹ | 5    | å·¥ å• å»º æŠ½ åŸ                     |
| **ç»“æ„å‹(Structural)** | ç»„åˆç±»æˆ–å¯¹è±¡, å½¢æˆæ›´å¤§ç»“æ„       | 7    | é€‚ æ¡¥ ç»„ äº« ä»£, è£… å¤– è¡¥ç»“æ„       |
| **è¡Œä¸ºå‹(Behavioral)** | åˆ†é…èŒè´£, ç®¡ç†å¯¹è±¡é—´é€šä¿¡         | 11   | ç­–æ¨¡è§‚å‘½çŠ¶, è´£é“¾å¤‡è®¿ä¸­,è§£è¿­å…¨æ”¶é½ |

> ğŸ¯ **ç»ˆæå£è¯€(æ¨èèƒŒè¯µ): **
> **åˆ›äº” ç»“ä¸ƒ è¡Œåä¸€, SOLIDæ˜¯æ ¹åŸº;
> å·¥ å• å»º æŠ½ åŸ,é€‚ æ¡¥ ç»„ äº« ä»£;
> è£… å¤– è¡¥ç»“æ„,ç­– æ¨¡ è§‚ å‘½ çŠ¶;
> è´£é“¾ å¤‡ è®¿ ä¸­,è§£ è¿­ å…¨æ”¶é½**

---

## ğŸ› ï¸ åˆ›å»ºå‹æ¨¡å¼(5ç§)

| æ¨¡å¼         | ç®€ä»‹                             | ç‰¹ç‚¹                                             | é«˜é¢‘é‡ç‚¹ |
| ------------ | -------------------------------- | ------------------------------------------------ | -------- |
| **å·¥å‚æ–¹æ³•** | å®šä¹‰åˆ›å»ºæ¥å£, å­ç±»å†³å®šå®ä¾‹åŒ–     | **å•ä¸€äº§å“çº¿**; â€œå»¶è¿Ÿåˆ°å­ç±»çš„ newâ€               | âœ…        |
| **æŠ½è±¡å·¥å‚** | åˆ›å»ºç›¸å…³äº§å“æ—, æ— éœ€æŒ‡å®šå…·ä½“ç±»   | **å¤šäº§å“æ—**; â€œå·¥å‚çš„å·¥å‚â€, éš¾æ‰©æ–°äº§å“, æ˜“æ‰©æ–°æ— | âœ…        |
| **å•ä¾‹**     | å…¨å±€å”¯ä¸€å®ä¾‹, æä¾›å…¨å±€è®¿é—®ç‚¹     | **å”¯ä¸€**; æ§åˆ¶èµ„æº(å¦‚é…ç½®ã€è¿æ¥æ± );              | âœ…        |
| **å»ºé€ è€…**   | åˆ†æ­¥æ„é€ å¤æ‚å¯¹è±¡, åˆ†ç¦»æ„é€ ä¸è¡¨ç¤º | **è£…é…çº¿**; å¼ºè°ƒè¿‡ç¨‹(å¦‚SQLæ„é€ å™¨);               | âœ…        |
| **åŸå‹**     | é€šè¿‡å…‹éš†åˆ›å»ºå¯¹è±¡                 | **å¤åˆ¶**; é¿å…æ„é€ å¼€é”€;                          |          |

> ğŸ’¡ **è®°å¿†å£è¯€**:   
> **å·¥å»¶å­ç±»é€ å•å“,
> å•æ§å…¨å±€å”¯ä¸€ä¸ª,
> å»ºåˆ†æ­¥éª¤å¦‚è£…é…,
> æŠ½é€ ä¸€æ—æ‰©æ—æ˜“,
> åŸé å…‹éš†çœå¼€é”€**

---

## ğŸ”Œ ç»“æ„å‹æ¨¡å¼(7ç§)

| æ¨¡å¼       | ç®€ä»‹                                          | ç±»æ¯”è®°å¿†              | é«˜é¢‘é‡ç‚¹ |
| ---------- | --------------------------------------------- | --------------------- | -------- |
| **é€‚é…å™¨** | è½¬æ¢æ¥å£, å…¼å®¹ä¸åŒ¹é…ç±»                        | **è½¬æ¥å¤´/è½¬æ¢æ¥å£**   | âœ…        |
| **æ¡¥æ¥**   | æŠ½è±¡ä¸å®ç°åˆ†ç¦», ç‹¬ç«‹å˜åŒ–                      | **é¥æ§å™¨+ç”µè§†**       |          |
| **ç»„åˆ**   | æ ‘å½¢ç»“æ„ç»Ÿä¸€å¤„ç†éƒ¨åˆ†-æ•´ä½“                     | **æ–‡ä»¶ç³»ç»Ÿ/èœå•æ ‘**   |          |
| **è£…é¥°å™¨** | åŠ¨æ€æ·»åŠ åŠŸèƒ½, æ›¿ä»£ç»§æ‰¿                        | **å±‚å±‚åŒ…è£…,åŠŸèƒ½å¢å¼º** | âœ…        |
| **å¤–è§‚**   | å°è£…å­ç³»ç»Ÿ, æä¾›ç»Ÿä¸€å…¥å£                      | **ä¸€é”®å¼€æœº/å‰å°æ¥å¾…** |          |
| **äº«å…ƒ**   | å…±äº«å¯¹è±¡, èŠ‚çœå†…å­˜;å…³æ³¨å¤ç”¨,åˆ†ç¦»å†…éƒ¨/å¤–éƒ¨çŠ¶æ€ | **å­—ç¬¦æ± /å­å¼¹æ± **;    |          |
| **ä»£ç†**   | æ§åˆ¶å¯¹è±¡è®¿é—®                                  | **ç»çºªäºº/ä»£ç†**       | âœ…        |

| å¯¹æ¯”è®°å¿†   | éƒ½åŒ…è£…å¯¹è±¡, ä½†ç›®çš„ä¸åŒ                | ç±»æ¯”                 |
| ---------- | ------------------------------------- | -------------------- |
| **é€‚é…å™¨** | **è½¬æ¢æ¥å£**(æ—§ç³»ç»Ÿå…¼å®¹)            | â€œç”µæºæ’å¤´è½¬æ¢å™¨â€     |
| **è£…é¥°å™¨** | **å¢å¼ºåŠŸèƒ½**(åŠ¨æ€åŠ æ–™)              | â€œç»™è›‹ç³•åŠ å¥¶æ²¹å’Œæ°´æœâ€ |
| **ä»£ç†**   | **æ§åˆ¶è®¿é—®**(æƒé™ã€å»¶è¿Ÿã€æ—¥å¿—)      | â€œç»çºªäººæ›¿æ˜æ˜Ÿè°ˆåˆåŒâ€ |
| 2          |                                       |                      |
| **è£…é¥°å™¨** | åŒ…è£…å¢å¼º â†’ é€æ˜æ¥å£, å±‚å±‚å åŠ          | è£…é¥°å™¨åƒâ€œç©¿è¡£æœâ€     |
| **ç»„åˆ**   | æ ‘å½¢ç»“æ„ â†’ éƒ¨åˆ†-æ•´ä½“é€’å½’å¤„ç†          | ç»„åˆåƒâ€œç»„ç»‡ç»“æ„å›¾â€   |
| 3          |                                       |                      |
| **å¤–è§‚**   | å°è£…å­ç³»ç»Ÿ â†’ ç®€åŒ–è°ƒç”¨(å®¢æˆ·ç«¯è§†è§’)   | â€œä¸€é”®å¼€æœºæŒ‰é’®â€       |
| **ä¸­ä»‹è€…** | å°è£…å¯¹è±¡äº¤äº’ â†’ é™ä½è€¦åˆ(å¯¹è±¡é—´é€šä¿¡) | â€œæœºåœºå¡”å°åè°ƒé£æœºâ€   |

> ğŸ’¡ **è®°å¿†å£è¯€**: 
> é€‚è½¬æ¥å£ æ—§å…¼å®¹
> æ¡¥åˆ†æŠ½è±¡ ä¸å®ç°
> ç»„æ ‘ç»Ÿä¸€ éƒ¨ä¸æ•´
> äº«æ± å¤ç”¨ çœå†…å­˜
> ä»£æ§è®¿é—® å¦‚ç»çºª
> è£…å åŠŸèƒ½ åŠ¨æ€åŠ 
> å¤–å°å­ç³» ä¸€é”®å¯**

---

## ğŸ”„ è¡Œä¸ºå‹æ¨¡å¼(11ç§)

| æ¨¡å¼         | ç®€ä»‹                       | ç‰¹ç‚¹(å«å¯¹æ¯” & ç±»æ¯”)                        | é«˜é¢‘é‡ç‚¹ |
| ------------ | -------------------------- | ------------------------------------------ | -------- |
| **ç­–ç•¥**     | å°è£…å¯äº’æ¢ç®—æ³•             | â€œå¯¼èˆªè·¯çº¿åˆ‡æ¢â€                             | âœ…        |
| **æ¨¡æ¿æ–¹æ³•** | å®šä¹‰ç®—æ³•éª¨æ¶, å­ç±»å®ç°æ­¥éª¤ | â€œæ³¡èŒ¶æµç¨‹â€;                                | âœ…        |
| **è§‚å¯Ÿè€…**   | ä¸€å¯¹å¤šä¾èµ–, çŠ¶æ€å˜æ›´é€šçŸ¥   | â€œè®¢é˜…å·æ¨é€â€                               | âœ…        |
| **è´£ä»»é“¾**   | è¯·æ±‚æ²¿é“¾ä¼ é€’å¤„ç†           | â€œå®¡æ‰¹æµç¨‹/å¼‚å¸¸å¤„ç†â€                        |          |
| **å‘½ä»¤**     | å°è£…è¯·æ±‚ä¸ºå¯¹è±¡, æ”¯æŒæ’¤é”€   | â€œé¥æ§å™¨æŒ‰é’®â€                               | âœ…        |
| **è§£é‡Šå™¨**   | å®šä¹‰æ–‡æ³•å¹¶è§£é‡Šè¡¨è¾¾å¼       | â€œç®€å•è¯­è¨€è§£æå™¨â€; ä½¿ç”¨è¾ƒå°‘                 |          |
| **è¿­ä»£å™¨**   | éå†èšåˆå¯¹è±¡, éšè—å†…éƒ¨ç»“æ„ | â€œé€šç”¨éå†å™¨â€;                              |          |
| **ä¸­ä»‹è€…**   | é›†ä¸­ç®¡ç†å¯¹è±¡äº¤äº’           | â€œèŠå¤©å®¤æœåŠ¡å™¨â€                             |          |
| **å¤‡å¿˜å½•**   | ä¿å­˜/æ¢å¤å¯¹è±¡çŠ¶æ€          | â€œæ¸¸æˆå­˜æ¡£â€                                 |          |
| **çŠ¶æ€**     | çŠ¶æ€é©±åŠ¨è¡Œä¸ºè‡ªåŠ¨åˆ‡æ¢       | â€œå”®è´§æœºçŠ¶æ€â€                               | âœ…        |
| **è®¿é—®è€…**   | åˆ†ç¦»æ“ä½œä¸å¯¹è±¡ç»“æ„         | â€œæ•°æ®ç»“æ„+å¤šç§æ“ä½œâ€; é€‚åˆç¨³å®šç»“æ„+å¤šå˜æ“ä½œ |          |

| æ¨¡å¼          | è¯´æ˜                                       | ç±»æ¯”                                      |
| ------------- | ------------------------------------------ | ----------------------------------------- |
| **ç­–ç•¥**      | å®¢æˆ·ç«¯ä¸»åŠ¨åˆ‡æ¢ â†’ â€œæˆ‘é€‰å“ªä¸ªç®—æ³•â€            | é€‰æ‹©é©¾é©¶/éª‘è¡Œ/æ­¥è¡Œ                        |
| **çŠ¶æ€**      | å¯¹è±¡è‡ªåŠ¨åˆ‡æ¢ â†’ â€œæˆ‘æ˜¯ä»€ä¹ˆçŠ¶æ€, è¯¥åšä»€ä¹ˆâ€    | æ‰‹æœºå……ç”µä¸­/æ»¡ç”µ/å…³æœºè‡ªåŠ¨è¡Œä¸ºä¸åŒ          |
| 2             |                                            |                                           |
| **å‘½ä»¤**      | å°è£…â€œè¯·æ±‚â€ â†’ æ”¯æŒæ’¤é”€ã€æ’é˜Ÿ(åŠ¨è¯)        | é¥æ§å™¨æŒ‰é’®(å¼€/å…³/éŸ³é‡)                   |
| **ç­–ç•¥**      | å°è£…â€œç®—æ³•â€ â†’ æ”¯æŒæ›¿æ¢(æ–¹æ³•)              | å¯¼èˆªè·¯çº¿A/B/C                             |
| 3             |                                            |                                           |
| **æ¨¡æ¿æ–¹æ³•**  | çˆ¶ç±»å®šæµç¨‹, å­ç±»å¡«æ­¥éª¤ â†’ **ç»§æ‰¿**          | çˆ¶ç±»å®šä¹‰æ³¡èŒ¶æµç¨‹, å­ç±»å®ç°åŠ ç³–æˆ–ä¸åŠ       |
| **ç­–ç•¥**      | æ³¨å…¥ä¸åŒå®ç° â†’ **ç»„åˆ**                    | æ³¨å…¥ SweetTeaStrategy æˆ– PlainTeaStrategy |
| 4             |                                            |                                           |
| **è§‚å¯Ÿè€…**    | ç›®æ ‡ç›´æ¥é€šçŸ¥è§‚å¯Ÿè€… â†’ åŒæ­¥ã€ç´§è€¦åˆ          |                                           |
| **å‘å¸ƒ-è®¢é˜…** | è¿‡æ¶ˆæ¯é˜Ÿåˆ—è§£è€¦ â†’ å¼‚æ­¥ã€æ¾è€¦åˆ(éGoFæ¨¡å¼) | GoFåªæœ‰â€œè§‚å¯Ÿè€…â€, å‘å¸ƒè®¢é˜…æ˜¯å…¶åˆ†å¸ƒå¼æ¼”è¿›   |
| 5             |                                            |                                           |
| **å¤‡å¿˜å½•**    | ä¿å­˜çŠ¶æ€å¿«ç…§ â†’ æ¢å¤(å†…å­˜æ¶ˆè€—å¤§)          | â€œæ¸¸æˆå­˜æ¡£â€                                |
| **å‘½ä»¤**      | è®°å½•æ“ä½œ+åå‘æ“ä½œ â†’ æ’¤é”€(è½»é‡)           | â€œCtrl+Zâ€                                  |
| 6             |                                            |                                           |
| **ä¸­ä»‹è€…**    | æ˜Ÿå‹ç»“æ„, é›†ä¸­è°ƒåº¦ â†’ é™ä½Nå¯¹Nè€¦åˆ          | â€œæœºåœºå¡”å°â€                                |
| **è§‚å¯Ÿè€…**    | å¹¿æ’­é€šçŸ¥ â†’ ç›®æ ‡ä¸è§‚å¯Ÿè€…ç›´æ¥è€¦åˆ            | â€œå¾®ä¿¡ç¾¤@æ‰€æœ‰äººâ€                           |

> ğŸ’¡ **è®°å¿†å£è¯€**:   
> **ç­–æ¢ç®—æ³• å¦‚å¯¼èˆª;âœ…
> æ¨¡å®šéª¨æ¶ å­å¡«æ­¥;âœ…
> è§‚æ¨é€šçŸ¥ è®¢é˜…å·;âœ…
> å‘½å°è¯·æ±‚ å¯æ’¤é”€;âœ…
> çŠ¶é©±è¡Œä¸º å”®è´§æœº;âœ… 
> è´£é“¾å®¡æ‰¹ é€çº§ä¼ ;
> å¤‡å­˜å¿«ç…§ æ¸¸æˆæ¡£;
> è®¿åˆ†æ“ä½œ ç»“æ„ç¨³;
> ä¸­ä»‹è°ƒåº¦ å¡”å°æ§;
> è§£æ–‡æ³• è¯­ä¹‰æ ‘;
> è¿­éå®¹å™¨ è—ç»“æ„.**

> ğŸ”„ **å¯¹æ¯”å¼ºåŒ–å£è¯€(è¾…åŠ©è®°å¿†)**
> **â€œç­–ç•¥æˆ‘é€‰,çŠ¶æ€è‡ªåˆ‡â€** â†’ å®¢æˆ·é€‰ç®—æ³• vs å¯¹è±¡è‡ªåˆ‡æ¢
> **â€œæ¨¡æ¿ç»§æ‰¿,ç­–ç•¥ç»„åˆâ€** â†’ å®ç°æ–¹å¼å¯¹æ¯”
> **â€œå‘½ä»¤è®°æ“ä½œ,å¤‡å¿˜å½•è®°çŠ¶æ€â€** â†’ æ’¤é”€ vs æ¢å¤
> **â€œè§‚å¯Ÿè€…ç›´æ¨,ä¸­ä»‹è€…è°ƒåº¦â€** â†’ å¹¿æ’­ vs ä¸­å¿ƒåŒ–


---

## ğŸ“Š é«˜é¢‘é‡ç‚¹æ¨¡å¼æ¨è

| ç±»å‹   | é‡ç‚¹æ¨¡å¼                           | å…¸å‹åº”ç”¨åœºæ™¯                 |
| ------ | ---------------------------------- | ---------------------------- |
| åˆ›å»ºå‹ | å·¥å‚æ–¹æ³•ã€å•ä¾‹ã€å»ºé€ è€…             | æ¡†æ¶ã€å·¥å…·ç±»ã€å¤æ‚å¯¹è±¡æ„å»º   |
| ç»“æ„å‹ | é€‚é…å™¨ã€è£…é¥°å™¨ã€ä»£ç†               | ç³»ç»Ÿé›†æˆã€åŠŸèƒ½å¢å¼ºã€æƒé™æ§åˆ¶ |
| è¡Œä¸ºå‹ | ç­–ç•¥ã€è§‚å¯Ÿè€…ã€æ¨¡æ¿æ–¹æ³•ã€çŠ¶æ€ã€å‘½ä»¤ | ä¸šåŠ¡é€»è¾‘ã€äº‹ä»¶é©±åŠ¨ã€æµç¨‹æ§åˆ¶ |

---

## ğŸ§  å­¦ä¹ å»ºè®®

1. **æŒ‰ç±»å­¦ä¹ **: åˆ›å»º â†’ ç»“æ„ â†’ è¡Œä¸º, ç†è§£æ¼”è¿›é€»è¾‘ã€‚
2. **å¯¹æ¯”è®°å¿†**: é‡ç‚¹æŒæ¡ç­–ç•¥vsçŠ¶æ€ã€è£…é¥°å™¨vsä»£ç†ã€å‘½ä»¤vså¤‡å¿˜å½•ç­‰ã€‚
3. **åœºæ™¯é©±åŠ¨**: æ€è€ƒâ€œä»€ä¹ˆé—®é¢˜ç”¨ä»€ä¹ˆæ¨¡å¼â€, ç»“åˆSpring/JDK/Qtç­‰æ¡†æ¶ã€‚
4. **ç”»å›¾+å†™ç **: UMLç±»å›¾ + æœ€å°å¯è¿è¡ŒDemo, åŠ æ·±ç†è§£ã€‚
5. **ä»£ç å®è·µ**: ç”¨ C++/Java/Python å®ç°æœ€å°å¯è¿è¡Œç¤ºä¾‹ã€‚
6. **ä¼˜å…ˆæŒæ¡é«˜é¢‘æ¨¡å¼**, é¿å…æ­»è®°ç¡¬èƒŒã€‚

---

ğŸ“Œ **ç»“è¯­: **

> è®¾è®¡æ¨¡å¼ = **è§£å†³ç‰¹å®šé—®é¢˜çš„æ€ç»´æ¨¡æ¿**ã€‚  
> æŒæ¡æ­¤è¡¨ + å£è¯€ + å¯¹æ¯”, 23ç§æ¨¡å¼å°½åœ¨æŒæ¡, ä»£ç è®¾è®¡æ¸¸åˆƒæœ‰ä½™ï¼

---

# 2. ğŸ¯å¸¸ç”¨è®¾è®¡åŸåˆ™

> âœ… **SOLID + LoD = é¢å‘å¯¹è±¡è®¾è®¡é»„é‡‘æ³•åˆ™**
>
> âœ… **æŒæ¡è¿™å…­å¤§åŸåˆ™, ä½ å°±æŒæ¡äº†é¢å‘å¯¹è±¡è®¾è®¡çš„çµé­‚ï¼**
>
> âœ… **è®¾è®¡æ¨¡å¼æ˜¯â€œæœ¯â€, è¿™äº›åŸåˆ™æ˜¯â€œé“â€ã€‚**
>
> ğŸš€ **ç»ˆæå¿ƒæ³•: é«˜å†…èš, ä½è€¦åˆ, å¯æ‰©å±•, æ˜“ç»´æŠ¤ã€‚**
>
> **ğŸ’¡ è®°å¿†å£è¯€: å¼€é‡Œæ¥ä¾è¿ª**

| ä¸­æ–‡å                    | æ ¸å¿ƒæ€æƒ³(ä¸€å¥è¯)                   |
| ------------------------- | ------------------------------------ |
| å•ä¸€èŒè´£åŸåˆ™ (SRP-Single Responsibility Principle) | ä¸€ä¸ªç±»åªåšä¸€ä»¶äº‹;                    |
| å¼€é—­åŸåˆ™ (OCP - Open/Closed Principle) | å¯¹æ‰©å±•å¼€æ”¾, å¯¹ä¿®æ”¹å…³é—­;              |
| é‡Œæ°æ›¿æ¢åŸåˆ™ (LSP - Liskov Substitution Principle) | å­ç±»å¿…é¡»èƒ½æ›¿æ¢çˆ¶ç±»è€Œä¸å½±å“ç¨‹åºæ­£ç¡®æ€§;**å­æ¢çˆ¶, ä¸å‡ºé”™** |
| æ¥å£éš”ç¦»åŸåˆ™ (ISP - Interface Segregation Principle) | å®¢æˆ·ç«¯ä¸åº”ä¾èµ–å®ƒä¸éœ€è¦çš„æ¥å£;**æ¥å£å°, ä¸å¼ºå¡** |
| ä¾èµ–å€’ç½®åŸåˆ™ (DIP - Dependency Inversion Principle) | ä¾èµ–æŠ½è±¡, ä¸ä¾èµ–å…·ä½“; **ä¾èµ–æŠ½è±¡è€Œéå…·ä½“** |
| è¿ªç±³ç‰¹æ³•åˆ™ (æœ€å°‘çŸ¥é“åŸåˆ™)(LoD - Law of Demeter) | åªä¸ç›´æ¥æœ‹å‹é€šä¿¡, é™ä½è€¦åˆ; **åªèŠç†Ÿäºº, ä¸ä¸²é—¨** |

---

## 1ï¸âƒ£ å•ä¸€èŒè´£åŸåˆ™

> **ä¸€ä¸ªç±», åªè´Ÿè´£ä¸€ä»¶äº‹ã€‚**

ğŸ’¡ ç²¾ç‚¼è§£é‡Š: 

- èŒè´£ = å˜åŒ–çš„åŸå› ã€‚
- å¦‚æœä¸€ä¸ªç±»æœ‰å¤šä¸ªèŒè´£, ä¿®æ”¹ä¸€ä¸ªå¯èƒ½å½±å“å¦ä¸€ä¸ª â†’ è„†å¼±ã€éš¾ç»´æŠ¤ã€‚

ğŸ§© C++ ç¤ºä¾‹: 

```cpp
// âŒ è¿åSRP: ä¸€ä¸ªç±»æ—¢ç®¡ç”¨æˆ·æ•°æ®, åˆç®¡ä¿å­˜åˆ°æ•°æ®åº“
class User {
    std::string name;
public:
    void setName(std::string n) { name = n; }
    void saveToDB() { /* è¿æ¥æ•°æ®åº“ã€æ‰§è¡ŒSQL... */ } // èŒè´£2: æŒä¹…åŒ–
};

// âœ… éµå¾ªSRP: æ‹†åˆ†èŒè´£
class User {
    std::string name;
public:
    void setName(std::string n) { name = n; }
    std::string getName() const { return name; }
};

class UserRepository {
public:
    static void save(const User& user) {
        // ä¸“é—¨è´Ÿè´£æŒä¹…åŒ–
    }
};
```

---

## 2ï¸âƒ£ å¼€é—­åŸåˆ™

> **å¯¹æ‰©å±•å¼€æ”¾, å¯¹ä¿®æ”¹å…³é—­ã€‚**

ğŸ’¡ ç²¾ç‚¼è§£é‡Š: 

- æ–°å¢åŠŸèƒ½ â†’ **æ‰©å±•**(åŠ æ–°ç±»/ç­–ç•¥), è€Œé**ä¿®æ”¹**æ—§ä»£ç ã€‚
- é€šå¸¸é€šè¿‡**æŠ½è±¡ + å¤šæ€**å®ç°ã€‚

ğŸ§© C++ ç¤ºä¾‹: 

```cpp
// âŒ è¿åOCP: æ–°å¢æ”¯ä»˜æ–¹å¼éœ€ä¿®æ”¹åŸç±»
class PaymentProcessor {
public:
    void process(std::string type, double amount) {
        if (type == "Alipay") { /* ... */ }
        else if (type == "WeChat") { /* ... */ }
        // else if (type == "Crypto") { ... } // æ¯æ¬¡åŠ æ–°æ”¯ä»˜éƒ½è¦æ”¹è¿™é‡Œï¼
    }
};

// âœ… éµå¾ªOCP: æ‰©å±•æ–°ç±», ä¸æ”¹æ—§ä»£ç 
class IPayment {
public:
    virtual ~IPayment() = default;
    virtual void pay(double amount) = 0;
};

class Alipay : public IPayment {
    void pay(double amount) override { /* ... */ }
};

class WeChatPay : public IPayment {
    void pay(double amount) override { /* ... */ }
};

class PaymentProcessor {
    std::unique_ptr<IPayment> strategy;
public:
    void setPayment(std::unique_ptr<IPayment> p) {
        strategy = std::move(p);
    }
    void process(double amount) {
        if (strategy) strategy->pay(amount);
    }
};
// æ–°å¢ CryptoPayï¼Ÿåªéœ€ç»§æ‰¿ IPayment, æ— éœ€ä¿®æ”¹ PaymentProcessorï¼
```

---

## 3ï¸âƒ£ é‡Œæ°æ›¿æ¢åŸåˆ™

> **å­ç±»å¿…é¡»èƒ½æ›¿æ¢çˆ¶ç±», ä¸”ç¨‹åºè¡Œä¸ºä¸å˜ã€‚**

ğŸ’¡ ç²¾ç‚¼è§£é‡Š: 

- å­ç±»ä¸èƒ½ç ´åçˆ¶ç±»å¥‘çº¦(å‰ç½®/åç½®æ¡ä»¶ã€ä¸å˜é‡)ã€‚
- ä¸è¦ç”¨ç»§æ‰¿å¼ºè¡Œâ€œæ˜¯-aâ€å…³ç³»ã€‚

ğŸ§© C++ ç¤ºä¾‹: 

```cpp
// âŒ è¿åLSP: æ­£æ–¹å½¢ç»§æ‰¿çŸ©å½¢, ä½†è¡Œä¸ºä¸ä¸€è‡´
class Rectangle {
protected:
    int width, height;
public:
    virtual void setWidth(int w) { width = w; }
    virtual void setHeight(int h) { height = h; }
    virtual int getArea() { return width * height; }
};

class Square : public Rectangle {
public:
    void setWidth(int w) override { width = height = w; } // ç ´åçˆ¶ç±»å¥‘çº¦ï¼
    void setHeight(int h) override { width = height = h; }
};

// ä½¿ç”¨æ—¶å‡ºé”™: 
void resize(Rectangle& r) {
    r.setWidth(5);
    r.setHeight(4);
    assert(r.getArea() == 20); // å¯¹Squareä¼šå¤±è´¥ï¼é¢ç§¯=16 â‰  20
}

// âœ… éµå¾ªLSP: æ­£æ–¹å½¢ä¸åº”ç»§æ‰¿çŸ©å½¢, æˆ–é‡æ–°è®¾è®¡æ¥å£
// â†’ ç”¨ç»„åˆ or ç‹¬ç«‹ç±» or æ¥å£éš”ç¦»
```

---

## 4ï¸âƒ£ æ¥å£éš”ç¦»åŸåˆ™

> **å®¢æˆ·ç«¯ä¸åº”è¢«è¿«ä¾èµ–å®ƒä¸éœ€è¦çš„æ¥å£ã€‚**

ğŸ’¡ ç²¾ç‚¼è§£é‡Š: 

- æ¥å£è¦â€œå°è€Œä¸“â€, ä¸è¦â€œå¤§è€Œå…¨â€ã€‚
- é¿å…â€œèƒ–æ¥å£â€, æŒ‰è§’è‰²æ‹†åˆ†ã€‚

ğŸ§© C++ ç¤ºä¾‹: 

```cpp
// âŒ è¿åISP: ä¸€ä¸ªæ¥å£åŒ…å«æ‰€æœ‰æ–¹æ³•, æœ‰äº›ç±»ç”¨ä¸åˆ°
class IBird {
public:
    virtual void fly() = 0;
    virtual void eat() = 0;
    virtual void swim() = 0; // ä¼é¹…ä¸éœ€è¦ï¼
};

class Penguin : public IBird {
    void fly() override { /* ä¸èƒ½é£, æŠ›å¼‚å¸¸ï¼Ÿç©ºå®ç°ï¼Ÿéƒ½ä¸å¯¹ï¼ */ }
    void eat() override { /* ... */ }
    void swim() override { /* ... */ }
};

// âœ… éµå¾ªISP: æŒ‰èƒ½åŠ›æ‹†åˆ†æ¥å£
class IFlyable { virtual void fly() = 0; };
class ISwimmable { virtual void swim() = 0; };
class IEatable { virtual void eat() = 0; };

class Sparrow : public IFlyable, public IEatable { /* ... */ };
class Penguin : public ISwimmable, public IEatable { /* ... */ };
```

---

## 5ï¸âƒ£ ä¾èµ–å€’ç½®åŸåˆ™

> **é«˜å±‚æ¨¡å—ä¸åº”ä¾èµ–ä½å±‚æ¨¡å—, äºŒè€…éƒ½åº”ä¾èµ–æŠ½è±¡ã€‚**

ğŸ’¡ ç²¾ç‚¼è§£é‡Š: 

- ä¾èµ–æŠ½è±¡(æ¥å£/åŸºç±»), ä¸ä¾èµ–å…·ä½“å®ç°ã€‚
- æ§åˆ¶åè½¬(IoC)çš„åŸºç¡€ã€‚

ğŸ§© C++ ç¤ºä¾‹: 

```cpp
// âŒ è¿åDIP: é«˜å±‚ç›´æ¥ä¾èµ–ä½å±‚å…·ä½“ç±»
class MySQLDatabase {
public:
    void connect() { /* ... */ }
    void query(std::string sql) { /* ... */ }
};

class UserService {
    MySQLDatabase db; // ç´§è€¦åˆï¼æ¢æ•°æ®åº“ï¼Ÿæ”¹ä»£ç ï¼
public:
    void getUser(int id) {
        db.query("SELECT * FROM users WHERE id=" + std::to_string(id));
    }
};

// âœ… éµå¾ªDIP: ä¾èµ–æŠ½è±¡
class IDatabase {
public:
    virtual ~IDatabase() = default;
    virtual void connect() = 0;
    virtual void query(std::string sql) = 0;
};

class MySQLDatabase : public IDatabase { /* ... */ };
class PostgreSQLDatabase : public IDatabase { /* ... */ };

class UserService {
    std::unique_ptr<IDatabase> db; // ä¾èµ–æŠ½è±¡
public:
    UserService(std::unique_ptr<IDatabase> d) : db(std::move(d)) {}
    void getUser(int id) {
        db->query("SELECT * FROM users WHERE id=" + std::to_string(id));
    }
};
// æ¢æ•°æ®åº“ï¼Ÿæ³¨å…¥ä¸åŒå®ç°å³å¯, UserService ä¸€è¡Œä¸æ”¹ï¼
```

---

## 6ï¸âƒ£ è¿ªç±³ç‰¹æ³•åˆ™

> **åªä¸ç›´æ¥æœ‹å‹é€šä¿¡, ä¸å’Œâ€œé™Œç”Ÿäººâ€è¯´è¯ã€‚**

ğŸ’¡ ç²¾ç‚¼è§£é‡Š: 

- â€œæœ‹å‹â€ = å‚æ•°ã€æˆå‘˜ã€å±€éƒ¨å˜é‡ã€thisã€‚
- ä¸è¦ `a.getB().getC().doSomething()` é“¾å¼è°ƒç”¨ â†’ è€¦åˆæ·±, æ˜“å´©ã€‚

ğŸ§© C++ ç¤ºä¾‹: 

```cpp
// âŒ è¿åLoD: é“¾å¼è°ƒç”¨, è€¦åˆè¿‡æ·±
class Engine {
public:
    void start() { /* ... */ }
};

class Car {
    Engine engine;
public:
    Engine& getEngine() { return engine; } // æš´éœ²å†…éƒ¨å¯¹è±¡ï¼
};

class Driver {
public:
    void drive(Car& car) {
        car.getEngine().start(); // ä¾èµ–äº†Engineï¼ä¸è¯¥çŸ¥é“Carå†…éƒ¨ç»“æ„
    }
};

// âœ… éµå¾ªLoD: å°è£…å†…éƒ¨, åªè°ƒç”¨ç›´æ¥æ¥å£
class Car {
    Engine engine;
public:
    void start() { engine.start(); } // å°è£…ï¼Driver åªéœ€çŸ¥é“ Car.start()
};

class Driver {
public:
    void drive(Car& car) {
        car.start(); // åªä¸Caré€šä¿¡, ä¸ç¢°Engine
    }
};
```

---

# ğŸ› ï¸åˆ›å»ºå‹æ¨¡å¼

# 3.ç®€å•å·¥å‚æ¨¡å¼

## ç®€ä»‹

**ç®€å•å·¥å‚æ¨¡å¼(Simple Factory Pattern)** å¹¶ä¸æ˜¯ GoF 23 ç§è®¾è®¡æ¨¡å¼ä¹‹ä¸€,è€Œæ˜¯ä¸€ç§â€œç¼–ç¨‹ä¹ æƒ¯â€æˆ–â€œæƒ¯ç”¨æ³•â€,å¸¸è¢«ç”¨ä½œå·¥å‚æ–¹æ³•æ¨¡å¼çš„ç®€åŒ–ç‰ˆã€‚

**é€‚ç”¨åœºæ™¯**

1. **å¯¹è±¡åˆ›å»ºé€»è¾‘ç®€å•,ä½†éœ€è¦é›†ä¸­ç®¡ç†** - å¦‚æ ¹æ®é…ç½®ã€ç”¨æˆ·è¾“å…¥ã€ç±»å‹å­—ç¬¦ä¸²ç­‰åˆ›å»ºä¸åŒå¯¹è±¡ã€‚
2. **å®¢æˆ·ç«¯ä¸å…³å¿ƒå…·ä½“ç±»,åªå…³å¿ƒæ¥å£** - è§£è€¦å®¢æˆ·ç«¯ä¸å…·ä½“å®ç°ã€‚
3. **äº§å“ç±»è¾ƒå°‘,ä¸”ä¸å¤ªä¼šé¢‘ç¹æ‰©å±•** - é¿å…å·¥å‚ç±»è†¨èƒ€ã€‚
4. **å¿«é€ŸåŸå‹æˆ–æ•™å­¦ç¤ºä¾‹** - ç®€å•ç›´è§‚,æ˜“äºç†è§£ã€‚

**ä¼˜ç¼ºç‚¹**

âœ… ä¼˜ç‚¹

- **å°è£…åˆ›å»ºé€»è¾‘**: å®¢æˆ·ç«¯æ— éœ€çŸ¥é“å…·ä½“ç±»å,é™ä½è€¦åˆã€‚
- **é›†ä¸­ç®¡ç†å¯¹è±¡åˆ›å»º**: ä¾¿äºç»´æŠ¤å’Œä¿®æ”¹åˆ›å»ºé€»è¾‘ã€‚
- **ä»£ç ç®€æ´**: ç›¸æ¯”å·¥å‚æ–¹æ³•/æŠ½è±¡å·¥å‚æ›´è½»é‡ã€‚

âŒ ç¼ºç‚¹

- **è¿åå¼€é—­åŸåˆ™(OCP)**: æ–°å¢äº§å“æ—¶å¿…é¡»ä¿®æ”¹å·¥å‚ç±»(éœ€åŠ  `if-else` æˆ– `switch`)ã€‚
- **å·¥å‚ç±»èŒè´£è¿‡é‡**: æ‰€æœ‰äº§å“çš„åˆ›å»ºé€»è¾‘é›†ä¸­åœ¨ä¸€ä¸ªç±»ä¸­,ä¸æ˜“æ‰©å±•å’Œç»´æŠ¤ã€‚
- **ä¸æ˜¯çœŸæ­£çš„â€œè®¾è®¡æ¨¡å¼â€**: ç¼ºä¹æ‰©å±•æ€§å’Œå¤šæ€æ€§æ”¯æŒ(å¯¹æ¯”å·¥å‚æ–¹æ³•æ¨¡å¼)ã€‚

**âš ï¸ æ³¨æ„äº‹é¡¹**

1. **é¿å…å·¥å‚ç±»è¿‡äºåºå¤§** - å¦‚æœäº§å“ç§ç±»å¾ˆå¤š,è€ƒè™‘ä½¿ç”¨**å·¥å‚æ–¹æ³•æ¨¡å¼**æˆ–**æ³¨å†Œè¡¨æ¨¡å¼(åå°„/é…ç½®é©±åŠ¨)**ã€‚
2. **å¼‚å¸¸å¤„ç†è¦å®Œå–„** - å¯¹éæ³•è¾“å…¥å‚æ•°æŠ›å‡ºå¼‚å¸¸æˆ–è¿”å›ç©ºæŒ‡é’ˆ,å¹¶åšå¥½å®¢æˆ·ç«¯å¤„ç†ã€‚
3. **çº¿ç¨‹å®‰å…¨é—®é¢˜** - å¦‚æœå·¥å‚ç±»æœ‰çŠ¶æ€æˆ–ä½¿ç”¨å•ä¾‹,éœ€è€ƒè™‘å¤šçº¿ç¨‹ç¯å¢ƒä¸‹çš„åŒæ­¥ã€‚
4. **å†…å­˜ç®¡ç†** - ç¤ºä¾‹ä¸­ä½¿ç”¨ `std::unique_ptr` è‡ªåŠ¨ç®¡ç†èµ„æº,é¿å…å†…å­˜æ³„æ¼ã€‚
5. **å¯è€ƒè™‘ä½¿ç”¨æšä¸¾æ›¿ä»£å­—ç¬¦ä¸²** - æé«˜ç±»å‹å®‰å…¨æ€§,é¿å…æ‹¼å†™é”™è¯¯: 

**ğŸ“Œæ€»ç»“**

> **ç®€å•å·¥å‚æ¨¡å¼æ˜¯â€œå·¥å‚æ¨¡å¼å®¶æ—â€çš„å…¥é—¨æ¬¾,é€‚åˆäº§å“ç§ç±»å°‘ã€å˜åŒ–ä¸é¢‘ç¹çš„åœºæ™¯ã€‚**
>  å®ƒè®©ä»£ç æ›´æ•´æ´ã€è€¦åˆæ›´ä½,ä½†ä¸å…·å¤‡è‰¯å¥½çš„æ‰©å±•æ€§ã€‚åœ¨éœ€è¦çµæ´»æ‰©å±•æ—¶,åº”å‡çº§ä¸º**å·¥å‚æ–¹æ³•æ¨¡å¼**æˆ–**æŠ½è±¡å·¥å‚æ¨¡å¼**ã€‚

## ä»£ç 

```
#include <iostream>
#include <memory>
#include <string>

// æŠ½è±¡äº§å“ç±»
class Product {
public:
    virtual ~Product() = default;
    virtual void operation() = 0;
};

// å…·ä½“äº§å“ A
class ConcreteProductA : public Product {
public:
    void operation() override {
        std::cout << "ConcreteProductA::operation() called.\n";
    }
};

// å…·ä½“äº§å“ B
class ConcreteProductB : public Product {
public:
    void operation() override {
        std::cout << "ConcreteProductB::operation() called.\n";
    }
};

// ç®€å•å·¥å‚ç±»
class SimpleFactory {
public:
    static std::unique_ptr<Product> createProduct(const std::string& type) {
        if (type == "A") {
            return std::make_unique<ConcreteProductA>();
        } else if (type == "B") {
            return std::make_unique<ConcreteProductB>();
        } else {
            throw std::invalid_argument("Unknown product type: " + type);
        }
    }
};

// å®¢æˆ·ç«¯ä»£ç 
int main() {
    try {
        auto productA = SimpleFactory::createProduct("A");
        productA->operation();

        auto productB = SimpleFactory::createProduct("B");
        productB->operation();

        // auto productC = SimpleFactory::createProduct("C"); // æŠ›å‡ºå¼‚å¸¸
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }

    return 0;
}
```

## PlantUML

```
@startuml
' ç®€å•å·¥å‚æ¨¡å¼ç±»å›¾

interface Product {
    +operation()
}

class ConcreteProductA {
    +operation()
}

class ConcreteProductB {
    +operation()
}

class SimpleFactory {
    +createProduct(type: string): Product
}

class Client

Client --> SimpleFactory : ä½¿ç”¨
SimpleFactory --> Product : åˆ›å»º
Product <|-- ConcreteProductA
Product <|-- ConcreteProductB

note right of SimpleFactory
  æ ¹æ®ä¼ å…¥å‚æ•°å†³å®š
  åˆ›å»ºå“ªä¸ªå…·ä½“äº§å“
end note

@enduml
```

![](./picture/1.SimpleFactoryPattern.png)



# 4. å·¥å‚æ–¹æ³•æ¨¡å¼

## ç®€ä»‹

**å·¥å‚æ–¹æ³•æ¨¡å¼(Factory Method Pattern)** æ˜¯ GoF 23 ç§ç»å…¸è®¾è®¡æ¨¡å¼ä¹‹ä¸€, å±äº **åˆ›å»ºå‹æ¨¡å¼**ã€‚

> å®ƒå®šä¹‰ä¸€ä¸ªç”¨äºåˆ›å»ºå¯¹è±¡çš„**æ¥å£(å·¥å‚æ–¹æ³•)**, ä½†è®©**å­ç±»å†³å®šå®ä¾‹åŒ–å“ªä¸€ä¸ªç±»**ã€‚å·¥å‚æ–¹æ³•ä½¿ä¸€ä¸ªç±»çš„å®ä¾‹åŒ–å»¶è¿Ÿåˆ°å…¶å­ç±»ã€‚

ğŸ“Œ æ ¸å¿ƒæ€æƒ³: **â€œæˆ‘ä¸ç›´æ¥åˆ›å»ºäº§å“, æˆ‘æä¾›ä¸€ä¸ªåˆ›å»ºæ–¹æ³•, è®©å­ç±»å»å®ç°å…·ä½“åˆ›å»ºé€»è¾‘ã€‚â€**

> ğŸ’¡ ç±»æ¯”: æ¡†æ¶è¯´â€œä½ å¿…é¡»æä¾›ä¸€ä¸ªé€ æŒ‰é’®çš„æ–¹æ³•â€, å…·ä½“æ˜¯é€  Windows æŒ‰é’®è¿˜æ˜¯ Mac æŒ‰é’®, ç”±å­ç±»å†³å®šã€‚

ä¸â€œç®€å•å·¥å‚â€ä¸åŒ, å·¥å‚æ–¹æ³•æ¨¡å¼é€šè¿‡**ç»§æ‰¿ + å¤šæ€**å®ç°æ‰©å±•, ç¬¦åˆ**å¼€é—­åŸåˆ™**ã€‚

**é€‚ç”¨åœºæ™¯**

1. **ä¸ç¡®å®šå¯¹è±¡åˆ›å»ºç»†èŠ‚, å¸Œæœ›å­ç±»å†³å®š** â€”â€” å¦‚æ¡†æ¶æä¾›æ¥å£, ç”¨æˆ·å®ç°å…·ä½“äº§å“ã€‚
2. **éœ€è¦å°†äº§å“åˆ›å»ºä¸ä½¿ç”¨è§£è€¦** â€”â€” å®¢æˆ·ç«¯åªä¾èµ–æŠ½è±¡äº§å“å’Œåˆ›å»ºè€…ã€‚
3. **å¸Œæœ›æ”¯æŒæ‰©å±•æ–°äº§å“, è€Œä¸ä¿®æ”¹ç°æœ‰ä»£ç ** â€”â€” ç¬¦åˆå¼€é—­åŸåˆ™ã€‚
4. **å¹¶è¡Œäº§å“æ—ç»“æ„** â€”â€” å¦‚ä¸åŒå¹³å°ã€ä¸åŒæ•°æ®åº“ã€ä¸åŒæ–‡ä»¶æ ¼å¼çš„åˆ›å»ºã€‚

ğŸ“Œ å¸¸è§åº”ç”¨: 

- è·¨å¹³å° UI æ§ä»¶(Qtã€MFC ç­‰æ¡†æ¶)
- æ•°æ®åº“è¿æ¥å·¥å‚(MySQLFactoryã€PostgreSQLFactory)
- æ¸¸æˆå…³å¡ç”Ÿæˆå™¨(EasyLevelFactoryã€HardLevelFactory)
- æ—¥å¿—è®°å½•å™¨(FileLoggerFactoryã€DBLoggerFactory)
- æ’ä»¶ç³»ç»Ÿ(æ¯ä¸ªæ’ä»¶æä¾›è‡ªå·±çš„å·¥å‚)

**ä¼˜ç¼ºç‚¹**

**âœ… ä¼˜ç‚¹**

- **ç¬¦åˆå¼€é—­åŸåˆ™** â€”â€” æ–°å¢äº§å“åªéœ€æ–°å¢å…·ä½“å·¥å‚å’Œäº§å“ç±», æ— éœ€ä¿®æ”¹ç°æœ‰ä»£ç ã€‚
- **ç¬¦åˆå•ä¸€èŒè´£åŸåˆ™** â€”â€” åˆ›å»ºé€»è¾‘å°è£…åœ¨å·¥å‚å­ç±»ä¸­ã€‚
- **å®¢æˆ·ç«¯ä¸å…·ä½“äº§å“è§£è€¦** â€”â€” åªä¾èµ–æŠ½è±¡æ¥å£ã€‚
- **æ”¯æŒå¹¶è¡Œäº§å“æ—ç»“æ„** â€”â€” æ˜“äºç»„ç»‡ç›¸å…³äº§å“ã€‚
- **ä¾¿äºå•å…ƒæµ‹è¯•** â€”â€” å¯è½»æ¾ Mock å·¥å‚æ–¹æ³•ã€‚

**âŒ ç¼ºç‚¹**

- **ç±»æ•°é‡å¢åŠ ** â€”â€” æ¯ä¸ªäº§å“å¯¹åº”ä¸€ä¸ªå·¥å‚å­ç±»(æœ‰æ—¶æ˜¾å¾—â€œç±»çˆ†ç‚¸â€)ã€‚
- **ç»“æ„ç•¥å¤æ‚** â€”â€” ç›¸æ¯”â€œç®€å•å·¥å‚â€, å¤šäº†ä¸€å±‚ç»§æ‰¿ç»“æ„ã€‚
- **å®¢æˆ·ç«¯éœ€çŸ¥é“å…·ä½“å·¥å‚ç±»** â€”â€” ä»éœ€ `new WindowsDialog()`, å¯é€šè¿‡â€œæŠ½è±¡å·¥å‚â€æˆ–é…ç½®è¿›ä¸€æ­¥è§£è€¦ã€‚

**âš ï¸ æ³¨æ„äº‹é¡¹**

1. **å·¥å‚æ–¹æ³•é€šå¸¸ä¸ºè™šå‡½æ•°** â€”â€” C++ ä¸­ç”¨ `virtual` æ ‡è®°, å…è®¸å­ç±»é‡å†™ã€‚
2. **è¿”å›æ™ºèƒ½æŒ‡é’ˆç®¡ç†èµ„æº** â€”â€” ç¤ºä¾‹ä¸­ä½¿ç”¨ `std::unique_ptr` é¿å…å†…å­˜æ³„æ¼ã€‚
3. **å¯ç»“åˆæ¨¡æ¿ç®€åŒ–(æ¨¡æ¿å·¥å‚æ–¹æ³•)** â€”â€” è‹¥äº§å“æ„é€ ç®€å•, å¯ç”¨ CRTP: 

ğŸ“Œ **ä¸€å¥è¯æ€»ç»“: **

> **å·¥å‚æ–¹æ³• = â€œæˆ‘å®šä¹‰åˆ›å»ºæ¥å£, ä½ (å­ç±»)å†³å®šåˆ›å»ºè°â€, å®ç°çµæ´»æ‰©å±•, æ‹¥æŠ±å˜åŒ–ã€‚**

## ä»£ç 

```
// Shape.h
#include <iostream>
#include <memory>

// æŠ½è±¡äº§å“
class Shape {
public:
    virtual ~Shape() = default;
    virtual void draw() = 0;
};

// å…·ä½“äº§å“: åœ†å½¢
class Circle : public Shape {
public:
    void draw() override {
        std::cout << "Drawing a Circle" << std::endl;
    }
};

// å…·ä½“äº§å“: çŸ©å½¢
class Rectangle : public Shape {
public:
    void draw() override {
        std::cout << "Drawing a Rectangle" << std::endl;
    }
};

// æŠ½è±¡å·¥å‚
class ShapeFactory {
public:
    virtual ~ShapeFactory() = default;
    virtual std::unique_ptr<Shape> createShape() = 0; // å·¥å‚æ–¹æ³•
};

// å…·ä½“å·¥å‚: åœ†å½¢å·¥å‚
class CircleFactory : public ShapeFactory {
public:
    std::unique_ptr<Shape> createShape() override {
        return std::make_unique<Circle>();
    }
};

// å…·ä½“å·¥å‚: çŸ©å½¢å·¥å‚
class RectangleFactory : public ShapeFactory {
public:
    std::unique_ptr<Shape> createShape() override {
        return std::make_unique<Rectangle>();
    }
};

// å®¢æˆ·ç«¯ä»£ç 
void clientCode(std::unique_ptr<ShapeFactory> factory) {
    auto shape = factory->createShape();
    shape->draw();
}

// main.cpp
#include "Shape.h"

int main() {
    std::cout << "Client: Testing with CircleFactory:\n";
    clientCode(std::make_unique<CircleFactory>());

    std::cout << "\nClient: Testing with RectangleFactory:\n";
    clientCode(std::make_unique<RectangleFactory>());

    return 0;
}
```

## PlantUML

```
@startuml
' æŠ½è±¡äº§å“
abstract class Shape {
    +draw() : void
}

' å…·ä½“äº§å“
class Circle {
    +draw() : void
}

class Rectangle {
    +draw() : void
}

' æŠ½è±¡å·¥å‚
abstract class ShapeFactory {
    +createShape() : std::unique_ptr<Shape>
}

' å…·ä½“å·¥å‚
class CircleFactory {
    +createShape() : std::unique_ptr<Shape>
}

class RectangleFactory {
    +createShape() : std::unique_ptr<Shape>
}

' å…³ç³»
Shape <|-- Circle
Shape <|-- Rectangle

ShapeFactory <|-- CircleFactory
ShapeFactory <|-- RectangleFactory

CircleFactory ..> Circle : creates
RectangleFactory ..> Rectangle : creates

note right of ShapeFactory
    Factory Method
    declares interface
end note

note right of CircleFactory
    overrides to
    create Circle
end note

@enduml
```

![](./picture/2.FactoryMethodPattern.png)



# 5. æŠ½è±¡å·¥å‚æ¨¡å¼

## ç®€ä»‹

**æŠ½è±¡å·¥å‚æ¨¡å¼(Abstract Factory Pattern)** æ˜¯ GoF 23 ç§ç»å…¸è®¾è®¡æ¨¡å¼ä¹‹ä¸€, å±äº **åˆ›å»ºå‹æ¨¡å¼**ã€‚

> å®ƒæä¾›ä¸€ä¸ª**åˆ›å»ºä¸€ç³»åˆ—ç›¸å…³æˆ–ç›¸äº’ä¾èµ–å¯¹è±¡çš„æ¥å£**, è€Œæ— éœ€æŒ‡å®šå®ƒä»¬å…·ä½“çš„ç±»ã€‚

ğŸ“Œ æ ¸å¿ƒæ€æƒ³: **â€œä¸æ˜¯é€ ä¸€ä¸ªäº§å“, è€Œæ˜¯é€ ä¸€æ•´å¥—é£æ ¼ä¸€è‡´çš„äº§å“æ—ã€‚â€**

> ğŸ’¡ ç±»æ¯”: ä¹°å®¶å…· â€”â€” ä½ é€‰â€œåŒ—æ¬§é£æ ¼â€, å·¥å‚å°±ç»™ä½ é€ åŒ—æ¬§çš„æ²™å‘+æ¤…å­+æ¡Œå­; é€‰â€œå·¥ä¸šé£â€, å°±å…¨æ¢æˆå·¥ä¸šé£ã€‚ä½ ä¸ç”¨ä¸€ä¸ªä¸ªæŒ‡å®š, å·¥å‚æ‰“åŒ…ç»™ä½ ã€‚

æŠ½è±¡å·¥å‚æ˜¯ **å·¥å‚æ–¹æ³•æ¨¡å¼çš„æ‰©å±•** â€”â€” å·¥å‚æ–¹æ³•é’ˆå¯¹â€œå•ä¸€äº§å“â€, æŠ½è±¡å·¥å‚é’ˆå¯¹â€œäº§å“æ—â€ã€‚

**é€‚ç”¨åœºæ™¯**

1. **ç³»ç»Ÿéœ€è¦ç‹¬ç«‹äºäº§å“çš„åˆ›å»ºã€ç»„åˆå’Œè¡¨ç¤ºæ—¶ã€‚**
2. **ç³»ç»Ÿéœ€è¦ç”±å¤šä¸ªäº§å“ç³»åˆ—ä¸­çš„ä¸€ä¸ªæ¥é…ç½®æ—¶ã€‚**
3. **å¼ºè°ƒä¸€ç³»åˆ—ç›¸å…³äº§å“å¯¹è±¡çš„è®¾è®¡ä»¥ä¾¿è¿›è¡Œè”åˆä½¿ç”¨ã€‚**
4. **æä¾›ä¸€ä¸ªäº§å“ç±»åº“, è€Œåªæƒ³æ˜¾ç¤ºå®ƒä»¬çš„æ¥å£, è€Œä¸æ˜¯å®ç°æ—¶ã€‚**

ğŸ“Œ **å…¸å‹åº”ç”¨åœºæ™¯: **

- GUI è·¨å¹³å°ç»„ä»¶åº“(Windows vs Mac vs Linux é£æ ¼æ§ä»¶)
- æ¸¸æˆä¸­ä¸åŒä¸»é¢˜çš„è£…å¤‡å¥—è£…(æˆ˜å£«å¥—è£…ã€æ³•å¸ˆå¥—è£…)
- æ•°æ®åº“è®¿é—®å±‚(MySQLFactoryã€PostgreSQLFactory åˆ›å»º Connectionã€Commandã€DataReader)

**âœ… ä¸‰ã€ä¼˜ç¼ºç‚¹**

**âœ… ä¼˜ç‚¹: **

1. **åˆ†ç¦»å…·ä½“ç±»çš„ç”Ÿæˆ, å®¢æˆ·ç«¯ä¸ä¾èµ–å…·ä½“ç±»ã€‚**
2. **æ˜“äºäº¤æ¢äº§å“ç³»åˆ—** â€”â€” åªéœ€æ›´æ¢ ConcreteFactoryã€‚
3. **æœ‰åˆ©äºäº§å“ä¸€è‡´æ€§** â€”â€” ç¡®ä¿åˆ›å»ºçš„å¯¹è±¡æ˜¯é…å¥—çš„ã€å…¼å®¹çš„ã€‚
4. **ç¬¦åˆå¼€é—­åŸåˆ™(å¯¹æ‰©å±•å¼€æ”¾)** â€”â€” å¢åŠ æ–°äº§å“æ—æ—¶åªéœ€æ–°å¢å·¥å‚å’Œäº§å“ç±»ã€‚

**âŒ ç¼ºç‚¹: **

1. **éš¾ä»¥æ”¯æŒæ–°ç§ç±»çš„äº§å“** â€”â€” å¦‚æœè¦æ–°å¢ä¸€ç±»äº§å“(å¦‚æ–°å¢ TextBox), éœ€è¦ä¿®æ”¹æ‰€æœ‰å·¥å‚æ¥å£åŠå…¶å®ç°ã€‚
2. **ç±»æ•°é‡çˆ†ç‚¸** â€”â€” æ¯ä¸ªäº§å“æ— Ã— æ¯ä¸ªäº§å“ç±»å‹ = å¤§é‡ç±»ã€‚
3. **ç»“æ„å¤æ‚, å°é¡¹ç›®ä¸æ¨èã€‚**

> ğŸ’¡ æŠ½è±¡å·¥å‚é€‚åˆâ€œäº§å“æ—ç¨³å®šã€äº§å“ç±»å‹å°‘ã€æ—å¤šâ€çš„åœºæ™¯ã€‚

**âœ… æ³¨æ„äº‹é¡¹**

1. **æŠ½è±¡å·¥å‚æ¥å£åº”ç¨³å®š, é¿å…é¢‘ç¹å¢åˆ äº§å“ç±»å‹ã€‚**
2. **C++ ä¸­æ¨èè¿”å›æ™ºèƒ½æŒ‡é’ˆ(`std::unique_ptr`)ç®¡ç†èµ„æºã€‚**
3. **å·¥å‚é€šå¸¸ä¸æŒæœ‰çŠ¶æ€, å¯è®¾è®¡ä¸ºå•ä¾‹æˆ–é™æ€å·¥å‚ã€‚**
4. **é¿å…åœ¨å·¥å‚ä¸­åšå¤æ‚åˆå§‹åŒ–é€»è¾‘, ä¿æŒèŒè´£å•ä¸€ã€‚**
5. **å¦‚æœäº§å“ç±»å‹å¯èƒ½æ‰©å±•, å¯è€ƒè™‘ç»“åˆâ€œåå°„â€æˆ–â€œæ³¨å†Œæœºåˆ¶â€åŠ¨æ€æ”¯æŒã€‚**

ğŸ“Œ **ä¸€å¥è¯æ€»ç»“: **

> **æŠ½è±¡å·¥å‚ = â€œæˆ‘ç»™ä½ ä¸€å¥—é…å¥—äº§å“, ä½ æ— éœ€å…³å¿ƒå®ƒä»¬ä»å“ªæ¥, åªéœ€ç”¨å°±å¯¹äº†â€ã€‚**

## ä»£ç 

```
// GUIFactory.h
#include <iostream>
#include <memory>
#include <string>

// æŠ½è±¡äº§å“: æŒ‰é’®
class Button {
public:
    virtual ~Button() = default;
    virtual void paint() = 0;
};

// æŠ½è±¡äº§å“: å¤é€‰æ¡†
class Checkbox {
public:
    virtual ~Checkbox() = default;
    virtual void paint() = 0;
};

// æŠ½è±¡å·¥å‚
class GUIFactory {
public:
    virtual ~GUIFactory() = default;
    virtual std::unique_ptr<Button> createButton() = 0;
    virtual std::unique_ptr<Checkbox> createCheckbox() = 0;
};

// ==================== Windows å¹³å°äº§å“ ====================

class WinButton : public Button {
public:
    void paint() override {
        std::cout << "Render a button in Windows style." << std::endl;
    }
};

class WinCheckbox : public Checkbox {
public:
    void paint() override {
        std::cout << "Render a checkbox in Windows style." << std::endl;
    }
};

class WinFactory : public GUIFactory {
public:
    std::unique_ptr<Button> createButton() override {
        return std::make_unique<WinButton>();
    }

    std::unique_ptr<Checkbox> createCheckbox() override {
        return std::make_unique<WinCheckbox>();
    }
};

// ==================== Mac å¹³å°äº§å“ ====================

class MacButton : public Button {
public:
    void paint() override {
        std::cout << "Render a button in Mac style." << std::endl;
    }
};

class MacCheckbox : public Checkbox {
public:
    void paint() override {
        std::cout << "Render a checkbox in Mac style." << std::endl;
    }
};

class MacFactory : public GUIFactory {
public:
    std::unique_ptr<Button> createButton() override {
        return std::make_unique<MacButton>();
    }

    std::unique_ptr<Checkbox> createCheckbox() override {
        return std::make_unique<MacCheckbox>();
    }
};

// ==================== å®¢æˆ·ç«¯ä»£ç  ====================

void clientCode(std::unique_ptr<GUIFactory> factory) {
    auto button = factory->createButton();
    auto checkbox = factory->createCheckbox();

    button->paint();
    checkbox->paint();
}

// main.cpp
#include "GUIFactory.h"

int main() {
    std::cout << "Client: Testing client code with Windows factory:\n";
    clientCode(std::make_unique<WinFactory>());

    std::cout << "\nClient: Testing client code with Mac factory:\n";
    clientCode(std::make_unique<MacFactory>());

    return 0;
}
```

## PlantUML

```
@startuml

' ================= æŠ½è±¡å±‚ =================
abstract class GUIFactory {
    +createButton() : std::unique_ptr<Button>
    +createCheckbox() : std::unique_ptr<Checkbox>
}

abstract class Button {
    +paint() : void
}

abstract class Checkbox {
    +paint() : void
}

' ================= Windows äº§å“æ— =================
class WinFactory {
    +createButton() : std::unique_ptr<Button>
    +createCheckbox() : std::unique_ptr<Checkbox>
}

class WinButton {
    +paint() : void
}

class WinCheckbox {
    +paint() : void
}

' ================= Mac äº§å“æ— =================
class MacFactory {
    +createButton() : std::unique_ptr<Button>
    +createCheckbox() : std::unique_ptr<Checkbox>
}

class MacButton {
    +paint() : void
}

class MacCheckbox {
    +paint() : void
}

' ================= ç»§æ‰¿å…³ç³» =================
GUIFactory <|-- WinFactory
GUIFactory <|-- MacFactory

Button <|-- WinButton
Button <|-- MacButton

Checkbox <|-- WinCheckbox
Checkbox <|-- MacCheckbox

' ================= åˆ›å»ºå…³ç³» =================
WinFactory ..> WinButton : creates
WinFactory ..> WinCheckbox : creates

MacFactory ..> MacButton : creates
MacFactory ..> MacCheckbox : creates

note right of GUIFactory
    Abstract Factory
    creates a family of products
end note

note right of WinFactory
    Concrete Factory for Windows
end note

@enduml
```

![](./picture\3.AbstractFactoryPattern.png)

# 6. å•ä¾‹æ¨¡å¼

## ç®€ä»‹

> **å•ä¾‹æ¨¡å¼(Singleton Pattern)** æ˜¯ä¸€ç§åˆ›å»ºå‹è®¾è®¡æ¨¡å¼, å®ƒç¡®ä¿ä¸€ä¸ªç±»**åªæœ‰ä¸€ä¸ªå®ä¾‹**, å¹¶æä¾›ä¸€ä¸ª**å…¨å±€è®¿é—®ç‚¹**æ¥è®¿é—®è¯¥å®ä¾‹ã€‚

**æ ¸å¿ƒæ€æƒ³: **

- **ç§æœ‰åŒ–æ„é€ å‡½æ•°** â†’ é˜²æ­¢å¤–éƒ¨ `new`
- **é™æ€æˆå‘˜å˜é‡** â†’ å­˜å‚¨å”¯ä¸€å®ä¾‹
- **é™æ€æˆå‘˜å‡½æ•°** â†’ æä¾›å…¨å±€è®¿é—®æ¥å£(å¦‚ `getInstance()`

**é€‚ç”¨åœºæ™¯**

1. **éœ€è¦å…¨å±€å”¯ä¸€è®¿é—®ç‚¹çš„å¯¹è±¡**, å¦‚: 
   - é…ç½®ç®¡ç†å™¨(ConfigManager)
   - æ—¥å¿—è®°å½•å™¨(Logger)
   - æ•°æ®åº“è¿æ¥æ± (ConnectionPool)
   - çº¿ç¨‹æ± (ThreadPool)
   - åº”ç”¨ç¨‹åºä¸Šä¸‹æ–‡(ApplicationContext)
2. **èµ„æºéœ€è¦å…±äº«ä¸”æ§åˆ¶è®¿é—®æ•°é‡æ—¶**(å¦‚è®¸å¯è¯ã€ç¡¬ä»¶è®¾å¤‡é©±åŠ¨)ã€‚
3. **é¿å…é¢‘ç¹åˆ›å»ºé”€æ¯å¼€é”€å¤§çš„å¯¹è±¡**ã€‚

ğŸ“Œ **å…¸å‹åº”ç”¨åœºæ™¯: **

- æ¸¸æˆä¸­çš„â€œæ¸¸æˆç®¡ç†å™¨â€
- ç³»ç»Ÿä¸­çš„â€œè®¾ç½®ä¸­å¿ƒâ€
- å¤šçº¿ç¨‹ç¯å¢ƒä¸­çš„â€œå…¨å±€çŠ¶æ€ç®¡ç†â€

**ä¼˜ç¼ºç‚¹**

**âœ… ä¼˜ç‚¹: **

1. **ç¡®ä¿å…¨å±€å”¯ä¸€å®ä¾‹, èŠ‚çœèµ„æºã€‚**
2. **æä¾›å…¨å±€è®¿é—®ç‚¹, ä½¿ç”¨æ–¹ä¾¿ã€‚**
3. **å»¶è¿Ÿåˆå§‹åŒ–(Lazy Initialization)â€”â€” é¦–æ¬¡ä½¿ç”¨æ‰åˆ›å»ºã€‚**
4. **å¯ç»§æ‰¿æ‰©å±•(å—é™, ä½†å¯é€šè¿‡æ¨¡æ¿æˆ–ä¾èµ–æ³¨å…¥ä¼˜åŒ–)ã€‚**

**âŒ ç¼ºç‚¹: **

1. **è¿åå•ä¸€èŒè´£åŸåˆ™** â€”â€” æ—¢è¦ç®¡ç†å®ä¾‹, åˆè¦å¤„ç†ä¸šåŠ¡é€»è¾‘ã€‚
2. **éšè—ä¾èµ–å…³ç³»** â€”â€” ä¸åˆ©äºå•å…ƒæµ‹è¯•(Mock å›°éš¾)ã€‚
3. **å¤šçº¿ç¨‹ç¯å¢ƒä¸‹éœ€è€ƒè™‘çº¿ç¨‹å®‰å…¨**(C++11 åå¯ç®€åŒ–)ã€‚
4. **ç”Ÿå‘½å‘¨æœŸç®¡ç†å›°éš¾** â€”â€” ä½•æ—¶é”€æ¯ï¼Ÿè°æ¥é”€æ¯ï¼Ÿ
5. **å¯èƒ½é€ æˆâ€œå…¨å±€çŠ¶æ€æ±¡æŸ“â€**, å¯¼è‡´ä»£ç è€¦åˆåº¦é«˜ã€‚

> ğŸ’¡ ç°ä»£ C++ é¡¹ç›®ä¸­, å•ä¾‹åº”è°¨æ…ä½¿ç”¨, ä¼˜å…ˆè€ƒè™‘ä¾èµ–æ³¨å…¥(DI)æˆ–æœåŠ¡å®šä½å™¨(Service Locator)ã€‚

**æ³¨æ„äº‹é¡¹(éå¸¸é‡è¦ï¼)**

1. ğŸš¨ çº¿ç¨‹å®‰å…¨(Thread Safety)

2. ğŸš« ç¦æ­¢æ‹·è´å’Œèµ‹å€¼
3. ğŸ•’ ææ„é¡ºåºé—®é¢˜(â€œé™æ€ææ„é¡ºåºæƒ¨æ¡ˆâ€)
4. å•å…ƒæµ‹è¯•å›°éš¾

**ğŸ“Œ ä¸€å¥è¯æ€»ç»“: **

> **å•ä¾‹æ¨¡å¼ = â€œæˆ‘ä¿è¯å…¨å±€åªæœ‰ä¸€ä¸ªæˆ‘, è°è¦ç”¨, æ‰¾æˆ‘æ‹¿â€ã€‚**

## ä»£ç 

```
// Singleton.h
#pragma once
#include <iostream>

class Singleton {
private:
    // ç§æœ‰æ„é€ 
    Singleton() {
        std::cout << "Singleton created!" << std::endl;
    }

    // ç¦æ­¢æ‹·è´
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

public:
    // C++11 Magic Static: çº¿ç¨‹å®‰å…¨ + å»¶è¿Ÿåˆå§‹åŒ– + è‡ªåŠ¨ææ„
    static Singleton& getInstance() {
        static Singleton instance;
        return instance;
    }

    void doSomething() {
        std::cout << "Doing something..." << std::endl;
    }

    ~Singleton() {
        std::cout << "Singleton destroyed!" << std::endl;
    }
};

// main.cpp
#include "Singleton.h"

int main() {
    auto& s1 = Singleton::getInstance();
    s1.doSomething();

    auto& s2 = Singleton::getInstance();
    std::cout << (&s1 == &s2 ? "Same instance!" : "Different!") << std::endl;

    return 0;
}
```

## PlantUML

```
@startuml

class Singleton {
    -{static} instance : Singleton*
    -Singleton()
    +{static} getInstance() : Singleton&
    +doSomething() : void
    -{delete} Singleton(const Singleton&)
    -{delete} operator=(const Singleton&)
}

note right of Singleton::getInstance
    C++11 Magic Static:
    - Thread-safe
    - Lazy initialization
    - Auto destruction
end note

note bottom of Singleton
    Ensures only one instance exists
    and provides global access point.
end note

@enduml
```

![](./picture/4.SingletonPattern.png)

# 7. å»ºé€ è€…æ¨¡å¼

## ç®€ä»‹

> **å»ºé€ è€…æ¨¡å¼(Builder Pattern)** æ˜¯ä¸€ç§åˆ›å»ºå‹è®¾è®¡æ¨¡å¼, å®ƒå°†ä¸€ä¸ª**å¤æ‚å¯¹è±¡çš„æ„å»ºè¿‡ç¨‹ä¸å…¶è¡¨ç¤ºåˆ†ç¦»**, ä½¿å¾—åŒæ ·çš„æ„å»ºè¿‡ç¨‹å¯ä»¥åˆ›å»ºä¸åŒçš„è¡¨ç¤ºã€‚

ğŸ¯ æ ¸å¿ƒæ€æƒ³: 

- å°†å¯¹è±¡çš„**æ„é€ è¿‡ç¨‹åˆ†è§£ä¸ºå¤šä¸ªæ­¥éª¤**(å¦‚ setPartA, setPartB, setPartCâ€¦)
- ä½¿ç”¨ä¸€ä¸ªâ€œå¯¼æ¼”â€(Director)æ§åˆ¶æ„å»ºæµç¨‹(å¯é€‰)
- æœ€ç»ˆè¿”å›å®Œæ•´æ„å»ºå¥½çš„å¯¹è±¡

> ğŸ’¡ é€‚ç”¨äº: å¯¹è±¡æ„é€ å¤æ‚ã€å‚æ•°å¤šã€æ„é€ æ­¥éª¤å¤šã€éœ€è¦çµæ´»ç»„åˆä¸åŒéƒ¨åˆ†ã€‚

ğŸ§© **ç»“æ„ç»„æˆ**: 

| è§’è‰²              | è¯´æ˜                                             |
| ----------------- | ------------------------------------------------ |
| `Product`         | è¢«æ„å»ºçš„å¤æ‚å¯¹è±¡(å¦‚æ±½è½¦ã€SQLæŸ¥è¯¢ã€HTMLæ–‡æ¡£)    |
| `Builder`         | æŠ½è±¡å»ºé€ è€…, å®šä¹‰æ„å»ºå„éƒ¨åˆ†çš„æ¥å£                 |
| `ConcreteBuilder` | å…·ä½“å»ºé€ è€…, å®ç°æ„å»ºæ­¥éª¤, æä¾›è·å–æœ€ç»ˆäº§å“çš„æ¥å£ |
| `Director`        | (å¯é€‰)æŒ‡å¯¼æ„å»ºè¿‡ç¨‹, å°è£…æ„å»ºæµç¨‹               |

âœ…**é€‚ç”¨åœºæ™¯**

1. **åˆ›å»ºå¤æ‚å¯¹è±¡, å…¶æ„é€ è¿‡ç¨‹åŒ…å«å¤šä¸ªæ­¥éª¤æˆ–éƒ¨ä»¶ã€‚**
2. **æ„é€ è¿‡ç¨‹å¿…é¡»å…è®¸æ„é€ ä¸åŒçš„è¡¨ç¤º(å¦‚ä¸åŒé…ç½®çš„æ±½è½¦ã€ä¸åŒé£æ ¼çš„æ–‡æ¡£)ã€‚**
3. **å¯¹è±¡çš„æ„é€ ç®—æ³•åº”ç‹¬ç«‹äºç»„æˆéƒ¨åˆ†å’Œè£…é…æ–¹å¼ã€‚**
4. **æ„é€ è¿‡ç¨‹éœ€è¦è¢«å¤ç”¨æˆ–æ ‡å‡†åŒ–(å¦‚â€œæ ‡å‡†å¥—é¤â€ã€â€œè±ªåå¥—é¤â€)ã€‚**

ğŸ“Œ **å…¸å‹åº”ç”¨åœºæ™¯: **

- æ„å»º SQL æŸ¥è¯¢è¯­å¥(SELECT, FROM, WHERE, GROUP BYâ€¦)
- æ„å»º HTML / XML æ–‡æ¡£
- æ¸¸æˆè§’è‰²åˆ›å»º(ä¸åŒè£…å¤‡ã€å±æ€§ç»„åˆ)
- æ±½è½¦/ç”µè„‘é…ç½®å™¨(é€‰é… CPUã€å†…å­˜ã€ç¡¬ç›˜â€¦)
- æµå¼ API(å¦‚ std::ostringstream, Qt çš„ä¿¡å·æ§½è¿æ¥å™¨)

**ä¼˜ç¼ºç‚¹**

**âœ… ä¼˜ç‚¹: **

1. **åˆ†ç¦»æ„é€ ä¸è¡¨ç¤º** â†’ åŒä¸€æ„å»ºè¿‡ç¨‹å¯åˆ›å»ºä¸åŒäº§å“ã€‚
2. **æ›´ç²¾ç»†æ§åˆ¶æ„é€ è¿‡ç¨‹** â†’ å¯è·³è¿‡ã€é‡å¤ã€æ¡ä»¶åŒ–æŸäº›æ­¥éª¤ã€‚
3. **ä»£ç å¯è¯»æ€§é«˜** â†’ æ­¥éª¤æ¸…æ™°, æ˜“äºç»´æŠ¤ã€‚
4. **æ”¯æŒ Fluent Interface(æµå¼è°ƒç”¨)** â†’ æå‡ API ä½“éªŒã€‚
5. **ç¬¦åˆå¼€é—­åŸåˆ™** â†’ æ–°å¢ Builder ä¸å½±å“åŸæœ‰ä»£ç ã€‚

**âŒ ç¼ºç‚¹: **

1. **ç±»æ•°é‡å¢åŠ ** â†’ æ¯ä¸ªäº§å“å˜ä½“å¯èƒ½éœ€è¦ä¸€ä¸ª Builderã€‚
2. **ç»“æ„ç•¥å¤æ‚** â†’ å°é¡¹ç›®æˆ–ç®€å•å¯¹è±¡ä¸æ¨èä½¿ç”¨ã€‚
3. **Director éå¿…éœ€** â†’ æœ‰æ—¶å®¢æˆ·ç«¯ç›´æ¥è°ƒç”¨ Builder æ›´çµæ´»ã€‚

âœ…**æ³¨æ„äº‹é¡¹**

1. **Builder é€šå¸¸ä¸æŒæœ‰æœ€ç»ˆäº§å“çŠ¶æ€, è€Œæ˜¯é€æ­¥æ„å»ºã€‚**
2. **æœ€ç»ˆäº§å“åº”æä¾›â€œè·å–ç»“æœâ€æ–¹æ³•(å¦‚ `getProduct()`)ã€‚**
3. **å¯é€‰: æä¾›â€œé‡ç½®â€æ–¹æ³•, ä»¥ä¾¿ Builder é‡ç”¨ã€‚**
4. **C++ ä¸­æ¨èè¿”å› `std::unique_ptr` æˆ–å€¼å¯¹è±¡, é¿å…è£¸æŒ‡é’ˆã€‚**
5. **æ”¯æŒ Fluent Interface æ—¶, æ¯ä¸ª setter è¿”å› `\*this`ã€‚**
6. **çº¿ç¨‹å®‰å…¨: Builder é€šå¸¸éçº¿ç¨‹å®‰å…¨, åº”é¿å…å…±äº«ã€‚**

> **è®°å¿†å£è¯€: **
>
> - **å·¥å‚ â†’ â€œç»™ä½ ä¸€ä¸ªæˆå“â€**
> - **å»ºé€ è€… â†’ â€œä¸€æ­¥æ­¥å¸®ä½ æ­å‡ºæ¥â€**

ğŸ“Œ **ç»ˆæå»ºè®®: **

> **ç°ä»£ C++ ä¸­, ä¼˜å…ˆè€ƒè™‘ Fluent Builder(æµå¼æ¥å£), å®ƒæ›´ç›´è§‚ã€æ›´æ˜“ç”¨ã€æ›´ç¬¦åˆç›´è§‰ã€‚Director å¯é€‰, å®¢æˆ·ç«¯ç›´æ¥è°ƒç”¨ Builder å¾€å¾€æ›´çµæ´»ã€‚**



## ä»£ç 

```
// Computer.h
#include <iostream>
#include <string>
#include <memory>

// äº§å“ç±»: è®¡ç®—æœº
class Computer {
private:
    std::string cpu;
    std::string ram;
    std::string storage;
    bool hasGPU = false;
    bool hasSSD = false;

public:
    // è®¾ç½®å™¨(å¯é€‰, Builder ä¹Ÿå¯ç›´æ¥è®¿é—®ç§æœ‰æˆå‘˜, æˆ–è®¾ä¸º friend)
    void setCPU(const std::string& c) { cpu = c; }
    void setRAM(const std::string& r) { ram = r; }
    void setStorage(const std::string& s) { storage = s; }
    void setGPU(bool g) { hasGPU = g; }
    void setSSD(bool s) { hasSSD = s; }

    void show() const {
        std::cout << "=== Computer Configuration ===\n";
        std::cout << "CPU: " << cpu << "\n";
        std::cout << "RAM: " << ram << "\n";
        std::cout << "Storage: " << storage << "\n";
        std::cout << "GPU: " << (hasGPU ? "Yes" : "No") << "\n";
        std::cout << "SSD: " << (hasSSD ? "Yes" : "No") << "\n";
        std::cout << "=============================\n\n";
    }
};

// æŠ½è±¡å»ºé€ è€…
class ComputerBuilder {
public:
    virtual ~ComputerBuilder() = default;
    virtual void buildCPU() = 0;
    virtual void buildRAM() = 0;
    virtual void buildStorage() = 0;
    virtual void buildGPU() = 0;
    virtual void buildSSD() = 0;
    virtual std::unique_ptr<Computer> getComputer() = 0;
};

// å…·ä½“å»ºé€ è€…: æ¸¸æˆç”µè„‘
class GamingComputerBuilder : public ComputerBuilder {
private:
    std::unique_ptr<Computer> computer;

public:
    GamingComputerBuilder() {
        computer = std::make_unique<Computer>();
    }

    void buildCPU() override {
        computer->setCPU("Intel i9-13900K");
    }

    void buildRAM() override {
        computer->setRAM("32GB DDR5");
    }

    void buildStorage() override {
        computer->setStorage("2TB NVMe");
    }

    void buildGPU() override {
        computer->setGPU(true);
    }

    void buildSSD() override {
        computer->setSSD(true);
    }

    std::unique_ptr<Computer> getComputer() override {
        return std::move(computer);
    }
};

// å…·ä½“å»ºé€ è€…: åŠå…¬ç”µè„‘
class OfficeComputerBuilder : public ComputerBuilder {
private:
    std::unique_ptr<Computer> computer;

public:
    OfficeComputerBuilder() {
        computer = std::make_unique<Computer>();
    }

    void buildCPU() override {
        computer->setCPU("Intel i5-13400");
    }

    void buildRAM() override {
        computer->setRAM("16GB DDR4");
    }

    void buildStorage() override {
        computer->setStorage("512GB SSD");
    }

    void buildGPU() override {
        computer->setGPU(false);
    }

    void buildSSD() override {
        computer->setSSD(true);
    }

    std::unique_ptr<Computer> getComputer() override {
        return std::move(computer);
    }
};

// å¯¼æ¼”ç±»(å¯é€‰): å°è£…æ„å»ºæµç¨‹
class ComputerDirector {
public:
    static void constructGamingComputer(ComputerBuilder& builder) {
        builder.buildCPU();
        builder.buildRAM();
        builder.buildStorage();
        builder.buildGPU();
        builder.buildSSD();
    }

    static void constructOfficeComputer(ComputerBuilder& builder) {
        builder.buildCPU();
        builder.buildRAM();
        builder.buildStorage();
        builder.buildSSD();
        // ä¸è£…ç‹¬ç«‹æ˜¾å¡
    }
};

// å®¢æˆ·ç«¯ä»£ç 
#include "Computer.h"

int main() {
    // æ–¹å¼1: ä½¿ç”¨ Director
    std::cout << "=== Using Director ===\n";
    GamingComputerBuilder gamingBuilder;
    ComputerDirector::constructGamingComputer(gamingBuilder);
    auto gamingPC = gamingBuilder.getComputer();
    gamingPC->show();

    // æ–¹å¼2: å®¢æˆ·ç«¯ç›´æ¥æ§åˆ¶æ„å»ºæ­¥éª¤(æ›´çµæ´»)
    std::cout << "=== Manual Building ===\n";
    OfficeComputerBuilder officeBuilder;
    officeBuilder.buildCPU();
    officeBuilder.buildRAM();
    officeBuilder.buildStorage();
    officeBuilder.buildSSD();
    // è·³è¿‡ buildGPU()
    auto officePC = officeBuilder.getComputer();
    officePC->show();

    return 0;
}
```

âœ… è¿›é˜¶: Fluent Builder(æµå¼æ¥å£)

```
class FluentComputerBuilder {
private:
    std::unique_ptr<Computer> computer;

public:
    FluentComputerBuilder() : computer(std::make_unique<Computer>()) {}

    FluentComputerBuilder& withCPU(const std::string& cpu) {
        computer->setCPU(cpu);
        return *this; // è¿”å›è‡ªèº«, æ”¯æŒé“¾å¼è°ƒç”¨
    }

    FluentComputerBuilder& withRAM(const std::string& ram) {
        computer->setRAM(ram);
        return *this;
    }

    FluentComputerBuilder& withStorage(const std::string& storage) {
        computer->setStorage(storage);
        return *this;
    }

    FluentComputerBuilder& withGPU() {
        computer->setGPU(true);
        return *this;
    }

    std::unique_ptr<Computer> build() {
        return std::move(computer);
    }
};

// ä½¿ç”¨æ–¹å¼: 
auto customPC = FluentComputerBuilder()
    .withCPU("AMD Ryzen 9")
    .withRAM("64GB DDR5")
    .withStorage("4TB SSD")
    .withGPU()
    .build();

customPC->show();
```

## PlantUML

```
@startuml

' äº§å“
class Computer {
    -cpu: string
    -ram: string
    -storage: string
    -hasGPU: bool
    -hasSSD: bool
    +setCPU(cpu: string)
    +setRAM(ram: string)
    +setStorage(storage: string)
    +setGPU(gpu: bool)
    +setSSD(ssd: bool)
    +show() : void
}

' æŠ½è±¡å»ºé€ è€…
abstract class ComputerBuilder {
    +buildCPU() : void
    +buildRAM() : void
    +buildStorage() : void
    +buildGPU() : void
    +buildSSD() : void
    +getComputer() : std::unique_ptr<Computer>
}

' å…·ä½“å»ºé€ è€…
class GamingComputerBuilder {
    -computer: std::unique_ptr<Computer>
    +buildCPU()
    +buildRAM()
    +buildStorage()
    +buildGPU()
    +buildSSD()
    +getComputer() : std::unique_ptr<Computer>
}

class OfficeComputerBuilder {
    -computer: std::unique_ptr<Computer>
    +buildCPU()
    +buildRAM()
    +buildStorage()
    +buildGPU()
    +buildSSD()
    +getComputer() : std::unique_ptr<Computer>
}

' å¯¼æ¼”(å¯é€‰)
class ComputerDirector {
    +{static} constructGamingComputer(builder: ComputerBuilder&)
    +{static} constructOfficeComputer(builder: ComputerBuilder&)
}

' å…³ç³»
ComputerBuilder <|-- GamingComputerBuilder
ComputerBuilder <|-- OfficeComputerBuilder

GamingComputerBuilder ..> Computer : builds
OfficeComputerBuilder ..> Computer : builds

ComputerDirector ..> ComputerBuilder : uses

note right of ComputerBuilder
    Defines steps to build
    a Computer.
end note

note bottom of ComputerDirector
    Optional: Encapsulates
    common build sequences.
end note

@enduml
```

![](./picture/5.BuilderPattern.png)

# 8. åŸå‹æ¨¡å¼

## ç®€ä»‹

> **åŸå‹æ¨¡å¼(Prototype Pattern)** æ˜¯ä¸€ç§åˆ›å»ºå‹è®¾è®¡æ¨¡å¼, å®ƒé€šè¿‡**å¤åˆ¶ç°æœ‰å¯¹è±¡(åŸå‹)** æ¥åˆ›å»ºæ–°å¯¹è±¡, è€Œä¸æ˜¯é€šè¿‡ `new` è°ƒç”¨æ„é€ å‡½æ•°ã€‚

ğŸ¯ **æ ¸å¿ƒæ€æƒ³: **

- **â€œå…‹éš†â€ä»£æ›¿â€œæ„é€ â€**
- å®šä¹‰ä¸€ä¸ª `clone()` æ¥å£, ç”±å­ç±»å®ç°å…·ä½“çš„å¤åˆ¶é€»è¾‘
- å®¢æˆ·ç«¯ä¸å…³å¿ƒå¯¹è±¡åˆ›å»ºç»†èŠ‚, åªéœ€å¤åˆ¶åŸå‹å³å¯

> ğŸ’¡ é€‚ç”¨äº: å¯¹è±¡åˆ›å»ºæˆæœ¬é«˜ã€ç»“æ„å¤æ‚ã€æˆ–éœ€åŠ¨æ€é…ç½®å¯¹è±¡æ—¶ã€‚

ğŸ§© **ç»“æ„ç»„æˆ: **

| è§’è‰²                | è¯´æ˜                             |
| ------------------- | -------------------------------- |
| `Prototype`         | å£°æ˜å…‹éš†æ¥å£(å¦‚ `clone()`)     |
| `ConcretePrototype` | å®ç°å…‹éš†æ–¹æ³•, è¿”å›è‡ªèº«å‰¯æœ¬       |
| `Client`            | æŒæœ‰åŸå‹å¯¹è±¡, é€šè¿‡å…‹éš†åˆ›å»ºæ–°å¯¹è±¡ |

âœ…**é€‚ç”¨åœºæ™¯**

1. **å¯¹è±¡åˆ›å»ºæˆæœ¬é«˜(å¦‚éœ€ä»æ•°æ®åº“/ç½‘ç»œåŠ è½½ã€å¤æ‚åˆå§‹åŒ–)**
2. **ç³»ç»Ÿéœ€ç‹¬ç«‹äºå¯¹è±¡çš„åˆ›å»ºã€ç»„åˆå’Œè¡¨ç¤º**
3. **è¿è¡Œæ—¶åŠ¨æ€å†³å®šåˆ›å»ºå¯¹è±¡çš„ç§ç±»(é€šè¿‡é…ç½®åŸå‹æ± )**
4. **é¿å…æ„å»ºç±»å±‚æ¬¡çš„å·¥å‚(ç”¨å…‹éš†ä»£æ›¿å·¥å‚)**
5. **éœ€è¦â€œå¯¹è±¡æ¨¡æ¿â€åŠŸèƒ½(å¦‚æ¸¸æˆä¸­çš„æ€ªç‰©æ¨¡æ¿ã€æ–‡æ¡£æ¨¡æ¿)**

ğŸ“Œ **å…¸å‹åº”ç”¨åœºæ™¯: **

- æ¸¸æˆä¸­å¤§é‡ç›¸åŒæ€ªç‰©/é“å…·çš„ç”Ÿæˆ(å…‹éš†æ¨¡æ¿)
- å›¾å½¢ç¼–è¾‘å™¨ä¸­å¤åˆ¶å¤æ‚å›¾å½¢å¯¹è±¡
- é…ç½®ç®¡ç†ç³»ç»Ÿä¸­å¤åˆ¶é¢„è®¾é…ç½®å¯¹è±¡
- å¤æ‚å¯¹è±¡åˆå§‹åŒ–åä½œä¸ºâ€œé»˜è®¤æ¨¡æ¿â€ä¾›åç»­å¤åˆ¶

âœ… **ä¼˜ç¼ºç‚¹**

âœ… ä¼˜ç‚¹: 

1. **éšè—åˆ›å»ºç»†èŠ‚** â†’ å®¢æˆ·ç«¯æ— éœ€çŸ¥é“å…·ä½“ç±»ã€‚
2. **æ€§èƒ½ä¼˜åŒ–** â†’ é¿å…é‡å¤æ˜‚è´µåˆå§‹åŒ–ã€‚
3. **æ”¯æŒåŠ¨æ€é…ç½®** â†’ è¿è¡Œæ—¶æ›¿æ¢åŸå‹å¯¹è±¡ã€‚
4. **ç®€åŒ–å¯¹è±¡åˆ›å»º** â†’ æ— éœ€å¯¹åº”æ¯ä¸ªç±»å†™å·¥å‚ã€‚
5. **å¯ç»“åˆâ€œåŸå‹æ³¨å†Œè¡¨â€å®ç°é…ç½®åŒ–åˆ›å»ºã€‚**

âŒ ç¼ºç‚¹: 

1. **å¿…é¡»å®ç°å…‹éš†æ–¹æ³•** â†’ æ¯ä¸ªå­ç±»éƒ½è¦å†™ `clone()`ã€‚
2. **æ·±æ‹·è´å®ç°å¤æ‚** â†’ æ¶‰åŠæŒ‡é’ˆã€èµ„æºç®¡ç†æ—¶å®¹æ˜“å‡ºé”™ã€‚
3. **ç ´åå°è£…æ€§** â†’ å…‹éš†å¯èƒ½éœ€è®¿é—®ç§æœ‰æˆå‘˜(å¯å£°æ˜ä¸º `friend` æˆ–æä¾›å¤åˆ¶æ„é€ )ã€‚
4. **å¯¹â€œä¸å¯å˜å¯¹è±¡â€æ— æ„ä¹‰** â†’ å¦‚å…¨æ˜¯ `const` æˆå‘˜ã€‚

âœ… **æ³¨æ„äº‹é¡¹(éå¸¸é‡è¦ï¼)**

1. ğŸš¨ æ·±æ‹·è´ vs æµ…æ‹·è´(C++ æ ¸å¿ƒé—®é¢˜ï¼)

- **æµ…æ‹·è´(é»˜è®¤)**: åªå¤åˆ¶æŒ‡é’ˆå€¼ â†’ å¤šä¸ªå¯¹è±¡å…±äº«åŒä¸€å—å†…å­˜ â†’ å±é™©ï¼
- **æ·±æ‹·è´**: å¤åˆ¶æŒ‡é’ˆæŒ‡å‘çš„å†…å®¹ â†’ ç‹¬ç«‹å‰¯æœ¬ â†’ å®‰å…¨ï¼

âœ… **å¿…é¡»æ‰‹åŠ¨å®ç°æ·±æ‹·è´**, æˆ–ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆ + è‡ªå®šä¹‰å…‹éš†ã€‚

2. ğŸ“Œ å®ç° `clone()` çš„å¸¸è§æ–¹å¼: 

æ–¹å¼1: çº¯è™šå‡½æ•° + å­ç±» override(æ¨è)

æ–¹å¼2: ä½¿ç”¨å¤åˆ¶æ„é€ å‡½æ•°(éœ€æš´éœ²æˆ–å£°æ˜ä¸º friend)

3. ğŸ§© èµ„æºç®¡ç†å»ºè®®: 

- ä½¿ç”¨ `std::unique_ptr` / `std::shared_ptr` ç®¡ç†åŠ¨æ€èµ„æº
- è‹¥å«è£¸æŒ‡é’ˆ, å¿…é¡»åœ¨ `clone()` ä¸­æ‰‹åŠ¨ `new` + æ·±æ‹·è´
- è€ƒè™‘ä½¿ç”¨â€œå¤åˆ¶æ„é€ å‡½æ•° + èµ‹å€¼æ“ä½œç¬¦â€å®ç° RAII

4. ğŸ§ª å¯ç»“åˆâ€œåŸå‹æ³¨å†Œè¡¨â€å®ç°åŠ¨æ€åˆ›å»º

â€‹	std::map<std::string, std::unique_ptr<Prototype>> prototypeRegistry;

â€‹	å®¢æˆ·ç«¯é€šè¿‡ key è·å–åŸå‹å¹¶å…‹éš†, å®ç°â€œé…ç½®åŒ–å¯¹è±¡åˆ›å»ºâ€ã€‚

ğŸ“Œ **ç»ˆæå»ºè®®: **

> **ç°ä»£ C++ ä¸­, è‹¥å¯¹è±¡ä¸å«è£¸æŒ‡é’ˆæˆ–å¤æ‚èµ„æº, ä½¿ç”¨é»˜è®¤å¤åˆ¶æ„é€ å³å¯; è‹¥å«èµ„æº, ä¼˜å…ˆä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆæˆ–å®¹å™¨, é¿å…æ‰‹åŠ¨ç®¡ç†å†…å­˜ã€‚åŸå‹æ¨¡å¼åœ¨æ¸¸æˆå¼€å‘ã€å›¾å½¢ç¼–è¾‘å™¨ã€é…ç½®ç³»ç»Ÿä¸­éå¸¸å®ç”¨ï¼**

æŒæ¡åŸå‹æ¨¡å¼, ä½ å°±èƒ½é«˜æ•ˆâ€œå…‹éš†â€å¯¹è±¡, é¿å…é‡å¤åˆå§‹åŒ–å¼€é”€, æå‡ç³»ç»Ÿæ€§èƒ½å’Œçµæ´»æ€§ï¼

## ä»£ç 

```
// Prototype.h
#include <iostream>
#include <string>
#include <memory>
#include <unordered_map>

// æŠ½è±¡åŸå‹
class EnemyPrototype {
public:
    virtual ~EnemyPrototype() = default;

    // çº¯è™šå…‹éš†å‡½æ•°
    virtual std::unique_ptr<EnemyPrototype> clone() const = 0;

    // ä¸šåŠ¡æ–¹æ³•
    virtual void showInfo() const = 0;
    virtual void fight() const = 0;
};

// å…·ä½“åŸå‹: å“¥å¸ƒæ—
class Goblin : public EnemyPrototype {
private:
    std::string name;
    int health;
    int damage;

public:
    Goblin(const std::string& n = "Goblin", int h = 50, int d = 10)
        : name(n), health(h), damage(d) {}

    // å®ç°æ·±æ‹·è´å…‹éš†
    std::unique_ptr<EnemyPrototype> clone() const override {
        return std::make_unique<Goblin>(*this); // è°ƒç”¨å¤åˆ¶æ„é€ (é»˜è®¤å³å¯, æ— æŒ‡é’ˆ)
    }

    void showInfo() const override {
        std::cout << "[Goblin] Name: " << name << ", Health: " << health << ", Damage: " << damage << std::endl;
    }

    void fight() const override {
        std::cout << name << " attacks with " << damage << " damage!" << std::endl;
    }

    // å¯é€‰: æä¾›ä¿®æ”¹æ–¹æ³•ç”¨äºé…ç½®æ¨¡æ¿
    void setHealth(int h) { health = h; }
    void setDamage(int d) { damage = d; }
    void setName(const std::string& n) { name = n; }
};

// å…·ä½“åŸå‹: å·¨é­”
class Troll : public EnemyPrototype {
private:
    std::string name;
    int health;
    int damage;
    bool regenerates;

public:
    Troll(const std::string& n = "Troll", int h = 100, int d = 20, bool regen = true)
        : name(n), health(h), damage(d), regenerates(regen) {}

    std::unique_ptr<EnemyPrototype> clone() const override {
        return std::make_unique<Troll>(*this);
    }

    void showInfo() const override {
        std::cout << "[Troll] Name: " << name << ", Health: " << health
                  << ", Damage: " << damage << ", Regen: " << (regenerates ? "Yes" : "No") << std::endl;
    }

    void fight() const override {
        std::cout << name << " smashes for " << damage << " damage!" << std::endl;
        if (regenerates) std::cout << name << " starts regenerating health!\n";
    }
};

// åŸå‹ç®¡ç†å™¨(æ³¨å†Œè¡¨)
class EnemyPrototypeManager {
private:
    std::unordered_map<std::string, std::unique_ptr<EnemyPrototype>> prototypes;

public:
    void registerPrototype(const std::string& key, std::unique_ptr<EnemyPrototype> prototype) {
        prototypes[key] = std::move(prototype);
    }

    std::unique_ptr<EnemyPrototype> create(const std::string& key) const {
        auto it = prototypes.find(key);
        if (it != prototypes.end() && it->second) {
            return it->second->clone();
        }
        throw std::runtime_error("Prototype not found: " + key);
    }
};

// main.cpp
#include "Prototype.h"

int main() {
    // åˆ›å»ºåŸå‹æ¨¡æ¿
    auto goblinTemplate = std::make_unique<Goblin>("Green Goblin", 60, 15);
    auto trollTemplate = std::make_unique<Troll>("Cave Troll", 120, 25, true);

    // æ³¨å†Œåˆ°ç®¡ç†å™¨
    EnemyPrototypeManager manager;
    manager.registerPrototype("goblin", std::move(goblinTemplate));
    manager.registerPrototype("troll", std::move(trollTemplate));

    // é€šè¿‡å…‹éš†åˆ›å»ºæ–°å¯¹è±¡
    std::cout << "=== Creating enemies via Prototype ===\n";
    auto enemy1 = manager.create("goblin");
    auto enemy2 = manager.create("troll");
    auto enemy3 = manager.create("goblin"); // å†å…‹éš†ä¸€ä¸ªå“¥å¸ƒæ—

    enemy1->showInfo();
    enemy1->fight();

    enemy2->showInfo();
    enemy2->fight();

    enemy3->showInfo();
    enemy3->fight();

    return 0;
}
```

âœ… å«æŒ‡é’ˆæˆå‘˜çš„æ·±æ‹·è´ç¤ºä¾‹(é‡è¦ï¼)

```
class DeepCopyExample : public EnemyPrototype {
private:
    std::string* name; // å‡è®¾ç”¨è£¸æŒ‡é’ˆ(å®é™…æ¨èç”¨ std::string)
    int health;

public:
    DeepCopyExample(const std::string& n = "Default", int h = 100) 
        : health(h) {
        name = new std::string(n);
    }

    // æ·±æ‹·è´å¤åˆ¶æ„é€ 
    DeepCopyExample(const DeepCopyExample& other)
        : health(other.health) {
        name = new std::string(*other.name); // æ·±æ‹·è´ï¼
    }

    // å¿…é¡»é‡è½½èµ‹å€¼æ“ä½œç¬¦(Rule of Three)
    DeepCopyExample& operator=(const DeepCopyExample& other) {
        if (this != &other) {
            delete name;
            name = new std::string(*other.name);
            health = other.health;
        }
        return *this;
    }

    ~DeepCopyExample() {
        delete name;
    }

    std::unique_ptr<EnemyPrototype> clone() const override {
        return std::make_unique<DeepCopyExample>(*this); // è°ƒç”¨å¤åˆ¶æ„é€ 
    }

    void showInfo() const override {
        std::cout << "Name: " << *name << ", Health: " << health << std::endl;
    }

    void fight() const override {
        std::cout << *name << " fights!\n";
    }
};
```

## PlantUML

```
@startuml

' æŠ½è±¡åŸå‹
abstract class EnemyPrototype {
    +clone() : std::unique_ptr<EnemyPrototype>
    +showInfo() : void
    +fight() : void
}

' å…·ä½“åŸå‹
class Goblin {
    -name: string
    -health: int
    -damage: int
    +clone() : std::unique_ptr<EnemyPrototype>
    +showInfo() : void
    +fight() : void
    +setHealth(h: int)
    +setDamage(d: int)
}

class Troll {
    -name: string
    -health: int
    -damage: int
    -regenerates: bool
    +clone() : std::unique_ptr<EnemyPrototype>
    +showInfo() : void
    +fight() : void
}

' åŸå‹ç®¡ç†å™¨
class EnemyPrototypeManager {
    -prototypes: map<string, unique_ptr<EnemyPrototype>>
    +registerPrototype(key: string, prototype: unique_ptr<EnemyPrototype>)
    +create(key: string) : unique_ptr<EnemyPrototype>
}

' å…³ç³»
EnemyPrototype <|-- Goblin
EnemyPrototype <|-- Troll

EnemyPrototypeManager o-- EnemyPrototype : holds prototypes

note right of EnemyPrototype::clone
    Pure virtual function
    Subclasses implement
    deep copy logic.
end note

note bottom of EnemyPrototypeManager
    Optional registry for
    dynamic prototype access.
end note

@enduml
```

![](./picture/6.PrototypePattern.png)

# ğŸ”Œç»“æ„å‹æ¨¡å¼

# 9. é€‚é…å™¨æ¨¡å¼

## ç®€ä»‹

> **é€‚é…å™¨æ¨¡å¼(Adapter Pattern)** æ˜¯ä¸€ç§ç»“æ„å‹è®¾è®¡æ¨¡å¼, å®ƒ**å°†ä¸€ä¸ªç±»çš„æ¥å£è½¬æ¢æˆå®¢æˆ·æœŸæœ›çš„å¦ä¸€ä¸ªæ¥å£**, ä½¿å¾—åŸæœ¬ç”±äºæ¥å£ä¸å…¼å®¹è€Œä¸èƒ½ä¸€èµ·å·¥ä½œçš„ç±»å¯ä»¥ååŒå·¥ä½œã€‚

ğŸ¯ **æ ¸å¿ƒæ€æƒ³: **

- **â€œæ¥å£è½¬æ¢å™¨â€** â€”â€” åƒç”µæºé€‚é…å™¨ä¸€æ ·, æŠŠâ€œä¸åŒ¹é…çš„æ’å¤´â€å˜æˆâ€œåŒ¹é…çš„æ’å¤´â€
- è§£å†³â€œè€æ¥å£â€ä¸â€œæ–°éœ€æ±‚â€ä¹‹é—´çš„ä¸å…¼å®¹é—®é¢˜
- ä¸ä¿®æ”¹åŸæœ‰ç±», é€šè¿‡â€œåŒ…è£…â€å®ç°æ¥å£è½¬æ¢

> ğŸ’¡ é€‚ç”¨äº: é›†æˆç¬¬ä¸‰æ–¹åº“ã€æ—§ç³»ç»Ÿæ”¹é€ ã€æ¥å£æ ‡å‡†åŒ–ç­‰åœºæ™¯ã€‚

ğŸ§© **ç»“æ„ç»„æˆ: **

| è§’è‰²      | è¯´æ˜                                            |
| --------- | ----------------------------------------------- |
| `Target`  | å®¢æˆ·ç«¯æœŸæœ›çš„æ¥å£(æŠ½è±¡ç±»æˆ–æ¥å£)                |
| `Adaptee` | å·²å­˜åœ¨çš„ã€ä½†æ¥å£ä¸å…¼å®¹çš„ç±»(â€œè¢«é€‚é…è€…â€)        |
| `Adapter` | é€‚é…å™¨, ç»§æ‰¿/ç»„åˆ `Adaptee`, å®ç° `Target` æ¥å£ |

âœ… **é€‚ç”¨åœºæ™¯**

1. **ä½¿ç”¨ç°æœ‰ç±», ä½†å…¶æ¥å£ä¸ç¬¦åˆéœ€æ±‚ã€‚**
2. **æƒ³å¤ç”¨ä¸€äº›ç°å­˜çš„ç±», ä½†æ— æ³•ä¿®æ”¹å…¶æºç (å¦‚ç¬¬ä¸‰æ–¹åº“)ã€‚**
3. **åˆ›å»ºä¸€ä¸ªå¯å¤ç”¨çš„ç±», ä¸å…¶ä»–ä¸ç›¸å…³æˆ–ä¸å¯é¢„è§çš„ç±»ååŒå·¥ä½œã€‚**
4. **ç³»ç»Ÿæ•°æ®/æ¥å£å‡çº§, éœ€è¦å…¼å®¹æ—§ç‰ˆæœ¬æ¥å£ã€‚**

ğŸ“Œ **å…¸å‹åº”ç”¨åœºæ™¯: **

- å°†æ—§ç‰ˆæ—¥å¿—æ¥å£é€‚é…åˆ°æ–°ç‰ˆç»Ÿä¸€æ—¥å¿—ç³»ç»Ÿ
- å°†ç¬¬ä¸‰æ–¹æ”¯ä»˜ SDK(å¦‚æ”¯ä»˜å®ã€å¾®ä¿¡)ç»Ÿä¸€æˆå†…éƒ¨æ”¯ä»˜æ¥å£
- å°†ä¸åŒå›¾å½¢åº“(OpenGL/DirectX)ç»Ÿä¸€æˆå¼•æ“æ¸²æŸ“æ¥å£
- å°† C é£æ ¼ API é€‚é…æˆ C++ RAII æ¥å£
- æ¸¸æˆä¸­ä¸åŒè¾“å…¥è®¾å¤‡(é”®ç›˜ã€æ‰‹æŸ„ã€è§¦å±)ç»Ÿä¸€æˆâ€œè¾“å…¥äº‹ä»¶â€

âœ… **ä¼˜ç¼ºç‚¹**

âœ… ä¼˜ç‚¹: 

1. **æé«˜ç±»çš„å¤ç”¨æ€§** â†’ ä¸ä¿®æ”¹åŸæœ‰ä»£ç å³å¯é›†æˆã€‚
2. **å¢å¼ºç±»çš„é€æ˜æ€§å’Œå¤ç”¨æ€§** â†’ å®¢æˆ·ç«¯åªä¸ Target æ¥å£äº¤äº’ã€‚
3. **çµæ´»æ€§é«˜** â†’ å¯åŒæ—¶é€‚é…å¤šä¸ª Adapteeã€‚
4. **ç¬¦åˆå¼€é—­åŸåˆ™** â†’ å¯¹æ‰©å±•å¼€æ”¾, å¯¹ä¿®æ”¹å…³é—­ã€‚

âŒ ç¼ºç‚¹: 

1. **å¢åŠ ç³»ç»Ÿå¤æ‚åº¦** â†’ å¼•å…¥é¢å¤–çš„é€‚é…å™¨ç±»ã€‚
2. **è¿‡å¤šé€‚é…å™¨ä¼šè®©ç³»ç»Ÿâ€œç»•æ¥ç»•å»â€** â†’ è°ƒè¯•å›°éš¾ã€‚
3. **æ€§èƒ½ç•¥æœ‰æŸå¤±** â†’ å¤šä¸€å±‚è°ƒç”¨(é€šå¸¸å¯å¿½ç•¥)ã€‚

âœ… **æ³¨æ„äº‹é¡¹**

1. ğŸ”„ ä¸¤ç§å®ç°æ–¹å¼: 

| æ–¹å¼           | è¯´æ˜                         | ä¼˜ç‚¹                 | ç¼ºç‚¹                     |
| -------------- | ---------------------------- | -------------------- | ------------------------ |
| **ç±»é€‚é…å™¨**   | é€šè¿‡å¤šé‡ç»§æ‰¿å®ç°(C++ æ”¯æŒ) | æ•ˆç‡é«˜, ç›´æ¥ç»§æ‰¿     | ä¸çµæ´», C++ å¤šé‡ç»§æ‰¿å¤æ‚ |
| **å¯¹è±¡é€‚é…å™¨** | é€šè¿‡ç»„åˆ + å§”æ‰˜å®ç°(æ¨è)  | çµæ´», å¯é€‚é…ç±»çš„å­ç±» | å¤šä¸€å±‚å¯¹è±¡å¼•ç”¨           |

> âœ… **ç°ä»£ C++ æ¨èä½¿ç”¨â€œå¯¹è±¡é€‚é…å™¨â€** â€”â€” æ›´çµæ´»ã€æ›´å®‰å…¨ã€æ›´ç¬¦åˆç»„åˆä¼˜äºç»§æ‰¿åŸåˆ™ã€‚

2. âš ï¸ é€‚é…å™¨ä¸æ˜¯ä¸‡èƒ½èƒ¶æ°´

- é€‚é…å™¨ç”¨äº**æ¥å£è½¬æ¢**, ä¸æ˜¯ç”¨äº**åŠŸèƒ½å¢å¼º**
- å¦‚æœä¸¤ä¸ªç±»è¯­ä¹‰å®Œå…¨ä¸ç›¸å…³, å¼ºè¡Œé€‚é…ä¼šå¯¼è‡´é€»è¾‘æ··ä¹±

3. ğŸ“¦ é€‚é…å™¨å¯ç»“åˆâ€œå·¥å‚æ¨¡å¼â€åŠ¨æ€é€‰æ‹©é€‚é…å¯¹è±¡

4. ğŸ§© é€‚é…å™¨å¯â€œåŒå‘é€‚é…â€

- æœ‰æ—¶éœ€è¦ Aâ†’B, æœ‰æ—¶éœ€è¦ Bâ†’A, å¯è®¾è®¡åŒå‘é€‚é…å™¨(è¾ƒå°‘è§)

ğŸ¯ **æ¨èè¯­: **

> **å½“ä½ é¢å¯¹â€œç¥–ä¼ ä»£ç â€æˆ–â€œç¬¬ä¸‰æ–¹é»‘ç›’åº“â€æ—¶, é€‚é…å™¨æ¨¡å¼æ˜¯ä½ æœ€å¥½çš„æœ‹å‹ã€‚å®ƒè®©ä½ åœ¨ä¸ç ´ååŸæœ‰ç³»ç»Ÿçš„æƒ…å†µä¸‹, ä¼˜é›…åœ°é›†æˆæ–°åŠŸèƒ½ã€‚**

æŒæ¡é€‚é…å™¨æ¨¡å¼, ä½ å°±èƒ½åœ¨â€œæ¥å£ä¸å…¼å®¹â€çš„æˆ˜åœºä¸Šæ‰€å‘æŠ«é¡ï¼

## ä»£ç 

```
// Target.h - å®¢æˆ·ç«¯æœŸæœ›çš„æ¥å£
#pragma once
#include <string>
#include <iostream>

// ç›®æ ‡æ¥å£: ç»Ÿä¸€æ”¯ä»˜æ¥å£
class IPayment {
public:
    virtual ~IPayment() = default;
    virtual bool pay(double amount, const std::string& orderId) = 0;
    virtual std::string getName() const = 0;
};

// ==============================
// Adaptee: å¾®ä¿¡æ”¯ä»˜(ç¬¬ä¸‰æ–¹åº“, ä¸èƒ½æ”¹)
class WeChatPaySDK {
public:
    // æ³¨æ„: æ¥å£ä¸å…¼å®¹ï¼å‚æ•°é¡ºåºã€ç±»å‹ã€è¿”å›å€¼éƒ½ä¸åŒ
    int makePayment(const std::string& tradeNo, float price) {
        std::cout << "[WeChatPay] Paying " << price << " for order " << tradeNo << std::endl;
        return 0; // 0=success
    }
};

// ==============================
// Adaptee: æ”¯ä»˜å®(ç¬¬ä¸‰æ–¹åº“, ä¸èƒ½æ”¹)
class AliPaySDK {
public:
    // æ¥å£åˆä¸ä¸€æ ·ï¼
    bool doPay(float money, const char* orderNum) {
        std::cout << "[AliPay] Paying " << money << " for order " << orderNum << std::endl;
        return true; // true=success
    }
};

// ==============================
// å¯¹è±¡é€‚é…å™¨: å¾®ä¿¡æ”¯ä»˜é€‚é…å™¨(æ¨èæ–¹å¼)
class WeChatPayAdapter : public IPayment {
private:
    WeChatPaySDK wechat; // ç»„åˆ

public:
    bool pay(double amount, const std::string& orderId) override {
        int result = wechat.makePayment(orderId, static_cast<float>(amount));
        return result == 0;
    }

    std::string getName() const override {
        return "WeChat Pay";
    }
};

// ==============================
// å¯¹è±¡é€‚é…å™¨: æ”¯ä»˜å®é€‚é…å™¨
class AliPayAdapter : public IPayment {
private:
    AliPaySDK alipay; // ç»„åˆ

public:
    bool pay(double amount, const std::string& orderId) override {
        bool result = alipay.doPay(static_cast<float>(amount), orderId.c_str());
        return result;
    }

    std::string getName() const override {
        return "AliPay";
    }
};

// ==============================
// å®¢æˆ·ç«¯ä»£ç 
#include "Target.h"

class PaymentProcessor {
public:
    static void processPayment(IPayment& payment, double amount, const std::string& orderId) {
        std::cout << "Processing payment via " << payment.getName() << "...\n";
        if (payment.pay(amount, orderId)) {
            std::cout << "âœ… Payment successful!\n\n";
        } else {
            std::cout << "âŒ Payment failed!\n\n";
        }
    }
};

// main.cpp
int main() {
    WeChatPayAdapter wechatAdapter;
    AliPayAdapter aliAdapter;

    PaymentProcessor::processPayment(wechatAdapter, 99.9, "ORDER_12345");
    PaymentProcessor::processPayment(aliAdapter, 199.5, "ORDER_67890");

    return 0;
}
```

âœ… è¿›é˜¶: å¸¦å·¥å‚çš„åŠ¨æ€é€‚é…å™¨

```
class PaymentAdapterFactory {
public:
    static std::unique_ptr<IPayment> create(const std::string& type) {
        if (type == "wechat") return std::make_unique<WeChatPayAdapter>();
        if (type == "alipay") return std::make_unique<AliPayAdapter>();
        throw std::invalid_argument("Unsupported payment type: " + type);
    }
};

// ä½¿ç”¨: 
auto payment = PaymentAdapterFactory::create("wechat");
PaymentProcessor::processPayment(*payment, 50.0, "DYNAMIC_ORDER");
```

## PlantUML

```
@startuml

' ç›®æ ‡æ¥å£
interface IPayment {
    +pay(amount: double, orderId: string) : bool
    +getName() : string
}

' è¢«é€‚é…è€…(å¾®ä¿¡)
class WeChatPaySDK {
    +makePayment(tradeNo: string, price: float) : int
}

' è¢«é€‚é…è€…(æ”¯ä»˜å®)
class AliPaySDK {
    +doPay(money: float, orderNum: char*) : bool
}

' é€‚é…å™¨(å¯¹è±¡é€‚é…å™¨ - æ¨è)
class WeChatPayAdapter {
    -wechat: WeChatPaySDK
    +pay(amount: double, orderId: string) : bool
    +getName() : string
}

class AliPayAdapter {
    -alipay: AliPaySDK
    +pay(amount: double, orderId: string) : bool
    +getName() : string
}

' å®¢æˆ·ç«¯
class PaymentProcessor {
    +{static} processPayment(payment: IPayment&, amount: double, orderId: string)
}

' å…³ç³»
WeChatPayAdapter ..|> IPayment
AliPayAdapter ..|> IPayment

WeChatPayAdapter *-- WeChatPaySDK : adapts
AliPayAdapter *-- AliPaySDK : adapts

PaymentProcessor --> IPayment : uses

note right of WeChatPayAdapter
    Object Adapter (Composition)
    Recommended in modern C++
end note

note right of AliPayAdapter
    Converts AliPaySDK interface
    to IPayment interface.
end note

@enduml
```

![](./picture/7.AdapterPattern.png)

# 10. æ¡¥æ¥æ¨¡å¼

## ç®€ä»‹

> **æ¡¥æ¥æ¨¡å¼(Bridge Pattern)** æ˜¯ä¸€ç§**ç»“æ„å‹è®¾è®¡æ¨¡å¼**, å®ƒå°†**æŠ½è±¡éƒ¨åˆ†ä¸å®ç°éƒ¨åˆ†åˆ†ç¦»**, ä½¿å®ƒä»¬å¯ä»¥**ç‹¬ç«‹å˜åŒ–**ã€‚

ğŸ¯ æ ¸å¿ƒæ€æƒ³: 

- â€œæŠ½è±¡â€ ä¸ â€œå®ç°â€ è§£è€¦ â†’ ç”¨**ç»„åˆä»£æ›¿ç»§æ‰¿**
- æŠ½è±¡å±‚æŒæœ‰ä¸€ä¸ªâ€œå®ç°å±‚â€çš„å¼•ç”¨(æŒ‡é’ˆ)
- ä¸¤è€…å¯ç‹¬ç«‹æ‰©å±•, é¿å…â€œç±»çˆ†ç‚¸â€

> ğŸ’¡ æ¡¥æ¥ = â€œæŠ½è±¡â€ ä¸ â€œå®ç°â€ ä¹‹é—´çš„æ¡¥æ¢ â†’ åŠ¨æ€ç»‘å®š, è¿è¡Œæ—¶åˆ‡æ¢å®ç°ã€‚

ğŸ“Œ **ç»å…¸æ¯”å–»: **

> ç”µè§†(æŠ½è±¡)å’Œé¥æ§å™¨(å®ç°)â€”â€” åŒä¸€ä¸ªé¥æ§å™¨å¯ä»¥æ§åˆ¶ä¸åŒå“ç‰Œç”µè§†, åŒä¸€ç”µè§†ä¹Ÿå¯é…ä¸åŒé¥æ§å™¨ã€‚

ğŸ§© ç»“æ„ç»„æˆ: 

| è§’è‰²                  | è¯´æ˜                                             |
| --------------------- | ------------------------------------------------ |
| `Abstraction`         | æŠ½è±¡ç±», å®šä¹‰é«˜å±‚æ§åˆ¶æ¥å£, æŒæœ‰ä¸€ä¸ª `Implementor` |
| `RefinedAbstraction`  | æ‰©å±•æŠ½è±¡(å¯é€‰), å¦‚ä¸åŒå½¢çŠ¶ã€ä¸åŒè®¾å¤‡           |
| `Implementor`         | å®ç°æ¥å£, å®šä¹‰åº•å±‚æ“ä½œ(å¦‚ç»˜åˆ¶ã€é©±åŠ¨)           |
| `ConcreteImplementor` | å…·ä½“å®ç°, å¦‚ OpenGLã€DirectXã€Vulkan æ¸²æŸ“å™¨      |

âœ… é€‚ç”¨åœºæ™¯

1. **ä½ ä¸å¸Œæœ›åœ¨æŠ½è±¡å’Œå®ç°ä¹‹é—´æœ‰å›ºå®šçš„ç»‘å®šå…³ç³»(ç»§æ‰¿å¤ªæ­»æ¿)**
2. **æŠ½è±¡åŠå…¶å®ç°éƒ½åº”å¯é€šè¿‡å­ç±»åŒ–ç‹¬ç«‹æ‰©å±•**
3. **å¯¹æŠ½è±¡çš„å®ç°ä¿®æ”¹ä¸åº”å½±å“å®¢æˆ·ç«¯ä»£ç **
4. **ä½ æƒ³åœ¨è¿è¡Œæ—¶åˆ‡æ¢å®ç°(å¦‚åˆ‡æ¢æ¸²æŸ“åç«¯ã€æ•°æ®åº“é©±åŠ¨)**
5. **é¿å…â€œå¤šç»´åº¦ç»§æ‰¿â€å¯¼è‡´çš„ç±»çˆ†ç‚¸(å¦‚ Shape Ã— Color Ã— Renderer = NÃ—MÃ—K ä¸ªç±»)**

ğŸ“Œ **å…¸å‹åº”ç”¨åœºæ™¯: **

- å›¾å½¢åº“: Shape(æŠ½è±¡) + Renderer(å®ç°: OpenGL/DirectX/Vulkan)
- è·¨å¹³å° UI: Button(æŠ½è±¡) + PlatformImpl(Win/Mac/Linux)
- æ•°æ®åº“é©±åŠ¨: DAO(æŠ½è±¡) + DriverImpl(MySQL/PostgreSQL/SQLite)
- æ¸¸æˆå¼•æ“: GameObject(æŠ½è±¡) + PhysicsEngine(Box2D/Bullet)
- é¥æ§è®¾å¤‡: TV(æŠ½è±¡) + RemoteControl(çº¢å¤–/è“ç‰™/WiFi)

âœ… ä¼˜ç¼ºç‚¹

âœ… ä¼˜ç‚¹: 

1. **åˆ†ç¦»æŠ½è±¡ä¸å®ç°** â†’ ä¸¤è€…å¯ç‹¬ç«‹æ‰©å±•, ç¬¦åˆå•ä¸€èŒè´£åŸåˆ™ã€‚
2. **é¿å…ç±»çˆ†ç‚¸** â†’ N ä¸ªæŠ½è±¡ Ã— M ä¸ªå®ç° = N+M ä¸ªç±», è€Œä¸æ˜¯ NÃ—Mã€‚
3. **è¿è¡Œæ—¶åˆ‡æ¢å®ç°** â†’ çµæ´», å¦‚åˆ‡æ¢å›¾å½¢ APIã€æ•°æ®åº“åç«¯ã€‚
4. **æé«˜å¯æ‰©å±•æ€§** â†’ æ–°å¢å®ç°ä¸å½±å“æŠ½è±¡å±‚, åä¹‹äº¦ç„¶ã€‚
5. **éšè—å®ç°ç»†èŠ‚** â†’ å®¢æˆ·ç«¯åªä¸æŠ½è±¡å±‚äº¤äº’ã€‚

âŒ ç¼ºç‚¹: 

1. **å¢åŠ ç³»ç»Ÿå¤æ‚åº¦** â†’ å¼•å…¥é¢å¤–å±‚æ¬¡ã€‚
2. **å®¢æˆ·ç«¯éœ€ç†è§£â€œæ¡¥æ¥â€æ¦‚å¿µ** â†’ åˆå­¦è€…å¯èƒ½å›°æƒ‘ã€‚
3. **ä»…é€‚ç”¨äºâ€œæŠ½è±¡-å®ç°â€å¯åˆ†ç¦»çš„åœºæ™¯** â†’ ä¸æ˜¯ä¸‡èƒ½ã€‚

ğŸ¯ **æ¨èè¯­: **

> **æ¡¥æ¥æ¨¡å¼æ˜¯è§£å†³â€œå¤šç»´åº¦å˜åŒ–â€é—®é¢˜çš„åˆ©å™¨ã€‚å½“ä½ å‘ç°ç±»åœ¨å¤šä¸ªç»´åº¦ä¸Šæ‰©å±•å¯¼è‡´å­ç±»çˆ†ç‚¸æ—¶, æ¡¥æ¥æ¨¡å¼å°±æ˜¯ä½ çš„æ•‘æ˜Ÿï¼**

æŒæ¡æ¡¥æ¥æ¨¡å¼, ä½ å°±èƒ½è®¾è®¡å‡ºé«˜åº¦çµæ´»ã€æ˜“äºæ‰©å±•çš„ç³»ç»Ÿæ¶æ„ï¼

## ä»£ç 

```
// Bridge.h
#include <iostream>
#include <memory>
#include <string>

// ============ å®ç°å±‚ ============
// æŠ½è±¡å®ç°æ¥å£
class Renderer {
public:
    virtual ~Renderer() = default;
    virtual void render(const std::string& shapeType, const std::string& info) = 0;
};

// å…·ä½“å®ç°: OpenGL
class OpenGLRenderer : public Renderer {
public:
    void render(const std::string& shapeType, const std::string& info) override {
        std::cout << "[OpenGL] Rendering " << shapeType << ": " << info << std::endl;
    }
};

// å…·ä½“å®ç°: DirectX
class DirectXRenderer : public Renderer {
public:
    void render(const std::string& shapeType, const std::string& info) override {
        std::cout << "[DirectX] Drawing " << shapeType << " -> " << info << std::endl;
    }
};

// å…·ä½“å®ç°: Vulkan
class VulkanRenderer : public Renderer {
public:
    void render(const std::string& shapeType, const std::string& info) override {
        std::cout << "[Vulkan] ğŸš€ Ultra-fast rendering of " << shapeType << " (" << info << ")" << std::endl;
    }
};

// ============ æŠ½è±¡å±‚ ============
// æŠ½è±¡å›¾å½¢
class Shape {
protected:
    std::unique_ptr<Renderer> renderer; // æ¡¥æ¥æ ¸å¿ƒ: ç»„åˆè€Œéç»§æ‰¿

public:
    Shape(std::unique_ptr<Renderer> r) : renderer(std::move(r)) {}

    virtual ~Shape() = default;

    // è®¾ç½®æ¸²æŸ“å™¨(è¿è¡Œæ—¶åˆ‡æ¢)
    void setRenderer(std::unique_ptr<Renderer> r) {
        renderer = std::move(r);
    }

    virtual void draw() = 0;
    virtual std::string getInfo() const = 0;
    virtual std::string getType() const = 0;
};

// å…·ä½“æŠ½è±¡: åœ†å½¢
class Circle : public Shape {
private:
    double radius;
    std::string position;

public:
    Circle(double r, const std::string& pos, std::unique_ptr<Renderer> r)
        : Shape(std::move(r)), radius(r), position(pos) {}

    void draw() override {
        if (renderer) {
            renderer->render(getType(), getInfo());
        }
    }

    std::string getInfo() const override {
        return "Radius=" + std::to_string(radius) + ", Pos=" + position;
    }

    std::string getType() const override {
        return "Circle";
    }
};

// å…·ä½“æŠ½è±¡: çŸ©å½¢
class Rectangle : public Shape {
private:
    double width, height;
    std::string position;

public:
    Rectangle(double w, double h, const std::string& pos, std::unique_ptr<Renderer> r)
        : Shape(std::move(r)), width(w), height(h), position(pos) {}

    void draw() override {
        if (renderer) {
            renderer->render(getType(), getInfo());
        }
    }

    std::string getInfo() const override {
        return "W=" + std::to_string(width) + ", H=" + std::to_string(height) + ", Pos=" + position;
    }

    std::string getType() const override {
        return "Rectangle";
    }
};

// å®¢æˆ·ç«¯
int main() {
    std::cout << "=== æ¡¥æ¥æ¨¡å¼ç¤ºä¾‹: å›¾å½¢ + æ¸²æŸ“å™¨ ===\n\n";

    // åˆ›å»ºä¸åŒæ¸²æŸ“å™¨
    auto opengl = std::make_unique<OpenGLRenderer>();
    auto directx = std::make_unique<DirectXRenderer>();
    auto vulkan = std::make_unique<VulkanRenderer>();

    // åˆ›å»ºå›¾å½¢å¯¹è±¡, ç»‘å®šæ¸²æŸ“å™¨
    Circle circle(5.0, "(10,20)", std::make_unique<OpenGLRenderer>());
    Rectangle rect(10.0, 8.0, "(30,40)", std::make_unique<DirectXRenderer>());

    // ç»˜åˆ¶
    circle.draw();
    rect.draw();

    std::cout << "\n=== è¿è¡Œæ—¶åˆ‡æ¢æ¸²æŸ“å™¨ ===\n";
    circle.setRenderer(std::make_unique<VulkanRenderer>());
    circle.draw();

    rect.setRenderer(std::make_unique<OpenGLRenderer>());
    rect.draw();

    return 0;
}
```

âœ… è¿›é˜¶: å¸¦å·¥å‚çš„åŠ¨æ€æ¡¥æ¥

```
class RendererFactory {
public:
    static std::unique_ptr<Renderer> create(const std::string& type) {
        if (type == "opengl") return std::make_unique<OpenGLRenderer>();
        if (type == "directx") return std::make_unique<DirectXRenderer>();
        if (type == "vulkan") return std::make_unique<VulkanRenderer>();
        throw std::invalid_argument("Unknown renderer: " + type);
    }
};

// ä½¿ç”¨: 
auto circle = std::make_unique<Circle>(5.0, "(0,0)", RendererFactory::create("vulkan"));
```

## PlantUML

```
@startuml

' æŠ½è±¡å®ç°æ¥å£
interface Renderer {
    +render(shapeType: string, info: string) : void
}

' å…·ä½“å®ç°
class OpenGLRenderer {
    +render(shapeType: string, info: string) : void
}

class DirectXRenderer {
    +render(shapeType: string, info: string) : void
}

class VulkanRenderer {
    +render(shapeType: string, info: string) : void
}

' æŠ½è±¡å±‚
abstract class Shape {
    -renderer: unique_ptr<Renderer>
    +setRenderer(r: unique_ptr<Renderer>)
    +draw() : void {abstract}
    +getInfo() : string {abstract}
    +getType() : string {abstract}
}

' å…·ä½“æŠ½è±¡
class Circle {
    -radius: double
    -position: string
    +draw()
    +getInfo() : string
    +getType() : string
}

class Rectangle {
    -width: double
    -height: double
    -position: string
    +draw()
    +getInfo() : string
    +getType() : string
}

' å…³ç³»
Shape *-- Renderer : "has a (bridge)"

Renderer <|.. OpenGLRenderer
Renderer <|.. DirectXRenderer
Renderer <|.. VulkanRenderer

Shape <|-- Circle
Shape <|-- Rectangle

note right of Shape
    Holds a reference to
    Renderer (composition).
    This is the BRIDGE.
end note

note bottom of Renderer
    Defines the implementation
    interface. Can be extended
    independently of Shape.
end note

@enduml
```

![](./picture/8.BridgePattern.png)

# 11. ç»„åˆæ¨¡å¼

## ç®€ä»‹

> **ç»„åˆæ¨¡å¼(Composite Pattern)** æ˜¯ä¸€ç§**ç»“æ„å‹è®¾è®¡æ¨¡å¼**, å®ƒ**å°†å¯¹è±¡ç»„åˆæˆæ ‘å½¢ç»“æ„ä»¥è¡¨ç¤ºâ€œéƒ¨åˆ†-æ•´ä½“â€çš„å±‚æ¬¡ç»“æ„**, ä½¿å¾—å®¢æˆ·ç«¯å¯¹å•ä¸ªå¯¹è±¡å’Œç»„åˆå¯¹è±¡çš„ä½¿ç”¨å…·æœ‰ä¸€è‡´æ€§ã€‚

ğŸ¯ æ ¸å¿ƒæ€æƒ³: 

- **â€œéƒ¨åˆ†-æ•´ä½“â€ç»Ÿä¸€æ¥å£** â†’ å®¢æˆ·ç«¯æ— éœ€åŒºåˆ†å¶å­å’Œå®¹å™¨
- æ ‘å½¢ç»“æ„: èŠ‚ç‚¹å¯ä»¥æ˜¯å¶å­(Leaf)æˆ–å®¹å™¨(Composite)
- é€’å½’ç»„åˆ â†’ å®¹å™¨å¯åŒ…å«å¶å­æˆ–å…¶ä»–å®¹å™¨

> ğŸ’¡ ç»å…¸æ¯”å–»: 
>  **æ–‡ä»¶ç³»ç»Ÿ** â€”â€” æ–‡ä»¶(å¶å­)å’Œæ–‡ä»¶å¤¹(å®¹å™¨)éƒ½å¯è¢«â€œæ“ä½œâ€, å¦‚ `getSize()`ã€`display()`, å®¢æˆ·ç«¯æ— éœ€å…³å¿ƒæ˜¯æ–‡ä»¶è¿˜æ˜¯æ–‡ä»¶å¤¹ã€‚

------

 ğŸ§© ç»“æ„ç»„æˆ: 

| è§’è‰²        | è¯´æ˜                                                         |
| ----------- | ------------------------------------------------------------ |
| `Component` | æŠ½è±¡åŸºç±», å£°æ˜å¶å­å’Œå®¹å™¨çš„å…¬å…±æ¥å£(å¦‚ `display()`, `getSize()`) |
| `Leaf`      | å¶å­èŠ‚ç‚¹, å®ç° `Component` æ¥å£, æ— å­èŠ‚ç‚¹                    |
| `Composite` | å®¹å™¨èŠ‚ç‚¹, èšåˆå­èŠ‚ç‚¹(`Component*`), å®ç°ç›¸åŒæ¥å£, å†…éƒ¨é€’å½’è°ƒç”¨å­èŠ‚ç‚¹ |

------

 âœ… é€‚ç”¨åœºæ™¯

1. **ä½ æƒ³è¡¨ç¤ºå¯¹è±¡çš„â€œéƒ¨åˆ†-æ•´ä½“â€å±‚æ¬¡ç»“æ„(æ ‘å½¢ç»“æ„)**
2. **å¸Œæœ›å®¢æˆ·ç«¯å¿½ç•¥ç»„åˆå¯¹è±¡ä¸å•ä¸ªå¯¹è±¡çš„å·®å¼‚, ç»Ÿä¸€å¤„ç†**
3. **ç»“æ„åœ¨è¿è¡Œæ—¶åŠ¨æ€å˜åŒ–(å¦‚æ·»åŠ /åˆ é™¤å­èŠ‚ç‚¹)**
4. **éœ€è¦é€’å½’éå†æˆ–æ“ä½œæ•´ä¸ªç»“æ„**

ğŸ“Œ **å…¸å‹åº”ç”¨åœºæ™¯: **

- ğŸ“ **æ–‡ä»¶ç³»ç»Ÿ**: æ–‡ä»¶ + æ–‡ä»¶å¤¹
- ğŸ¨ **å›¾å½¢ç•Œé¢**: æ§ä»¶ + å®¹å™¨æ§ä»¶(å¦‚ GroupBoxã€Panel)
- ğŸ® **æ¸¸æˆå¯¹è±¡**: GameObject + å­å¯¹è±¡(å¦‚è§’è‰² + è£…å¤‡ + æŠ€èƒ½)
- ğŸ“Š **ç»„ç»‡æ¶æ„**: å‘˜å·¥ + éƒ¨é—¨(éƒ¨é—¨å¯åŒ…å«å­éƒ¨é—¨)
- ğŸ“œ **XML/HTML DOM æ ‘**: èŠ‚ç‚¹ + å­èŠ‚ç‚¹

------

 âœ… ä¼˜ç¼ºç‚¹

 âœ… ä¼˜ç‚¹: 

1. **å®šä¹‰äº†åŒ…å«ç®€å•å¯¹è±¡å’Œå¤åˆå¯¹è±¡çš„ç±»å±‚æ¬¡ç»“æ„** â†’ å®¢æˆ·ç«¯ç»Ÿä¸€å¤„ç†
2. **ç®€åŒ–å®¢æˆ·ç«¯ä»£ç ** â†’ æ— éœ€åˆ¤æ–­æ˜¯å¶å­è¿˜æ˜¯å®¹å™¨
3. **æ›´å®¹æ˜“å¢åŠ æ–°ç±»å‹çš„ç»„ä»¶** â†’ ç¬¦åˆå¼€é—­åŸåˆ™
4. **æ”¯æŒé€’å½’ç»“æ„** â†’ å¤©ç„¶é€‚åˆæ ‘å½¢æ•°æ®

 âŒ ç¼ºç‚¹: 

1. **è®¾è®¡æ›´å¤æ‚** â†’ éœ€è¦å®šä¹‰å…¬å…±æ¥å£, å¯èƒ½åŒ…å«å¶å­ä¸éœ€è¦çš„æ–¹æ³•
2. **ç±»å‹ç³»ç»Ÿé™åˆ¶** â†’ æŸäº›æ“ä½œåªå¯¹å®¹å™¨æœ‰æ„ä¹‰(å¦‚ `addChild`), å¶å­è°ƒç”¨ä¼šå‡ºé”™
3. **å¯èƒ½è¿åæ¥å£éš”ç¦»åŸåˆ™** â†’ å¶å­è¢«è¿«å®ç°æ— æ„ä¹‰çš„æ–¹æ³•

------

 âœ… æ³¨æ„äº‹é¡¹

 1. ğŸ”„ ä¸¤ç§è®¾è®¡é£æ ¼: 

| ç±»å‹                 | è¯´æ˜                                                       | ä¼˜ç‚¹                         | ç¼ºç‚¹                                         |
| -------------------- | ---------------------------------------------------------- | ---------------------------- | -------------------------------------------- |
| **é€æ˜æ–¹å¼(æ¨è)** | `Component` å£°æ˜æ‰€æœ‰æ–¹æ³•(åŒ…æ‹¬ `addChild`, `removeChild`) | å®¢æˆ·ç«¯å®Œå…¨ç»Ÿä¸€, æ— éœ€ç±»å‹åˆ¤æ–­ | å¶å­éœ€æŠ›å¼‚å¸¸æˆ–ç©ºå®ç°æ— æ„ä¹‰æ–¹æ³•               |
| **å®‰å…¨æ–¹å¼**         | åªåœ¨ `Composite` ä¸­å£°æ˜ç®¡ç†å­èŠ‚ç‚¹çš„æ–¹æ³•                    | ç±»å‹å®‰å…¨, ç¼–è¯‘æœŸæ£€æŸ¥         | å®¢æˆ·ç«¯éœ€ `dynamic_cast` åˆ¤æ–­ç±»å‹, ç ´åé€æ˜æ€§ |

> âœ… **ç°ä»£ C++ æ¨èâ€œé€æ˜æ–¹å¼â€ + è¿è¡Œæ—¶å¼‚å¸¸/ç©ºæ“ä½œ**, ä¿æŒæ¥å£ä¸€è‡´æ€§ã€‚

------

 2. âš ï¸ å¶å­èŠ‚ç‚¹å¯¹å®¹å™¨æ–¹æ³•çš„å¤„ç†: 

```
// é€æ˜æ–¹å¼ - Leaf å®ç°ä½†æŠ›å¼‚å¸¸
void addChild(std::unique_ptr<Component>) override {
    throw std::logic_error("Cannot add child to a leaf!");
}

// æˆ–è€…ç©ºå®ç°(é™é»˜å¤±è´¥, ä¸æ¨è)
void addChild(std::unique_ptr<Component>) override {}
```

> ğŸš¨ **å»ºè®®æŠ›å¼‚å¸¸**, é¿å…é™é»˜å¤±è´¥å¯¼è‡´è°ƒè¯•å›°éš¾ã€‚

------

 3. ğŸ§¹ å†…å­˜ç®¡ç†å»ºè®®: 

- ä½¿ç”¨ `std::unique_ptr<Component>` ç®¡ç†å­èŠ‚ç‚¹ç”Ÿå‘½å‘¨æœŸ
- Composite ææ„æ—¶è‡ªåŠ¨é‡Šæ”¾æ‰€æœ‰å­èŠ‚ç‚¹
- é¿å…è£¸æŒ‡é’ˆå’Œæ‰‹åŠ¨ `delete`

------

 4. ğŸ”„ é€’å½’æ“ä½œæ³¨æ„æ ˆæº¢å‡º

- è¶…æ·±æ ‘ç»“æ„å¯èƒ½å¯¼è‡´æ ˆæº¢å‡º â†’ å¯æ”¹ç”¨è¿­ä»£ + æ ˆæ¨¡æ‹Ÿ
- é€šå¸¸ä¸šåŠ¡åœºæ™¯æ·±åº¦æœ‰é™, æ— éœ€è¿‡åº¦æ‹…å¿ƒ

------

 5. ğŸ§© å¯é€‰: æä¾›è¿­ä»£å™¨æ”¯æŒ

```
class Composite : public Component {
    std::vector<std::unique_ptr<Component>> children;
public:
    using Iterator = decltype(children)::iterator;
    Iterator begin() { return children.begin(); }
    Iterator end() { return children.end(); }
};
```

ğŸ¯ **æ¨èè¯­: **

> **å½“ä½ éœ€è¦å¤„ç†æ ‘å½¢ç»“æ„(å¦‚æ–‡ä»¶ç³»ç»Ÿã€UI æ§ä»¶æ ‘ã€ç»„ç»‡æ¶æ„)æ—¶, ç»„åˆæ¨¡å¼æ˜¯ä½ æœ€ä½³é€‰æ‹©ã€‚å®ƒè®©å¤æ‚ç»“æ„çš„æ“ä½œå˜å¾—ç®€å•è€Œä¼˜é›…ï¼**

æŒæ¡ç»„åˆæ¨¡å¼, ä½ å°±èƒ½è½»æ¾é©¾é©­ä»»ä½•â€œéƒ¨åˆ†-æ•´ä½“â€å±‚æ¬¡ç»“æ„ï¼

## ä»£ç 

```
// Composite.h
#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <stdexcept>

// ============ æŠ½è±¡ç»„ä»¶ ============
class FileSystemComponent {
public:
    virtual ~FileSystemComponent() = default;

    // é€šç”¨æ“ä½œ(é€æ˜æ–¹å¼)
    virtual void display(const std::string& prefix = "") const = 0;
    virtual size_t getSize() const = 0;
    virtual std::string getName() const = 0;

    // å®¹å™¨æ“ä½œ(å¶å­éœ€å®ç°ä½†æŠ›å¼‚å¸¸)
    virtual void addChild(std::unique_ptr<FileSystemComponent> child) {
        throw std::logic_error("Cannot add child to a leaf node: " + getName());
    }

    virtual void removeChild(const std::string& name) {
        throw std::logic_error("Cannot remove child from a leaf node: " + getName());
    }

    virtual FileSystemComponent* getChild(const std::string& name) {
        throw std::logic_error("Leaf node has no children: " + getName());
    }
};

// ============ å¶å­èŠ‚ç‚¹: æ–‡ä»¶ ============
class File : public FileSystemComponent {
private:
    std::string name;
    size_t size;

public:
    File(const std::string& n, size_t s) : name(n), size(s) {}

    void display(const std::string& prefix = "") const override {
        std::cout << prefix << "ğŸ“„ " << name << " (" << size << " KB)" << std::endl;
    }

    size_t getSize() const override {
        return size;
    }

    std::string getName() const override {
        return name;
    }
};

// ============ å®¹å™¨èŠ‚ç‚¹: ç›®å½• ============
class Directory : public FileSystemComponent {
private:
    std::string name;
    std::vector<std::unique_ptr<FileSystemComponent>> children;

public:
    Directory(const std::string& n) : name(n) {}

    void display(const std::string& prefix = "") const override {
        std::cout << prefix << "ğŸ“ " << name << "/" << std::endl;
        for (const auto& child : children) {
            child->display(prefix + "  "); // é€’å½’æ˜¾ç¤º
        }
    }

    size_t getSize() const override {
        size_t total = 0;
        for (const auto& child : children) {
            total += child->getSize(); // é€’å½’è®¡ç®—
        }
        return total;
    }

    std::string getName() const override {
        return name;
    }

    // å®¹å™¨ç‰¹æœ‰æ“ä½œ
    void addChild(std::unique_ptr<FileSystemComponent> child) override {
        children.push_back(std::move(child));
    }

    void removeChild(const std::string& name) override {
        auto it = std::remove_if(children.begin(), children.end(),
            [&name](const std::unique_ptr<FileSystemComponent>& child) {
                return child->getName() == name;
            });
        if (it != children.end()) {
            children.erase(it, children.end());
        } else {
            throw std::runtime_error("Child not found: " + name);
        }
    }

    FileSystemComponent* getChild(const std::string& name) override {
        for (auto& child : children) {
            if (child->getName() == name) {
                return child.get();
            }
        }
        return nullptr;
    }
};

// ============ å®¢æˆ·ç«¯ä½¿ç”¨ ============
#include "Composite.h"

int main() {
    std::cout << "=== ç»„åˆæ¨¡å¼: æ–‡ä»¶ç³»ç»Ÿæ¨¡æ‹Ÿ ===\n\n";

    // åˆ›å»ºæ ¹ç›®å½•
    auto root = std::make_unique<Directory>("root");

    // æ·»åŠ æ–‡ä»¶
    root->addChild(std::make_unique<File>("readme.txt", 2));
    root->addChild(std::make_unique<File>("config.json", 1));

    // åˆ›å»ºå­ç›®å½•
    auto docs = std::make_unique<Directory>("documents");
    docs->addChild(std::make_unique<File>("report.pdf", 5000));
    docs->addChild(std::make_unique<File>("notes.txt", 100));

    auto pics = std::make_unique<Directory>("pictures");
    pics->addChild(std::make_unique<File>("photo1.jpg", 3000));
    pics->addChild(std::make_unique<File>("photo2.png", 2500));

    // å°†å­ç›®å½•åŠ å…¥æ ¹ç›®å½•
    root->addChild(std::move(docs));
    root->addChild(std::move(pics));

    // æ˜¾ç¤ºæ•´ä¸ªæ–‡ä»¶æ ‘
    root->display();

    // è®¡ç®—æ€»å¤§å°
    std::cout << "\nTotal size: " << root->getSize() << " KB" << std::endl;

    // å°è¯•å¯¹å¶å­è°ƒç”¨å®¹å™¨æ–¹æ³•(åº”æŠ›å¼‚å¸¸)
    std::cout << "\n=== æµ‹è¯•å¶å­èŠ‚ç‚¹å¼‚å¸¸ ===\n";
    auto file = std::make_unique<File>("test.txt", 10);
    try {
        file->addChild(std::make_unique<File>("invalid.txt", 0));
    } catch (const std::exception& e) {
        std::cout << "âœ… Caught expected exception: " << e.what() << std::endl;
    }

    return 0;
}
```



## PlantUML

```
@startuml

' æŠ½è±¡ç»„ä»¶(é€æ˜æ–¹å¼)
abstract class FileSystemComponent {
    +display(prefix: string) : void {abstract}
    +getSize() : size_t {abstract}
    +getName() : string {abstract}
    +addChild(child: unique_ptr<FileSystemComponent>) : void
    +removeChild(name: string) : void
    +getChild(name: string) : FileSystemComponent*
}

' å¶å­èŠ‚ç‚¹
class File {
    -name: string
    -size: size_t
    +display(prefix: string) : void
    +getSize() : size_t
    +getName() : string
    +addChild(...) {throws}
    +removeChild(...) {throws}
    +getChild(...) {throws}
}

' å®¹å™¨èŠ‚ç‚¹
class Directory {
    -name: string
    -children: vector<unique_ptr<FileSystemComponent>>
    +display(prefix: string) : void
    +getSize() : size_t
    +getName() : string
    +addChild(child: unique_ptr<FileSystemComponent>) : void
    +removeChild(name: string) : void
    +getChild(name: string) : FileSystemComponent*
}

' å…³ç³»
FileSystemComponent <|-- File
FileSystemComponent <|-- Directory

note right of FileSystemComponent
    Transparent Composite:
    Declares all operations,
    Leaf throws on container methods.
end note

note bottom of Directory
    Manages child components
    recursively. Uses composition.
end note

@enduml
```

![](./picture/9.CompositePattern.png)

# 12.è£…é¥°å™¨æ¨¡å¼

## ç®€ä»‹

> **è£…é¥°å™¨æ¨¡å¼(Decorator Pattern)** æ˜¯ä¸€ç§**ç»“æ„å‹è®¾è®¡æ¨¡å¼**, å®ƒ**åŠ¨æ€åœ°ç»™ä¸€ä¸ªå¯¹è±¡æ·»åŠ ä¸€äº›é¢å¤–çš„èŒè´£(åŠŸèƒ½)**, å°±å¢åŠ åŠŸèƒ½æ¥è¯´, è£…é¥°å™¨æ¨¡å¼ç›¸æ¯”ç”Ÿæˆå­ç±»æ›´ä¸ºçµæ´»ã€‚

 ğŸ¯ æ ¸å¿ƒæ€æƒ³: 

- **â€œå¥—å¨ƒå¼â€å¢å¼ºåŠŸèƒ½** â€”â€” ä¸€å±‚å¥—ä¸€å±‚, æ¯å±‚æ·»åŠ æ–°åŠŸèƒ½
- **ç»§æ‰¿æ˜¯é™æ€çš„, è£…é¥°æ˜¯åŠ¨æ€çš„**
- **ç¬¦åˆå¼€é—­åŸåˆ™** â€”â€” å¯¹æ‰©å±•å¼€æ”¾, å¯¹ä¿®æ”¹å…³é—­

> ğŸ’¡ ç»å…¸æ¯”å–»: 
>  **å’–å•¡ + é…æ–™** â€”â€” åŸºç¡€å’–å•¡(Espresso)å¯åŠ¨æ€æ·»åŠ â€œç‰›å¥¶â€ã€â€œç³–â€ã€â€œå·§å…‹åŠ›â€ç­‰è£…é¥°, æ¯åŠ ä¸€å±‚, ä»·æ ¼å’Œæè¿°éƒ½å˜åŒ–, ä½†ä»ç„¶æ˜¯â€œä¸€æ¯å’–å•¡â€ã€‚

------

 ğŸ§© ç»“æ„ç»„æˆ: 

| è§’è‰²                | è¯´æ˜                                                        |
| ------------------- | ----------------------------------------------------------- |
| `Component`         | æŠ½è±¡ç»„ä»¶, å®šä¹‰å¯¹è±¡æ¥å£(å¦‚ `cost()`, `getDescription()`)   |
| `ConcreteComponent` | å…·ä½“ç»„ä»¶, è¢«è£…é¥°çš„åŸå§‹å¯¹è±¡                                  |
| `Decorator`         | æŠ½è±¡è£…é¥°å™¨, ç»§æ‰¿ `Component`, æŒæœ‰ä¸€ä¸ª `Component*`(ç»„åˆ) |
| `ConcreteDecorator` | å…·ä½“è£…é¥°å™¨, å®ç°é¢å¤–åŠŸèƒ½, è°ƒç”¨è¢«è£…é¥°å¯¹è±¡çš„æ–¹æ³•å¹¶å¢å¼º        |

------

 âœ… é€‚ç”¨åœºæ™¯

1. **éœ€è¦åœ¨è¿è¡Œæ—¶åŠ¨æ€ã€é€æ˜åœ°ç»™å¯¹è±¡æ·»åŠ èŒè´£**
2. **æ‰©å±•åŠŸèƒ½çš„æ–¹æ¡ˆæœ‰å¾ˆå¤š, ç”¨ç»§æ‰¿ä¼šå¯¼è‡´å­ç±»çˆ†ç‚¸**
3. **èŒè´£å¯ä»¥â€œå åŠ â€, ä¸”é¡ºåºå¯èƒ½å½±å“ç»“æœ(å¦‚åŠ å¯†+å‹ç¼© vs å‹ç¼©+åŠ å¯†)**
4. **ä¸å¸Œæœ›ä¿®æ”¹åŸå§‹ç±»ä»£ç (å¦‚ç¬¬ä¸‰æ–¹åº“)**

ğŸ“Œ **å…¸å‹åº”ç”¨åœºæ™¯: **

- â˜• **å’–å•¡/é¥®æ–™ç³»ç»Ÿ**: åŸºç¡€é¥®å“ + å„ç§é…æ–™(ç³–ã€å¥¶ã€æ‘©å¡)
- ğŸ’¾ **I/O æµå¢å¼º**: `std::ostream` â†’ æ·»åŠ å‹ç¼©ã€åŠ å¯†ã€æ—¥å¿—åŠŸèƒ½
- ğŸ® **æ¸¸æˆé“å…·ç³»ç»Ÿ**: åŸºç¡€æ­¦å™¨ + é™„é­”(ç«ç„°ã€å†°éœœã€å¸è¡€)
- ğŸ§± **GUI æ§ä»¶è£…é¥°**: åŸºç¡€æŒ‰é’® + è¾¹æ¡†è£…é¥°ã€æ»šåŠ¨è£…é¥°ã€é€æ˜åº¦è£…é¥°
- ğŸ“¦ **ç½‘ç»œè¯·æ±‚ä¸­é—´ä»¶**: åŸºç¡€è¯·æ±‚ + æ—¥å¿—ã€é‡è¯•ã€ç¼“å­˜ã€è®¤è¯è£…é¥°å™¨

------

 âœ… ä¼˜ç¼ºç‚¹

 âœ… ä¼˜ç‚¹: 

1. **æ¯”ç»§æ‰¿æ›´çµæ´»** â†’ è¿è¡Œæ—¶åŠ¨æ€ç»„åˆåŠŸèƒ½
2. **é¿å…ç±»çˆ†ç‚¸** â†’ N ä¸ªåŠŸèƒ½ç»„åˆ = N ä¸ªè£…é¥°å™¨ç±», è€Œä¸æ˜¯ 2^N ä¸ªå­ç±»
3. **ç¬¦åˆå¼€é—­åŸåˆ™** â†’ æ–°å¢åŠŸèƒ½ä¸ä¿®æ”¹åŸæœ‰ä»£ç 
4. **å¯å åŠ ã€å¯åµŒå¥—** â†’ åŠŸèƒ½è‡ªç”±ç»„åˆ
5. **å•ä¸€èŒè´£åŸåˆ™** â†’ æ¯ä¸ªè£…é¥°å™¨åªè´Ÿè´£ä¸€ä¸ªå¢å¼ºåŠŸèƒ½

 âŒ ç¼ºç‚¹: 

1. **äº§ç”Ÿå¾ˆå¤šå°å¯¹è±¡** â†’ è°ƒè¯•æ—¶è°ƒç”¨æ ˆè¾ƒæ·±
2. **è¿‡åº¦ä½¿ç”¨ä¼šè®©ç³»ç»Ÿå¤æ‚** â†’ â€œå¥—å¨ƒåœ°ç‹±â€
3. **åˆ é™¤è£…é¥°å™¨è¾ƒå›°éš¾** â†’ é€šå¸¸éœ€é‡å»ºå¯¹è±¡é“¾
4. **é…ç½®å¤æ‚å¯¹è±¡æ—¶ä»£ç å†—é•¿** â†’ å¯ç»“åˆ Builder æ¨¡å¼ä¼˜åŒ–

------

 âœ… æ³¨æ„äº‹é¡¹

 1. ğŸ”„ è£…é¥°å™¨å¿…é¡»å®ç°ä¸ç»„ä»¶ç›¸åŒçš„æ¥å£

```
class Decorator : public Component { ... };
```

> âœ… å®¢æˆ·ç«¯æ— éœ€çŸ¥é“æ˜¯å¦è¢«è£…é¥° â†’ é€æ˜æ€§

------

 2. âš ï¸ è£…é¥°å™¨æŒæœ‰ç»„ä»¶çš„æŒ‡é’ˆ/å¼•ç”¨(ç»„åˆ)

```
class MilkDecorator : public Beverage {
    std::unique_ptr<Beverage> beverage; // å…³é”®: ç»„åˆè€Œéç»§æ‰¿åŠŸèƒ½
public:
    MilkDecorator(std::unique_ptr<Beverage> b) : beverage(std::move(b)) {}
    double cost() override { return beverage->cost() + 0.5; }
};
```

3. ğŸš« è£…é¥°å™¨ â‰  ç»§æ‰¿/é€‚é…å™¨/ä»£ç†

4. âœ… æ¨èä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆç®¡ç†ç»„ä»¶ç”Ÿå‘½å‘¨æœŸ

5. âœ… è£…é¥°é¡ºåºå¯èƒ½å½±å“ç»“æœ

```
auto coffee = std::make_unique<Espresso>();
auto withMilk = std::make_unique<MilkDecorator>(std::move(coffee));
auto withSugar = std::make_unique<SugarDecorator>(std::move(withMilk));

// vs

auto coffee2 = std::make_unique<Espresso>();
auto withSugar2 = std::make_unique<SugarDecorator>(std::move(coffee2));
auto withMilk2 = std::make_unique<MilkDecorator>(std::move(withSugar2));
```

ğŸ¯ **æ¨èè¯­: **

> **è£…é¥°å™¨æ¨¡å¼æ˜¯è§£å†³â€œåŠŸèƒ½åŠ¨æ€ç»„åˆâ€é—®é¢˜çš„ä¼˜é›…æ–¹æ¡ˆã€‚å½“ä½ åŒå€¦äº†ç»§æ‰¿å¯¼è‡´çš„ç±»çˆ†ç‚¸, è£…é¥°å™¨æ¨¡å¼å°±æ˜¯ä½ çš„æ•‘æ˜Ÿï¼**

æŒæ¡è£…é¥°å™¨æ¨¡å¼, ä½ å°±èƒ½è®¾è®¡å‡ºé«˜åº¦çµæ´»ã€å¯æ‰©å±•ã€å¯ç»„åˆçš„ç³»ç»Ÿï¼

## ä»£ç 

```
// Decorator.h
#include <iostream>
#include <string>
#include <memory>

// ============ æŠ½è±¡ç»„ä»¶ ============
class Beverage {
public:
    virtual ~Beverage() = default;
    virtual double cost() const = 0;
    virtual std::string getDescription() const = 0;
};

// ============ å…·ä½“ç»„ä»¶ ============
class Espresso : public Beverage {
public:
    double cost() const override {
        return 1.99;
    }

    std::string getDescription() const override {
        return "Espresso";
    }
};

class HouseBlend : public Beverage {
public:
    double cost() const override {
        return 0.89;
    }

    std::string getDescription() const override {
        return "House Blend Coffee";
    }
};

// ============ æŠ½è±¡è£…é¥°å™¨ ============
class CondimentDecorator : public Beverage {
protected:
    std::unique_ptr<Beverage> beverage;

public:
    CondimentDecorator(std::unique_ptr<Beverage> b) : beverage(std::move(b)) {}
    virtual ~CondimentDecorator() = default;
};

// ============ å…·ä½“è£…é¥°å™¨ ============
class Milk : public CondimentDecorator {
public:
    Milk(std::unique_ptr<Beverage> b) : CondimentDecorator(std::move(b)) {}

    double cost() const override {
        return beverage->cost() + 0.10;
    }

    std::string getDescription() const override {
        return beverage->getDescription() + ", Milk";
    }
};

class Mocha : public CondimentDecorator {
public:
    Mocha(std::unique_ptr<Beverage> b) : CondimentDecorator(std::move(b)) {}

    double cost() const override {
        return beverage->cost() + 0.20;
    }

    std::string getDescription() const override {
        return beverage->getDescription() + ", Mocha";
    }
};

class Whip : public CondimentDecorator {
public:
    Whip(std::unique_ptr<Beverage> b) : CondimentDecorator(std::move(b)) {}

    double cost() const override {
        return beverage->cost() + 0.15;
    }

    std::string getDescription() const override {
        return beverage->getDescription() + ", Whip";
    }
};

// ============ å®¢æˆ·ç«¯ ============
#include "Decorator.h"

void printBeverage(const Beverage& b) {
    std::cout << b.getDescription() << " $" << b.cost() << std::endl;
}

int main() {
    std::cout << "=== è£…é¥°å™¨æ¨¡å¼: å’–å•¡è®¢å•ç³»ç»Ÿ ===\n\n";

    // åŸºç¡€å’–å•¡
    auto espresso = std::make_unique<Espresso>();
    printBeverage(*espresso);

    // è£…é¥°: åŠ æ‘©å¡ + æ‰“å¥¶æ³¡
    auto espressoWithMochaWhip = std::make_unique<Whip>(
        std::make_unique<Mocha>(std::move(espresso))
    );
    printBeverage(*espressoWithMochaWhip);

    // å¦ä¸€æ¯: æ··åˆå’–å•¡ + ç‰›å¥¶ + æ‘©å¡ + ç‰›å¥¶
    auto houseBlend = std::make_unique<HouseBlend>();
    auto fancyCoffee = std::make_unique<Milk>(
        std::make_unique<Mocha>(
            std::make_unique<Milk>(std::move(houseBlend))
        )
    );
    printBeverage(*fancyCoffee);

    return 0;
}
```

## PlantUML

```
@startuml

' æŠ½è±¡ç»„ä»¶
abstract class Beverage {
    +cost() : double {abstract}
    +getDescription() : string {abstract}
}

' å…·ä½“ç»„ä»¶
class Espresso {
    +cost() : double
    +getDescription() : string
}

class HouseBlend {
    +cost() : double
    +getDescription() : string
}

' æŠ½è±¡è£…é¥°å™¨
abstract class CondimentDecorator {
    -beverage: unique_ptr<Beverage>
    +cost() : double {abstract}
    +getDescription() : string {abstract}
}

' å…·ä½“è£…é¥°å™¨
class Milk {
    +cost() : double
    +getDescription() : string
}

class Mocha {
    +cost() : double
    +getDescription() : string
}

class Whip {
    +cost() : double
    +getDescription() : string
}

' å…³ç³»
Beverage <|-- Espresso
Beverage <|-- HouseBlend
Beverage <|-- CondimentDecorator

CondimentDecorator <|-- Milk
CondimentDecorator <|-- Mocha
CondimentDecorator <|-- Whip

CondimentDecorator *-- Beverage : "wraps"

note right of CondimentDecorator
    Holds a reference to
    a Beverage (composition).
    This is the DECORATOR core.
end note

note bottom of Milk
    Adds milk cost and
    description to any Beverage.
end note

@enduml
```

![](./picture/10.DecoratorPattern.png)





# 13. å¤–è§‚æ¨¡å¼

## ç®€ä»‹

> **å¤–è§‚æ¨¡å¼(Facade Pattern)** æ˜¯ä¸€ç§**ç»“æ„å‹è®¾è®¡æ¨¡å¼**, å®ƒ**ä¸ºå­ç³»ç»Ÿä¸­çš„ä¸€ç»„æ¥å£æä¾›ä¸€ä¸ªä¸€è‡´çš„ã€ç®€åŒ–çš„é«˜å±‚æ¥å£**, ä½¿å¾—å­ç³»ç»Ÿæ›´å®¹æ˜“ä½¿ç”¨ã€‚

 ğŸ¯ æ ¸å¿ƒæ€æƒ³: 

- **â€œå°è£…å¤æ‚æ€§, æä¾›ç®€å•é—¨é¢â€**
- **å®¢æˆ·ç«¯æ— éœ€äº†è§£å­ç³»ç»Ÿå†…éƒ¨ç»“æ„**
- **é™ä½è€¦åˆ, ç»Ÿä¸€å…¥å£**

> ğŸ’¡ ç»å…¸æ¯”å–»: 
>  **é…’åº—å‰å°** â€”â€” å®¢äººåªéœ€å‘Šè¯‰å‰å°â€œæˆ‘è¦å…¥ä½â€, å‰å°ä¼šåè°ƒå®¢æˆ¿éƒ¨ã€æ¸…æ´éƒ¨ã€å®‰ä¿éƒ¨ç­‰å¤šä¸ªéƒ¨é—¨å®Œæˆå…¥ä½æµç¨‹, å®¢äººæ— éœ€ä¸æ¯ä¸ªéƒ¨é—¨æ‰“äº¤é“ã€‚

------

 ğŸ§© ç»“æ„ç»„æˆ: 

| è§’è‰²                | è¯´æ˜                                                         |
| ------------------- | ------------------------------------------------------------ |
| `Subsystem Classes` | å­ç³»ç»Ÿä¸­çš„å¤šä¸ªå¤æ‚ç±»(å¦‚ `Light`, `Thermostat`, `Security`) |
| `Facade`            | å¤–è§‚ç±», å°è£…å­ç³»ç»Ÿè°ƒç”¨, æä¾›ç®€åŒ–æ¥å£(å¦‚ `turnOnHome()`, `turnOffHome()`) |
| `Client`            | å®¢æˆ·ç«¯, åªä¸ `Facade` äº¤äº’, ä¸ç›´æ¥è®¿é—®å­ç³»ç»Ÿ                 |

> ğŸ“Œ **å…³é”®ç‚¹: **
>  Facade **ä¸å°è£…æ–°åŠŸèƒ½**, åªæ˜¯**ç»„åˆå’Œç®€åŒ–å·²æœ‰åŠŸèƒ½çš„è°ƒç”¨æµç¨‹**ã€‚

------

 âœ… é€‚ç”¨åœºæ™¯

1. **å­ç³»ç»Ÿå¤æ‚, æ¥å£ä¼—å¤š, ä½¿ç”¨å›°éš¾**
2. **å®¢æˆ·ç«¯ä¸å­ç³»ç»Ÿä¹‹é—´å­˜åœ¨è¿‡å¤šç›´æ¥ä¾èµ–**
3. **éœ€è¦ä¸ºå­ç³»ç»Ÿæä¾›ä¸€ä¸ªç»Ÿä¸€ã€ç®€åŒ–çš„è®¿é—®å…¥å£**
4. **åˆ†å±‚æ¶æ„ä¸­, ä¸Šå±‚æ¨¡å—éœ€è¦ç®€åŒ–å¯¹ä¸‹å±‚æ¨¡å—çš„è°ƒç”¨**

ğŸ“Œ **å…¸å‹åº”ç”¨åœºæ™¯: **

- ğŸ  **æ™ºèƒ½å®¶å±…ç³»ç»Ÿ**: ä¸€é”®â€œå›å®¶æ¨¡å¼â€ â†’ å¼€ç¯ + è°ƒæ¸© + è§£é™¤è­¦æŠ¥
- ğŸ› ï¸ **ç¼–è¯‘å™¨å­ç³»ç»Ÿ**: `compile()` â†’ è¯æ³•åˆ†æ + è¯­æ³•åˆ†æ + ä»£ç ç”Ÿæˆ
- ğŸ“¦ **API å°è£…åº“**: å°è£…å¤æ‚çš„ç¬¬ä¸‰æ–¹åº“(å¦‚ OpenGLã€FFmpeg)æä¾›ç®€å•æ¥å£
- ğŸ¦ **é“¶è¡Œç³»ç»Ÿ**: `applyLoan()` â†’ ä¿¡ç”¨æ£€æŸ¥ + é£æ§å®¡æ ¸ + åˆåŒç”Ÿæˆ + æ”¾æ¬¾
- ğŸ® **æ¸¸æˆå¼•æ“å¯åŠ¨**: `startGame()` â†’ åŠ è½½èµ„æº + åˆå§‹åŒ–éŸ³é¢‘ + å¯åŠ¨ç‰©ç†å¼•æ“ + æ˜¾ç¤ºä¸»èœå•

------

 âœ… ä¼˜ç¼ºç‚¹

 âœ… ä¼˜ç‚¹: 

1. **ç®€åŒ–å®¢æˆ·ç«¯ä½¿ç”¨** â†’ éšè—å­ç³»ç»Ÿå¤æ‚æ€§
2. **é™ä½è€¦åˆåº¦** â†’ å®¢æˆ·ç«¯åªä¾èµ–å¤–è§‚, ä¸ä¾èµ–å…·ä½“å­ç³»ç»Ÿ
3. **æé«˜å¯ç»´æŠ¤æ€§** â†’ å­ç³»ç»Ÿå˜åŒ–ä¸å½±å“å®¢æˆ·ç«¯(åªè¦å¤–è§‚æ¥å£ä¸å˜)
4. **ç¬¦åˆè¿ªç±³ç‰¹æ³•åˆ™(æœ€å°‘çŸ¥è¯†åŸåˆ™)** â†’ å®¢æˆ·ç«¯åªéœ€çŸ¥é“å¤–è§‚
5. **ä¾¿äºåˆ†å±‚è®¾è®¡** â†’ æ¯å±‚å¯æä¾›è‡ªå·±çš„å¤–è§‚

 âŒ ç¼ºç‚¹: 

1. **ä¸ç¬¦åˆå¼€é—­åŸåˆ™** â†’ æ–°å¢å­ç³»ç»ŸåŠŸèƒ½å¯èƒ½éœ€è¦ä¿®æ”¹å¤–è§‚ç±»
2. **å¯èƒ½æˆä¸ºâ€œä¸Šå¸ç±»â€** â†’ å¦‚æœå¤–è§‚æ‰¿æ‹…è¿‡å¤šèŒè´£, ä¼šå˜å¾—è‡ƒè‚¿
3. **çµæ´»æ€§å—é™** â†’ å®¢æˆ·ç«¯æ— æ³•ç²¾ç»†æ§åˆ¶å­ç³»ç»Ÿ(é™¤éæä¾›â€œé€ƒç”Ÿèˆ±å£â€)

------

 âœ… æ³¨æ„äº‹é¡¹

 1. ğŸ”„ å¤–è§‚ â‰  å°è£…æ‰€æœ‰åŠŸèƒ½

> å¤–è§‚åº”æä¾›**å¸¸ç”¨ã€é«˜å±‚**æ“ä½œ, ä¸æ˜¯æ›¿ä»£å­ç³»ç»Ÿã€‚
>  åº”å…è®¸å®¢æˆ·ç«¯åœ¨å¿…è¦æ—¶**ç»•è¿‡å¤–è§‚**ç›´æ¥è®¿é—®å­ç³»ç»Ÿ(â€œé€ƒç”Ÿèˆ±å£â€è®¾è®¡)ã€‚


```
class HomeFacade {
    LightSystem light;
    ACSystem ac;
public:
    void turnOnHome() { ... } // ç®€åŒ–æ¥å£

    // é€ƒç”Ÿèˆ±å£: å…è®¸ç›´æ¥è®¿é—®å­ç³»ç»Ÿ
    LightSystem& getLightSystem() { return light; }
};
```

------

 2. ğŸš« å¤–è§‚ â‰  é€‚é…å™¨

| æ¨¡å¼   | ç›®çš„                     |
| ------ | ------------------------ |
| å¤–è§‚   | **ç®€åŒ–æ¥å£, å°è£…å¤æ‚æ€§** |
| é€‚é…å™¨ | **è½¬æ¢æ¥å£, å…¼å®¹ä¸åŒ¹é…** |

> ğŸ’¡ **å¤–è§‚ = â€œç®€åŒ–æ“ä½œâ€, é€‚é…å™¨ = â€œæ¥å£ç¿»è¯‘â€**

------

 3. ğŸš« å¤–è§‚ â‰  ä¸­ä»‹è€…

| æ¨¡å¼   | ç›®çš„                     | äº¤äº’æ–¹å¼                     |
| ------ | ------------------------ | ---------------------------- |
| å¤–è§‚   | **å°è£…å­ç³»ç»Ÿ, å•å‘è°ƒç”¨** | Client â†’ Facade â†’ Subsystems |
| ä¸­ä»‹è€… | **åè°ƒå¯¹è±¡é—´äº¤äº’**       | Objects â†” Mediator â†” Objects |

> ğŸ’¡ **å¤–è§‚æ˜¯â€œé—¨é¢â€, ä¸­ä»‹è€…æ˜¯â€œè°ƒåº¦ä¸­å¿ƒâ€**

------

 4. âœ… å¤–è§‚ç±»åº”å°½é‡ä¿æŒæ— çŠ¶æ€æˆ–è½»çŠ¶æ€

> é¿å…å¤–è§‚ç±»æ‰¿æ‹…ä¸šåŠ¡é€»è¾‘æˆ–çŠ¶æ€ç®¡ç†, å®ƒåªæ˜¯â€œåè°ƒè€…â€ã€‚

------

 5. âœ… å¯è®¾è®¡å¤šå±‚å¤–è§‚(Layered Facade)

```
class LowLevelFacade { ... };     // å°è£…ç¡¬ä»¶é©±åŠ¨
class MidLevelFacade { ... };     // å°è£…ä¸šåŠ¡é€»è¾‘
class HighLevelFacade { ... };    // å°è£…ç”¨æˆ·æ“ä½œ
```

------

 6. âœ… å¤–è§‚ç±»å¯è¢«å¤šä¸ªå®¢æˆ·ç«¯å…±äº«

> é€šå¸¸è®¾è®¡ä¸ºæ— çŠ¶æ€æˆ–ä½¿ç”¨ä¾èµ–æ³¨å…¥, å¯å®‰å…¨å…±äº«ã€‚

 âœ… ä¸€å¥è¯æ€»ç»“: 

> **â€œä½ åªç®¡è¯´â€˜æˆ‘è¦å›å®¶â€™, å‰©ä¸‹çš„äº¤ç»™æˆ‘æ¥åè°ƒï¼â€**

ğŸ¯ **æ¨èè¯­: **

> **å¤–è§‚æ¨¡å¼æ˜¯é™ä½ç³»ç»Ÿå¤æ‚åº¦çš„åˆ©å™¨ã€‚æ— è®ºæ˜¯å°è£…ç¬¬ä¸‰æ–¹åº“ã€ç®€åŒ–å†…éƒ¨æ¨¡å—è°ƒç”¨, è¿˜æ˜¯æä¾›ç”¨æˆ·å‹å¥½æ¥å£, å¤–è§‚æ¨¡å¼éƒ½èƒ½è®©ä½ çš„ä»£ç æ›´æ¸…æ™°ã€æ›´æ˜“ç”¨ï¼**

æŒæ¡å¤–è§‚æ¨¡å¼, ä½ å°±æŒæ¡äº†â€œåŒ–ç¹ä¸ºç®€â€çš„æ¶æ„è‰ºæœ¯ï¼

## ä»£ç 

```
// Facade.h
#include <iostream>
#include <string>

// ============ å­ç³»ç»Ÿç±» ============
class LightSystem {
public:
    void turnOn() { std::cout << "ğŸ’¡ Lights ON\n"; }
    void turnOff() { std::cout << "ğŸ’¡ Lights OFF\n"; }
    void setBrightness(int level) { std::cout << "ğŸ”† Brightness set to " << level << "%\n"; }
};

class ACSystem {
public:
    void turnOn() { std::cout << "â„ï¸ AC ON\n"; }
    void turnOff() { std::cout << "â„ï¸ AC OFF\n"; }
    void setTemperature(int temp) { std::cout << "ğŸŒ¡ï¸ Temperature set to " << temp << "Â°C\n"; }
};

class SecuritySystem {
public:
    void arm() { std::cout << "ğŸ”’ Security System ARMED\n"; }
    void disarm() { std::cout << "ğŸ”“ Security System DISARMED\n"; }
    void triggerAlarm() { std::cout << "ğŸš¨ ALARM TRIGGERED!\n"; }
};

class EntertainmentSystem {
public:
    void turnOnTV() { std::cout << "ğŸ“º TV ON\n"; }
    void turnOffTV() { std::cout << "ğŸ“º TV OFF\n"; }
    void playMusic() { std::cout << "ğŸµ Playing relaxing music...\n"; }
};

// ============ å¤–è§‚ç±» ============
class HomeFacade {
private:
    LightSystem light;
    ACSystem ac;
    SecuritySystem security;
    EntertainmentSystem entertainment;

public:
    // ä¸€é”®å›å®¶æ¨¡å¼
    void activateHomeMode() {
        std::cout << "\n=== ğŸ  Activating HOME Mode ===\n";
        security.disarm();
        light.turnOn();
        light.setBrightness(80);
        ac.turnOn();
        ac.setTemperature(24);
        entertainment.turnOnTV();
        entertainment.playMusic();
    }

    // ä¸€é”®ç¦»å®¶æ¨¡å¼
    void activateAwayMode() {
        std::cout << "\n=== ğŸšª Activating AWAY Mode ===\n";
        light.turnOff();
        ac.turnOff();
        entertainment.turnOffTV();
        security.arm();
    }

    // ä¸€é”®ç¡çœ æ¨¡å¼
    void activateSleepMode() {
        std::cout << "\n=== ğŸ˜´ Activating SLEEP Mode ===\n";
        light.setBrightness(10);
        ac.setTemperature(26);
        entertainment.turnOffTV();
    }

    // é€ƒç”Ÿèˆ±å£: å…è®¸ç›´æ¥è®¿é—®å­ç³»ç»Ÿ
    LightSystem& getLightSystem() { return light; }
    ACSystem& getACSystem() { return ac; }
};

// ============ å®¢æˆ·ç«¯ä½¿ç”¨ ============
#include "Facade.h"

int main() {
    std::cout << "=== å¤–è§‚æ¨¡å¼: æ™ºèƒ½å®¶å±…ç³»ç»Ÿ ===\n";

    HomeFacade home;

    // ç”¨æˆ·åªéœ€æ“ä½œå¤–è§‚, æ— éœ€äº†è§£å­ç³»ç»Ÿç»†èŠ‚
    home.activateHomeMode();
    home.activateSleepMode();
    home.activateAwayMode();

    // ç‰¹æ®Šéœ€æ±‚: ç›´æ¥è°ƒç”¨å­ç³»ç»Ÿ(é€ƒç”Ÿèˆ±å£)
    std::cout << "\n=== ç‰¹æ®Šæ“ä½œ: ç›´æ¥è°ƒå…‰ ===\n";
    home.getLightSystem().setBrightness(50);

    return 0;
}
```

è¾“å‡º

```
=== å¤–è§‚æ¨¡å¼: æ™ºèƒ½å®¶å±…ç³»ç»Ÿ ===

=== ğŸ  Activating HOME Mode ===
ğŸ”“ Security System DISARMED
ğŸ’¡ Lights ON
ğŸ”† Brightness set to 80%
â„ï¸ AC ON
ğŸŒ¡ï¸ Temperature set to 24Â°C
ğŸ“º TV ON
ğŸµ Playing relaxing music...

=== ğŸ˜´ Activating SLEEP Mode ===
ğŸ”† Brightness set to 10%
ğŸŒ¡ï¸ Temperature set to 26Â°C
ğŸ“º TV OFF

=== ğŸšª Activating AWAY Mode ===
ğŸ’¡ Lights OFF
â„ï¸ AC OFF
ğŸ“º TV OFF
ğŸ”’ Security System ARMED

=== ç‰¹æ®Šæ“ä½œ: ç›´æ¥è°ƒå…‰ ===
ğŸ”† Brightness set to 50%
```



## PlantUML

```
@startuml

' å­ç³»ç»Ÿç±»
class LightSystem {
    +turnOn()
    +turnOff()
    +setBrightness(level)
}

class ACSystem {
    +turnOn()
    +turnOff()
    +setTemperature(temp)
}

class SecuritySystem {
    +arm()
    +disarm()
    +triggerAlarm()
}

class EntertainmentSystem {
    +turnOnTV()
    +turnOffTV()
    +playMusic()
}

' å¤–è§‚ç±»
class HomeFacade {
    -light: LightSystem
    -ac: ACSystem
    -security: SecuritySystem
    -entertainment: EntertainmentSystem
    +activateHomeMode()
    +activateAwayMode()
    +activateSleepMode()
    +getLightSystem() : LightSystem&
}

' å®¢æˆ·ç«¯
class Client {
    +main()
}

' å…³ç³»
Client --> HomeFacade : uses
HomeFacade --> LightSystem : uses
HomeFacade --> ACSystem : uses
HomeFacade --> SecuritySystem : uses
HomeFacade --> EntertainmentSystem : uses

note right of HomeFacade
    Provides simplified interface
    to complex subsystem.
    Follows "Facade Pattern".
end note

note bottom of Client
    Only interacts with Facade,
    not with subsystem classes.
end note

@enduml
```

![](./picture/11.FacadePattern.png)


# 14. äº«å…ƒæ¨¡å¼

## ç®€ä»‹

> **äº«å…ƒæ¨¡å¼(Flyweight Pattern)** æ˜¯ä¸€ç§**ç»“æ„å‹è®¾è®¡æ¨¡å¼**, å®ƒ**é€šè¿‡å…±äº«æŠ€æœ¯, æœ‰æ•ˆåœ°æ”¯æŒå¤§é‡ç»†ç²’åº¦å¯¹è±¡çš„å¤ç”¨**, ä»è€Œ**å‡å°‘å†…å­˜å ç”¨å’Œå¯¹è±¡åˆ›å»ºå¼€é”€**ã€‚

 ğŸ¯ æ ¸å¿ƒæ€æƒ³: 

- **â€œå…±äº«ç›¸åŒçŠ¶æ€çš„å¯¹è±¡, é¿å…é‡å¤åˆ›å»ºâ€**
- **åŒºåˆ†å†…éƒ¨çŠ¶æ€(å¯å…±äº«)å’Œå¤–éƒ¨çŠ¶æ€(ä¸å¯å…±äº«)**
- **ä½¿ç”¨â€œäº«å…ƒå·¥å‚â€ç®¡ç†å…±äº«å¯¹è±¡æ± **

> ğŸ’¡ ç»å…¸æ¯”å–»: 
>  **æ–‡å­—å¤„ç†å™¨ä¸­çš„å­—ç¬¦å¯¹è±¡** â€”â€” å­—æ¯ `'A'` åœ¨æ–‡æ¡£ä¸­å‡ºç° 1000 æ¬¡, ä½†å†…å­˜ä¸­åªéœ€åˆ›å»ºä¸€ä¸ª `'A'` å¯¹è±¡, é€šè¿‡å¤–éƒ¨çŠ¶æ€(ä½ç½®ã€é¢œè‰²ã€å­—ä½“å¤§å°)æ¥åŒºåˆ†æ¯æ¬¡æ¸²æŸ“ã€‚

------

 ğŸ§© ç»“æ„ç»„æˆ: 

| è§’è‰²                | è¯´æ˜                                                         |
| ------------------- | ------------------------------------------------------------ |
| `Flyweight`         | æŠ½è±¡äº«å…ƒç±», å®šä¹‰æ¥å£(å¦‚ `render(x, y)`), æ¥å—å¤–éƒ¨çŠ¶æ€å‚æ•°  |
| `ConcreteFlyweight` | å…·ä½“äº«å…ƒç±», å­˜å‚¨**å†…éƒ¨çŠ¶æ€**(å¦‚å­—ç¬¦ã€å›¾ç‰‡ID), å®ç°å…±äº«é€»è¾‘ |
| `FlyweightFactory`  | äº«å…ƒå·¥å‚, åˆ›å»ºå¹¶ç®¡ç†äº«å…ƒå¯¹è±¡æ± (é€šå¸¸ç”¨ `std::map` æˆ– `std::unordered_map`) |
| `Client`            | å®¢æˆ·ç«¯, ç»´æŠ¤**å¤–éƒ¨çŠ¶æ€**(å¦‚ä½ç½®ã€é¢œè‰²), è°ƒç”¨äº«å…ƒå¯¹è±¡       |

> ğŸ“Œ **å…³é”®æ¦‚å¿µ: **
>
> - **å†…éƒ¨çŠ¶æ€(Intrinsic State)**: å­˜å‚¨åœ¨äº«å…ƒå¯¹è±¡å†…éƒ¨, å¯å…±äº«(å¦‚å­—ç¬¦ã€çº¹ç†ID)
> - **å¤–éƒ¨çŠ¶æ€(Extrinsic State)**: ç”±å®¢æˆ·ç«¯ä¼ å…¥, ä¸å¯å…±äº«(å¦‚åæ ‡ã€é¢œè‰²ã€æ—‹è½¬è§’åº¦)

------

 âœ… é€‚ç”¨åœºæ™¯

1. **ç¨‹åºä¸­å­˜åœ¨å¤§é‡ç›¸ä¼¼å¯¹è±¡, é€ æˆå†…å­˜å‹åŠ›**
2. **å¯¹è±¡å¤§éƒ¨åˆ†çŠ¶æ€å¯ä»¥å¤–éƒ¨åŒ–(æå–ä¸ºå‚æ•°)**
3. **å¯¹è±¡å¯è¢«ç¼“å­˜å’Œå¤ç”¨**
4. **æ€§èƒ½æˆ–å†…å­˜æ˜¯å…³é”®ç“¶é¢ˆ**

ğŸ“Œ **å…¸å‹åº”ç”¨åœºæ™¯: **

- ğŸ“ **æ–‡å­—ç¼–è¾‘å™¨/æ’ç‰ˆç³»ç»Ÿ**: å…±äº«å­—ç¬¦å¯¹è±¡(å¦‚ 1000 ä¸ª 'A' â†’ 1 ä¸ªå¯¹è±¡)

- ğŸ®

   

  æ¸¸æˆå¼€å‘

  : 

  - å­å¼¹ã€ç²’å­ã€æ•Œäººç±»å‹(ç›¸åŒç±»å‹çš„å¯¹è±¡å…±äº«çº¹ç†ã€æ¨¡å‹)
  - åœ°å›¾ç“¦ç‰‡ç³»ç»Ÿ(ç›¸åŒåœ°å½¢å…±äº«è´´å›¾)

- ğŸ–¼ï¸ **å›¾å½¢ç•Œé¢ç³»ç»Ÿ**: å›¾æ ‡ã€æŒ‰é’®æ ·å¼å…±äº«

- ğŸ§¬ **ç”Ÿç‰©ä¿¡æ¯å­¦**: å…±äº« DNA ç¢±åŸºå¯¹è±¡(A, T, C, G)

- ğŸ“Š **æ•°æ®å¯è§†åŒ–**: å…±äº«æŸ±çŠ¶å›¾ã€é¥¼å›¾çš„æ ·å¼å¯¹è±¡

------

 âœ… ä¼˜ç¼ºç‚¹

 âœ… ä¼˜ç‚¹: 

1. **æå¤§å‡å°‘å†…å­˜å ç”¨** â†’ å…±äº«å¯¹è±¡, é¿å…é‡å¤åˆ›å»º
2. **æå‡æ€§èƒ½** â†’ å‡å°‘å¯¹è±¡åˆ›å»º/é”€æ¯å¼€é”€
3. **å¤–éƒ¨çŠ¶æ€ä¸å†…éƒ¨çŠ¶æ€åˆ†ç¦»** â†’ èŒè´£æ¸…æ™°
4. **é€‚åˆå¤§è§„æ¨¡å¯¹è±¡ç³»ç»Ÿ** â†’ å¦‚æ¸¸æˆã€å›¾å½¢ã€æ–‡æœ¬å¤„ç†

 âŒ ç¼ºç‚¹: 

1. **ä»£ç å¤æ‚åº¦å¢åŠ ** â†’ éœ€ç®¡ç†å¯¹è±¡æ± ã€åŒºåˆ†å†…å¤–çŠ¶æ€
2. **å¤–éƒ¨çŠ¶æ€éœ€å®¢æˆ·ç«¯ç»´æŠ¤** â†’ å¢åŠ å®¢æˆ·ç«¯è´Ÿæ‹…
3. **çº¿ç¨‹å®‰å…¨é—®é¢˜** â†’ å¤šçº¿ç¨‹è®¿é—®å·¥å‚éœ€åŠ é”(C++ ä¸­)
4. **è°ƒè¯•å›°éš¾** â†’ å¯¹è±¡è¢«å¤šä¸ªå®¢æˆ·ç«¯å…±äº«, çŠ¶æ€è¿½è¸ªå¤æ‚

------

 âœ… æ³¨æ„äº‹é¡¹

 1. ğŸ”„ å¿…é¡»åŒºåˆ†å†…éƒ¨çŠ¶æ€å’Œå¤–éƒ¨çŠ¶æ€


```
class CharacterFlyweight {
    char symbol; // å†…éƒ¨çŠ¶æ€: å¯å…±äº«(å¦‚ 'A')
public:
    void render(int x, int y, Color color); // å¤–éƒ¨çŠ¶æ€: ä½ç½®ã€é¢œè‰²ç”±å®¢æˆ·ç«¯ä¼ å…¥
};
```

> âœ… å†…éƒ¨çŠ¶æ€ = å¯¹è±¡æœ¬è´¨å±æ€§(ä¸å˜æˆ–æå°‘å˜)
>  âœ… å¤–éƒ¨çŠ¶æ€ = ä¸Šä¸‹æ–‡ç›¸å…³å±æ€§(æ¯æ¬¡è°ƒç”¨å¯èƒ½ä¸åŒ)

------

 2. âš ï¸ äº«å…ƒå¯¹è±¡åº”å°½é‡**ä¸å¯å˜(Immutable)**

> ä¸€æ—¦åˆ›å»º, å†…éƒ¨çŠ¶æ€ä¸åº”è¢«ä¿®æ”¹, ç¡®ä¿çº¿ç¨‹å®‰å…¨å’Œå…±äº«å®‰å…¨ã€‚


```
class TreeType { // ä¸å¯å˜äº«å…ƒ
    std::string name;
    Color color;
    Texture texture;
public:
    TreeType(std::string n, Color c, Texture t) : name(n), color(c), texture(t) {}
    void draw(int x, int y) const { ... } // const æ–¹æ³•
};
```

------

 3. ğŸš« äº«å…ƒ â‰  å•ä¾‹

| æ¨¡å¼ | ç›®çš„                 |
| ---- | -------------------- |
| äº«å…ƒ | **å…±äº«å¤§é‡ç›¸ä¼¼å¯¹è±¡** |
| å•ä¾‹ | **ç¡®ä¿å…¨å±€å”¯ä¸€å®ä¾‹** |

> ğŸ’¡ äº«å…ƒæ± ä¸­å¯èƒ½æœ‰å¤šä¸ªä¸åŒäº«å…ƒå¯¹è±¡(å¦‚ 'A', 'B', 'C' å„ä¸€ä¸ª), å•ä¾‹åªæœ‰ä¸€ä¸ªå¯¹è±¡ã€‚

------

 4. âœ… ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆæˆ–å¼•ç”¨ç®¡ç†äº«å…ƒå¯¹è±¡


```
std::shared_ptr<Flyweight> getFlyweight(const std::string& key);
```

> é¿å…è£¸æŒ‡é’ˆ, é˜²æ­¢å†…å­˜æ³„æ¼ã€‚å·¥å‚åº”ç®¡ç†ç”Ÿå‘½å‘¨æœŸã€‚

------

 5. âš ï¸ çº¿ç¨‹å®‰å…¨(C++ å¤šçº¿ç¨‹ç¯å¢ƒ)


```
class FlyweightFactory {
    std::unordered_map<std::string, std::shared_ptr<Flyweight>> pool;
    mutable std::mutex mtx; // ä¿æŠ¤ pool

public:
    std::shared_ptr<Flyweight> getFlyweight(const std::string& key) {
        std::lock_guard<std::mutex> lock(mtx);
        if (pool.find(key) == pool.end()) {
            pool[key] = std::make_shared<ConcreteFlyweight>(key);
        }
        return pool[key];
    }
};
```

------

 6. âœ… äº«å…ƒå·¥å‚åº”æä¾›æ¸…é™¤æœºåˆ¶(å¯é€‰)

> é˜²æ­¢å†…å­˜æ³„æ¼, å¯å®šæœŸæ¸…ç†æœªä½¿ç”¨å¯¹è±¡(å¼•ç”¨è®¡æ•° or LRU ç­–ç•¥)ã€‚

------

 7. âœ… é€‚ç”¨äºâ€œå¤§é‡å¯¹è±¡ + é‡å¤çŠ¶æ€â€åœºæ™¯

> å¦‚æœå¯¹è±¡æ•°é‡å°‘æˆ–çŠ¶æ€å‡ ä¹ä¸é‡å¤, äº«å…ƒæ¨¡å¼åè€Œå¢åŠ å¤æ‚åº¦ã€‚




## ä»£ç 

```
// Flyweight.h
#include <iostream>
#include <string>
#include <unordered_map>
#include <memory>
#include <mutex>

// ============ å¤–éƒ¨çŠ¶æ€: ç”±å®¢æˆ·ç«¯ç»´æŠ¤ ============
struct Position {
    int x, y;
    Position(int x, int y) : x(x), y(y) {}
};

enum class Color { RED, GREEN, BLUE, BLACK };

// ============ æŠ½è±¡äº«å…ƒ ============
class CharacterFlyweight {
public:
    virtual ~CharacterFlyweight() = default;
    virtual void render(const Position& pos, Color color) const = 0;
    virtual char getSymbol() const = 0;
};

// ============ å…·ä½“äº«å…ƒ ============
class ConcreteCharacter : public CharacterFlyweight {
    char symbol; // å†…éƒ¨çŠ¶æ€: å¯å…±äº«

public:
    ConcreteCharacter(char c) : symbol(c) {
        std::cout << "Creating character: '" << symbol << "'\n";
    }

    void render(const Position& pos, Color color) const override {
        std::string colorStr = (color == Color::RED) ? "RED" :
                              (color == Color::GREEN) ? "GREEN" :
                              (color == Color::BLUE) ? "BLUE" : "BLACK";
        std::cout << "Rendering '" << symbol << "' at (" << pos.x << "," << pos.y
                  << ") in " << colorStr << " color.\n";
    }

    char getSymbol() const override { return symbol; }
};

// ============ äº«å…ƒå·¥å‚ ============
class CharacterFactory {
private:
    std::unordered_map<char, std::shared_ptr<CharacterFlyweight>> pool;
    mutable std::mutex mtx;

public:
    std::shared_ptr<CharacterFlyweight> getCharacter(char c) {
        std::lock_guard<std::mutex> lock(mtx);
        if (pool.find(c) == pool.end()) {
            pool[c] = std::make_shared<ConcreteCharacter>(c);
        }
        return pool[c];
    }

    size_t getPoolSize() const {
        std::lock_guard<std::mutex> lock(mtx);
        return pool.size();
    }
};

// ============ å®¢æˆ·ç«¯ ============
#include "Flyweight.h"

int main() {
    std::cout << "=== äº«å…ƒæ¨¡å¼: å­—ç¬¦æ¸²æŸ“ç³»ç»Ÿ ===\n\n";

    CharacterFactory factory;

    // æ¨¡æ‹Ÿæ¸²æŸ“æ–‡æ¡£ä¸­çš„å­—ç¬¦
    std::string document = "AAABBBCCCDDDAAABBB";

    std::cout << "Rendering document: " << document << "\n\n";

    int x = 0, y = 0;
    for (char c : document) {
        auto character = factory.getCharacter(c);
        character->render(Position(x, y), Color::BLACK);
        x += 10; // æ°´å¹³ç§»åŠ¨
        if (x > 50) { x = 0; y += 20; } // æ¢è¡Œ
    }

    std::cout << "\n=== ç»Ÿè®¡ ===\n";
    std::cout << "æ–‡æ¡£é•¿åº¦: " << document.length() << " å­—ç¬¦\n";
    std::cout << "äº«å…ƒæ± å¤§å°: " << factory.getPoolSize() << " ä¸ªå¯¹è±¡\n";
    std::cout << "èŠ‚çœå¯¹è±¡: " << document.length() - factory.getPoolSize() << " ä¸ª\n";

    return 0;
}
```



## PlantUML

```
@startuml

' æŠ½è±¡äº«å…ƒ
abstract class Flyweight {
    +render(extrinsicState) {abstract}
}

' å…·ä½“äº«å…ƒ
class ConcreteFlyweight {
    -intrinsicState
    +render(extrinsicState)
}

' äº«å…ƒå·¥å‚
class FlyweightFactory {
    -pool: Map<Key, Flyweight>
    +getFlyweight(key): Flyweight
}

' å®¢æˆ·ç«¯
class Client {
    -extrinsicState
    +operation()
}

' å…³ç³»
Flyweight <|-- ConcreteFlyweight
FlyweightFactory --> Flyweight : manages pool
Client --> FlyweightFactory : requests
Client --> Flyweight : uses

note right of Flyweight
    Defines interface for
    rendering with extrinsic state.
end note

note right of ConcreteFlyweight
    Stores intrinsic state.
    Immutable recommended.
end note

note bottom of FlyweightFactory
    Creates and manages
    shared flyweight objects.
    Thread-safe in C++.
end note

note top of Client
    Maintains extrinsic state
    and coordinates rendering.
end note

@enduml
```

![](./picture/12.Flyweight Pattern.png)


# 15. ä»£ç†æ¨¡å¼

## ç®€ä»‹

> **ä»£ç†æ¨¡å¼(Proxy Pattern)** æ˜¯ä¸€ç§**ç»“æ„å‹è®¾è®¡æ¨¡å¼**, å®ƒ**ä¸ºå¦ä¸€ä¸ªå¯¹è±¡æä¾›ä¸€ä¸ªæ›¿èº«æˆ–å ä½ç¬¦, ä»¥æ§åˆ¶å¯¹è¿™ä¸ªå¯¹è±¡çš„è®¿é—®**ã€‚

 ğŸ¯ æ ¸å¿ƒæ€æƒ³: 

- **â€œä»£æ›¿çœŸå®å¯¹è±¡, æ§åˆ¶è®¿é—®â€**
- **ä»£ç†ä¸çœŸå®å¯¹è±¡å®ç°ç›¸åŒæ¥å£**
- **å®¢æˆ·ç«¯æ— æ„ŸçŸ¥, ä»¥ä¸ºåœ¨æ“ä½œçœŸå®å¯¹è±¡**

> ğŸ’¡ ç»å…¸æ¯”å–»: 
>  **æ¸¸æˆä»£ç»ƒ** â€”â€” ä½ (å®¢æˆ·ç«¯)ä»¥ä¸ºè‡ªå·±åœ¨æ‰“æ¸¸æˆ, å…¶å®æ˜¯ä»£ç»ƒ(ä»£ç†)åœ¨æ“ä½œä½ çš„è´¦å·(çœŸå®å¯¹è±¡), ä»–å¯ä»¥æ§åˆ¶ä½ ä»€ä¹ˆæ—¶å€™èƒ½ç©ã€èƒ½ä¸èƒ½ç©ã€ç©ä¹‹å‰è¦ä¸è¦äº¤é’±ã€‚

------

 ğŸ§© ç»“æ„ç»„æˆ: 

| è§’è‰²          | è¯´æ˜                                                         |
| ------------- | ------------------------------------------------------------ |
| `Subject`     | æŠ½è±¡ä¸»é¢˜æ¥å£(å¦‚ `IImage`, `IService`)                      |
| `RealSubject` | çœŸå®å¯¹è±¡(å¦‚ `RealImage`, `RealService`), æ‰§è¡Œå®é™…ä¸šåŠ¡é€»è¾‘  |
| `Proxy`       | ä»£ç†å¯¹è±¡, æŒæœ‰å¯¹ `RealSubject` çš„å¼•ç”¨, æ§åˆ¶è®¿é—®(å¦‚å»¶è¿ŸåŠ è½½ã€æƒé™æ£€æŸ¥) |
| `Client`      | å®¢æˆ·ç«¯, é€šè¿‡ `Proxy` è®¿é—® `RealSubject`, æ— æ„ŸçŸ¥              |

> ğŸ“Œ **å…³é”®ç‚¹: **
>  ä»£ç†ä¸çœŸå®å¯¹è±¡**å®ç°åŒä¸€æ¥å£**, å®¢æˆ·ç«¯**æ— éœ€ä¿®æ”¹ä»£ç **å³å¯åˆ‡æ¢ã€‚

------

 âœ… é€‚ç”¨åœºæ™¯

1. **å»¶è¿Ÿåˆå§‹åŒ–(Lazy Initialization)** â€”â€” å¯¹è±¡åˆ›å»ºå¼€é”€å¤§, é¦–æ¬¡ä½¿ç”¨æ—¶æ‰åˆ›å»º
2. **è®¿é—®æ§åˆ¶(Access Control)** â€”â€” æƒé™æ£€æŸ¥ã€ç™»å½•éªŒè¯
3. **è¿œç¨‹ä»£ç†(Remote Proxy)** â€”â€” æœ¬åœ°ä»£è¡¨è¿œç¨‹å¯¹è±¡(å¦‚ RPCã€Web Service)
4. **æ—¥å¿—è®°å½• / ç›‘æ§** â€”â€” è°ƒç”¨å‰åè®°å½•æ—¥å¿—ã€ç»Ÿè®¡è€—æ—¶
5. **ç¼“å­˜ä»£ç†(Caching Proxy)** â€”â€” ç¼“å­˜ç»“æœ, é¿å…é‡å¤è®¡ç®—
6. **æ™ºèƒ½æŒ‡é’ˆ / å¼•ç”¨è®¡æ•°** â€”â€” æ§åˆ¶å¯¹è±¡ç”Ÿå‘½å‘¨æœŸ

ğŸ“Œ **å…¸å‹åº”ç”¨åœºæ™¯: **

- ğŸ–¼ï¸ **å›¾åƒæ‡’åŠ è½½**: å›¾ç‰‡é¦–æ¬¡æ˜¾ç¤ºæ—¶æ‰ä»ç£ç›˜/ç½‘ç»œåŠ è½½
- ğŸ” **æƒé™æ§åˆ¶**: è®¿é—®æ•æ„Ÿæ“ä½œå‰æ£€æŸ¥ç”¨æˆ·æƒé™
- ğŸŒ **è¿œç¨‹æœåŠ¡è°ƒç”¨**: æœ¬åœ°ä»£ç†å°è£…ç½‘ç»œé€šä¿¡
- â±ï¸ **æ€§èƒ½ç›‘æ§**: è®°å½•æ–¹æ³•æ‰§è¡Œæ—¶é—´
- ğŸ’¾ **ç¼“å­˜æ•°æ®åº“æŸ¥è¯¢ç»“æœ**
- ğŸ§µ **çº¿ç¨‹å®‰å…¨ä»£ç†**: ä¸ºéçº¿ç¨‹å®‰å…¨å¯¹è±¡æ·»åŠ é”

------

 âœ… ä¼˜ç¼ºç‚¹

 âœ… ä¼˜ç‚¹: 

1. **æ§åˆ¶è®¿é—®** â†’ å¯æ·»åŠ æƒé™ã€æ—¥å¿—ã€ç¼“å­˜ç­‰é€»è¾‘
2. **å»¶è¿ŸåŠ è½½** â†’ èŠ‚çœå†…å­˜å’Œåˆå§‹åŒ–æ—¶é—´
3. **å®¢æˆ·ç«¯é€æ˜** â†’ æ— éœ€ä¿®æ”¹å®¢æˆ·ç«¯ä»£ç 
4. **èŒè´£åˆ†ç¦»** â†’ ä»£ç†è´Ÿè´£â€œæ§åˆ¶â€, çœŸå®å¯¹è±¡è´Ÿè´£â€œä¸šåŠ¡â€
5. **æ‰©å±•æ€§å¼º** â†’ å¯å åŠ å¤šä¸ªä»£ç†(å¦‚: ç¼“å­˜ä»£ç† + æƒé™ä»£ç†)

 âŒ ç¼ºç‚¹: 

1. **å¢åŠ ç³»ç»Ÿå¤æ‚åº¦** â†’ å¤šä¸€å±‚ä»£ç†ç±»
2. **å¯èƒ½é™ä½æ€§èƒ½** â†’ ä»£ç†å±‚å¢åŠ è°ƒç”¨å¼€é”€(é€šå¸¸å¯å¿½ç•¥)
3. **è°ƒè¯•å›°éš¾** â†’ è°ƒç”¨é“¾å˜é•¿, éœ€è·Ÿè¸ªä»£ç†é€»è¾‘
4. **ç”Ÿå‘½å‘¨æœŸç®¡ç†å¤æ‚** â†’ ä»£ç†å’ŒçœŸå®å¯¹è±¡çš„ææ„é¡ºåºéœ€æ³¨æ„(C++)

------

 âœ… æ³¨æ„äº‹é¡¹

 1. ğŸ”„ ä»£ç† â‰  è£…é¥°å™¨

| æ¨¡å¼   | ç›®çš„                                 |
| ------ | ------------------------------------ |
| ä»£ç†   | **æ§åˆ¶è®¿é—®**(ä½•æ—¶ã€èƒ½å¦ã€å¦‚ä½•è®¿é—®) |
| è£…é¥°å™¨ | **åŠ¨æ€æ·»åŠ åŠŸèƒ½**(å¢å¼ºè¡Œä¸º)         |

> ğŸ’¡ **ä»£ç† = â€œé—¨å«â€, è£…é¥°å™¨ = â€œåŒ…è£…çº¸â€**


```
// ä»£ç†: æ§åˆ¶æ˜¯å¦å…è®¸è®¿é—®
if (user.hasPermission()) realObject->operation();

// è£…é¥°å™¨: å¢å¼ºåŠŸèƒ½
decorated->operation(); // å†…éƒ¨è°ƒç”¨ component->operation() + é¢å¤–é€»è¾‘
```

------

 2. ğŸ”„ ä»£ç† â‰  é€‚é…å™¨

| æ¨¡å¼   | ç›®çš„                   |
| ------ | ---------------------- |
| ä»£ç†   | **ç›¸åŒæ¥å£, æ§åˆ¶è®¿é—®** |
| é€‚é…å™¨ | **è½¬æ¢æ¥å£, å…¼å®¹è°ƒç”¨** |

> ğŸ’¡ ä»£ç†ä¸æ”¹å˜æ¥å£, é€‚é…å™¨æ”¹å˜æ¥å£ã€‚

------

 3. âš ï¸ ä»£ç†åº”æŒæœ‰çœŸå®å¯¹è±¡çš„**æ™ºèƒ½æŒ‡é’ˆæˆ–å¼•ç”¨**


```
class ImageProxy : public IImage {
    std::unique_ptr<RealImage> realImage; // æˆ– shared_ptr
public:
    void display() override {
        if (!realImage) {
            realImage = std::make_unique<RealImage>("huge_image.jpg");
        }
        realImage->display();
    }
};
```

> âœ… é¿å…è£¸æŒ‡é’ˆ, é˜²æ­¢å†…å­˜æ³„æ¼
>  âœ… `unique_ptr`: ä»£ç†ç‹¬å æ‰€æœ‰æƒ
>  âœ… `shared_ptr`: å…è®¸å¤šä¸ªä»£ç†å…±äº«çœŸå®å¯¹è±¡

------

 4. âœ… ä»£ç†å¯ç»„åˆ(ä»£ç†é“¾)


```
// æƒé™ä»£ç† â†’ ç¼“å­˜ä»£ç† â†’ çœŸå®å¯¹è±¡
auto service = std::make_shared<RealService>();
auto cached = std::make_shared<CachingProxy>(service);
auto secured = std::make_shared<SecurityProxy>(cached);
```

------

 5. âš ï¸ æ³¨æ„ææ„é¡ºåº(C++)

> è‹¥ä»£ç†æŒæœ‰çœŸå®å¯¹è±¡, ç¡®ä¿ä»£ç†ææ„æ—¶çœŸå®å¯¹è±¡ä»æœ‰æ•ˆ(é€šå¸¸ä»£ç†è´Ÿè´£é”€æ¯)ã€‚

------

 6. âœ… é€‚ç”¨äºâ€œè®¿é—®æ§åˆ¶â€ã€â€œå»¶è¿ŸåŠ è½½â€ã€â€œè¿œç¨‹è°ƒç”¨â€ç­‰åœºæ™¯

> å¦‚æœåªæ˜¯ç®€å•å°è£…, è€ƒè™‘æ˜¯å¦è¿‡åº¦è®¾è®¡ã€‚



 âœ… ä¸€å¥è¯æ€»ç»“: 

> **ä»£ç†æ¨¡å¼ = â€œå¯¹è±¡çš„æ›¿èº«â€, åœ¨ä¸æ”¹å˜æ¥å£çš„å‰æä¸‹, æ§åˆ¶å¯¹çœŸå®å¯¹è±¡çš„è®¿é—®ã€‚**

> **â€œä½ æƒ³æ“ä½œçœŸå®å¯¹è±¡ï¼Ÿå…ˆè¿‡æˆ‘è¿™å…³ï¼â€**

ğŸ¯ **æ¨èè¯­: **

> **ä»£ç†æ¨¡å¼æ˜¯æ„å»ºå®‰å…¨ã€é«˜æ•ˆã€å¯æ‰©å±•ç³»ç»Ÿçš„å…³é”®æ¨¡å¼ã€‚æ— è®ºæ˜¯å»¶è¿ŸåŠ è½½ã€æƒé™æ§åˆ¶è¿˜æ˜¯è¿œç¨‹è°ƒç”¨, ä»£ç†æ¨¡å¼éƒ½èƒ½è®©ä½ åœ¨ä¸ä¾µå…¥ä¸šåŠ¡ä»£ç çš„å‰æä¸‹, ä¼˜é›…åœ°æ·»åŠ æ§åˆ¶é€»è¾‘ï¼**

æŒæ¡ä»£ç†æ¨¡å¼, ä½ å°±æŒæ¡äº†â€œæ§åˆ¶çš„è‰ºæœ¯â€ï¼

## ä»£ç 

è¿œç¨‹æœåŠ¡ä»£ç†(æ¨¡æ‹Ÿ RPC)

```
#include <iostream>
#include <string>
#include <thread>
#include <chrono>

// æŠ½è±¡è¿œç¨‹æœåŠ¡
class IRemoteService {
public:
    virtual ~IRemoteService() = default;
    virtual std::string getData() = 0;
};

// çœŸå®è¿œç¨‹æœåŠ¡(æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ)
class RealRemoteService : public IRemoteService {
public:
    std::string getData() override {
        std::cout << "ğŸŒ Connecting to remote server...\n";
        std::this_thread::sleep_for(std::chrono::seconds(2)); // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
        return "Data from remote server";
    }
};

// è¿œç¨‹ä»£ç†(æœ¬åœ°å­˜æ ¹)
class RemoteProxy : public IRemoteService {
    mutable std::unique_ptr<RealRemoteService> realService;
    mutable std::string cachedData;
    mutable bool isCached = false;

public:
    std::string getData() override {
        if (!realService) {
            realService = std::make_unique<RealRemoteService>();
        }

        if (!isCached) {
            std::cout << "ğŸ“¡ Proxy: Fetching data for the first time...\n";
            cachedData = realService->getData();
            isCached = true;
        } else {
            std::cout << "ğŸ’¾ Proxy: Returning cached data...\n";
        }

        return cachedData;
    }
};

int main() {
    std::cout << "=== ä»£ç†æ¨¡å¼: è¿œç¨‹æœåŠ¡ä»£ç† ===\n\n";

    RemoteProxy proxy;

    // ç¬¬ä¸€æ¬¡è°ƒç”¨: çœŸå®ç½‘ç»œè¯·æ±‚
    std::cout << "First call: " << proxy.getData() << "\n\n";

    // ç¬¬äºŒæ¬¡è°ƒç”¨: è¿”å›ç¼“å­˜
    std::cout << "Second call: " << proxy.getData() << "\n";

    return 0;
}
```

## PlantUML

```
@startuml

' è®¾ç½®ä¸»é¢˜å’Œæ ·å¼(å¯é€‰)
skinparam class {
    BackgroundColor White
    BorderColor #333333
    FontSize 14
}
skinparam interface {
    BackgroundColor LightBlue
    BorderColor #3333CC
    FontStyle italic
}

' å®šä¹‰æŠ½è±¡æ¥å£
interface IRemoteService {
    +getData() : string
}

' å®šä¹‰å…·ä½“å®ç°ç±»
class RealRemoteService {
    +getData() : string
}

' å®šä¹‰ä»£ç†ç±»
class RemoteProxy {
    -realService : unique_ptr<RealRemoteService>
    -cachedData : string
    -isCached : bool
    +getData() : string
}

' ç»§æ‰¿å…³ç³»
RealRemoteService --|> IRemoteService
RemoteProxy --|> IRemoteService

' ä»£ç†ç±»èšåˆçœŸå®æœåŠ¡(ç»„åˆå…³ç³», ç”¨è±å½¢å®çº¿)
RemoteProxy o-- "1" RealRemoteService : creates and holds

' æ·»åŠ æ³¨é‡Šè¯´æ˜
note right of RemoteProxy
  ä»£ç†æ¨¡å¼å®ç°: 
  - é¦–æ¬¡è°ƒç”¨åˆ›å»ºçœŸå®æœåŠ¡
  - ç¼“å­˜ç»“æœä»¥æé«˜åç»­æ€§èƒ½
  - å¯¹å®¢æˆ·ç«¯é€æ˜
end note

note right of RealRemoteService
  çœŸå®è¿œç¨‹æœåŠ¡: 
  - æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
  - å®é™…æ•°æ®æ¥æº
end note

@enduml
```

![](./picture/13.ProxyPattern.png)



# ğŸ”„è¡Œä¸ºå‹æ¨¡å¼

# 16. ç­–ç•¥æ¨¡å¼

## ç®€ä»‹

> **ç­–ç•¥æ¨¡å¼(Strategy Pattern)** æ˜¯ä¸€ç§**è¡Œä¸ºå‹è®¾è®¡æ¨¡å¼**, å®ƒ**å®šä¹‰ä¸€ç³»åˆ—ç®—æ³•æˆ–è¡Œä¸º, å¹¶å°†æ¯ä¸ªç®—æ³•å°è£…èµ·æ¥, ä½¿å®ƒä»¬å¯ä»¥äº’æ¢, è®©ç®—æ³•çš„å˜åŒ–ç‹¬ç«‹äºä½¿ç”¨å®ƒçš„å®¢æˆ·ç«¯**ã€‚

 ğŸ¯ æ ¸å¿ƒæ€æƒ³: 

- **â€œå°è£…å˜åŒ–, äº’æ¢ç®—æ³•â€**
- **å°†ç®—æ³•æŠ½è±¡ä¸ºç­–ç•¥æ¥å£**
- **å®¢æˆ·ç«¯é€šè¿‡ç»„åˆæ–¹å¼ä½¿ç”¨ä¸åŒç­–ç•¥, è€Œéç»§æ‰¿**

> ğŸ’¡ ç»å…¸æ¯”å–»: 
>  **å¯¼èˆªAppä¸­çš„è·¯çº¿ç­–ç•¥** â€”â€” ä½ å¯ä»¥éšæ—¶åˆ‡æ¢â€œæœ€çŸ­è·¯å¾„â€ã€â€œæœ€å°‘æ”¶è´¹â€ã€â€œé¿å¼€é«˜é€Ÿâ€, è€ŒAppæœ¬èº«ç»“æ„ä¸å˜ã€‚

------

 ğŸ§© ç»“æ„ç»„æˆ: 

| è§’è‰²                    | è¯´æ˜                                                         |
| ----------------------- | ------------------------------------------------------------ |
| `Strategy`              | æŠ½è±¡ç­–ç•¥æ¥å£(å¦‚ `ISortStrategy`, `IPaymentStrategy`)       |
| `ConcreteStrategyA/B/C` | å…·ä½“ç­–ç•¥ç±»(å¦‚ `QuickSort`, `CreditCardPayment`), å®ç°ä¸åŒç®—æ³• |
| `Context`               | ä¸Šä¸‹æ–‡ç±», æŒæœ‰ç­–ç•¥å¯¹è±¡å¼•ç”¨, æä¾›è°ƒç”¨æ¥å£(å¦‚ `Sorter`, `PaymentProcessor`) |
| `Client`                | å®¢æˆ·ç«¯, é€‰æ‹©å¹¶è®¾ç½®å…·ä½“ç­–ç•¥, è§¦å‘è¡Œä¸º                         |

> ğŸ“Œ **å…³é”®ç‚¹: **
>
> - ç­–ç•¥æ¨¡å¼ä½¿ç”¨**ç»„åˆè€Œéç»§æ‰¿**å®ç°ç®—æ³•åˆ‡æ¢
> - å®¢æˆ·ç«¯å†³å®šä½¿ç”¨å“ªä¸ªç­–ç•¥
> - ç­–ç•¥å¯¹è±¡å¯åŠ¨æ€æ›¿æ¢

------

 âœ… é€‚ç”¨åœºæ™¯

1. **å¤šç§ç®—æ³•/è¡Œä¸ºå¯äº’æ¢**(å¦‚æ’åºã€æ”¯ä»˜ã€å‹ç¼©ã€åŠ å¯†)
2. **é¿å…å¤§é‡æ¡ä»¶è¯­å¥(if-else / switch)**
3. **éœ€è¦è¿è¡Œæ—¶åŠ¨æ€åˆ‡æ¢ç®—æ³•**
4. **ç®—æ³•éœ€ç‹¬ç«‹äºä½¿ç”¨å®ƒçš„ç±»**
5. **ä¸åŒç”¨æˆ·/åœºæ™¯éœ€è¦ä¸åŒè¡Œä¸º**

ğŸ“Œ **å…¸å‹åº”ç”¨åœºæ™¯: **

- ğŸ§® **æ’åºç®—æ³•åˆ‡æ¢**: å¿«é€Ÿæ’åºã€å½’å¹¶æ’åºã€å†’æ³¡æ’åº
- ğŸ’³ **æ”¯ä»˜æ–¹å¼**: ä¿¡ç”¨å¡ã€æ”¯ä»˜å®ã€å¾®ä¿¡ã€PayPal
- ğŸ® **æ¸¸æˆè§’è‰²AIè¡Œä¸º**: æ”»å‡»ã€é€ƒè·‘ã€å·¡é€»
- ğŸ§­ **å¯¼èˆªè·¯å¾„è§„åˆ’**: æœ€çŸ­æ—¶é—´ã€æœ€å°‘æ”¶è´¹ã€é¿å¼€é«˜é€Ÿ
- ğŸ“¦ **æ•°æ®å‹ç¼©ç®—æ³•**: ZIPã€GZIPã€LZ4
- ğŸ” **åŠ å¯†ç®—æ³•**: AESã€RSAã€DES

------

 âœ… ä¼˜ç¼ºç‚¹

 âœ… ä¼˜ç‚¹: 

1. **ç®—æ³•å¯è‡ªç”±åˆ‡æ¢** â†’ è¿è¡Œæ—¶åŠ¨æ€æ›´æ¢ç­–ç•¥
2. **é¿å…æ¡ä»¶è¯­å¥** â†’ ä»£ç æ›´æ¸…æ™°ã€æ˜“ç»´æŠ¤
3. **æ‰©å±•æ€§å¼º** â†’ æ–°å¢ç­–ç•¥æ— éœ€ä¿®æ”¹ä¸Šä¸‹æ–‡æˆ–å®¢æˆ·ç«¯
4. **ç¬¦åˆå¼€é—­åŸåˆ™** â†’ å¯¹æ‰©å±•å¼€æ”¾, å¯¹ä¿®æ”¹å…³é—­
5. **èŒè´£åˆ†ç¦»** â†’ ç­–ç•¥ä¸“æ³¨ç®—æ³•, ä¸Šä¸‹æ–‡ä¸“æ³¨åè°ƒ

 âŒ ç¼ºç‚¹: 

1. **å¢åŠ ç±»æ•°é‡** â†’ æ¯ä¸ªç­–ç•¥ä¸€ä¸ªç±»
2. **å®¢æˆ·ç«¯éœ€äº†è§£ç­–ç•¥å·®å¼‚** â†’ éœ€çŸ¥é“é€‰å“ªä¸ªç­–ç•¥åˆé€‚
3. **ç­–ç•¥é—´åˆ‡æ¢å¯èƒ½æœ‰çŠ¶æ€ä¸¢å¤±é£é™©**(è‹¥ç­–ç•¥æœ‰å†…éƒ¨çŠ¶æ€)
4. **è¿‡åº¦è®¾è®¡é£é™©** â†’ ç®€å•åœºæ™¯ç”¨ if-else æ›´ç›´æ¥

------

 âœ… æ³¨æ„äº‹é¡¹

 1. ğŸ”„ ç­–ç•¥æ¨¡å¼ â‰  çŠ¶æ€æ¨¡å¼

| æ¨¡å¼     | ç›®çš„                     | åˆ‡æ¢æ§åˆ¶è€…     |
| -------- | ------------------------ | -------------- |
| ç­–ç•¥æ¨¡å¼ | **å®¢æˆ·ç«¯å†³å®šåˆ‡æ¢ç®—æ³•**   | å®¢æˆ·ç«¯ä¸»åŠ¨è®¾ç½® |
| çŠ¶æ€æ¨¡å¼ | **å¯¹è±¡å†…éƒ¨çŠ¶æ€é©±åŠ¨è¡Œä¸º** | å¯¹è±¡è‡ªèº«åˆ‡æ¢   |

> ğŸ’¡ **ç­–ç•¥ = â€œæˆ‘é€‰å“ªä¸ªç®—æ³•â€, çŠ¶æ€ = â€œæˆ‘ç°åœ¨æ˜¯ä»€ä¹ˆçŠ¶æ€, è¯¥åšä»€ä¹ˆâ€**


```
// ç­–ç•¥: å®¢æˆ·ç«¯è®¾ç½®
context.setStrategy(new QuickSort());

// çŠ¶æ€: å¯¹è±¡æ ¹æ®å†…éƒ¨çŠ¶æ€è‡ªåŠ¨åˆ‡æ¢
state.handle(); // å†…éƒ¨å¯èƒ½åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªçŠ¶æ€
```

------

 2. âš ï¸ ç­–ç•¥å¯¹è±¡åº”å°½é‡**æ— çŠ¶æ€(Stateless)**

> æœ‰çŠ¶æ€ç­–ç•¥åœ¨åˆ‡æ¢æ—¶å¯èƒ½ä¸¢å¤±æ•°æ®, å¢åŠ å¤æ‚åº¦ã€‚


```
// âœ… æ— çŠ¶æ€ç­–ç•¥(æ¨è)
class QuickSort : public ISortStrategy {
public:
    void sort(std::vector<int>& data) override {
        // ä¸ä¿å­˜ä»»ä½•æˆå‘˜å˜é‡
        std::sort(data.begin(), data.end()); // ç®€åŒ–ç¤ºä¾‹
    }
};

// âŒ æœ‰çŠ¶æ€ç­–ç•¥(è°¨æ…ä½¿ç”¨)
class CountingSort : public ISortStrategy {
    int maxVal; // å†…éƒ¨çŠ¶æ€
public:
    void sort(std::vector<int>& data) override { ... }
};
```

------

 3. âœ… ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆç®¡ç†ç­–ç•¥å¯¹è±¡(C++)


```
class Sorter {
    std::unique_ptr<ISortStrategy> strategy;
public:
    void setStrategy(std::unique_ptr<ISortStrategy> s) {
        strategy = std::move(s);
    }
    void execute(std::vector<int>& data) {
        if (strategy) strategy->sort(data);
    }
};
```

> âœ… `unique_ptr`: ç‹¬å æ‰€æœ‰æƒ, ç­–ç•¥ç”±ä¸Šä¸‹æ–‡ç®¡ç†
>  âœ… `shared_ptr`: å¤šä¸ªä¸Šä¸‹æ–‡å…±äº«åŒä¸€ç­–ç•¥

------

 4. âœ… ç­–ç•¥å¯é…ç½®åŒ–(å·¥å‚ + é…ç½®æ–‡ä»¶)


```
std::unique_ptr<ISortStrategy> createStrategy(const std::string& type) {
    if (type == "quick") return std::make_unique<QuickSort>();
    if (type == "merge") return std::make_unique<MergeSort>();
    throw std::invalid_argument("Unknown strategy");
}
```

------

 5. âœ… é€‚ç”¨äºâ€œç®—æ³•æ—â€ã€â€œè¡Œä¸ºæ—â€åœºæ™¯

> å¦‚æœç®—æ³•å·®å¼‚å¤§ã€ä½¿ç”¨é¢‘ç¹ã€éœ€åŠ¨æ€åˆ‡æ¢, ç­–ç•¥æ¨¡å¼æ˜¯é¦–é€‰ã€‚

------

 6. âš ï¸ é¿å…ç­–ç•¥â€œä¸Šå¸ç±»â€

> æ¯ä¸ªç­–ç•¥åº”èŒè´£å•ä¸€, é¿å…ä¸€ä¸ªç­–ç•¥åšå¤ªå¤šäº‹ã€‚

ğŸ¯ **æ¨èè¯­: **

> **ç­–ç•¥æ¨¡å¼æ˜¯æ¶ˆé™¤æ¡ä»¶è¯­å¥ã€å®ç°ç®—æ³•è‡ªç”±åˆ‡æ¢çš„åˆ©å™¨ã€‚æ— è®ºæ˜¯æ’åºã€æ”¯ä»˜ã€AIè¡Œä¸º, åªè¦ä½ æƒ³â€œæ¢ç®—æ³•å¦‚æ¢è¡£æœâ€, ç­–ç•¥æ¨¡å¼å°±æ˜¯ä½ çš„æœ€ä½³é€‰æ‹©ï¼**

æŒæ¡ç­–ç•¥æ¨¡å¼, ä½ å°±æŒæ¡äº†â€œç®—æ³•è‡ªç”±çš„è‰ºæœ¯â€ï¼

## ä»£ç 

æ’åºç­–ç•¥

```
// Strategy.h
#include <iostream>
#include <vector>
#include <memory>
#include <algorithm>

// ============ æŠ½è±¡ç­–ç•¥ ============
class ISortStrategy {
public:
    virtual ~ISortStrategy() = default;
    virtual void sort(std::vector<int>& data) = 0;
    virtual std::string getName() const = 0;
};

// ============ å…·ä½“ç­–ç•¥ ============
class QuickSort : public ISortStrategy {
public:
    void sort(std::vector<int>& data) override {
        std::sort(data.begin(), data.end()); // ç®€åŒ–, å®é™…åº”å®ç°å¿«æ’
    }
    std::string getName() const override { return "QuickSort"; }
};

class BubbleSort : public ISortStrategy {
public:
    void sort(std::vector<int>& data) override {
        for (size_t i = 0; i < data.size(); ++i) {
            for (size_t j = 0; j < data.size() - i - 1; ++j) {
                if (data[j] > data[j + 1]) {
                    std::swap(data[j], data[j + 1]);
                }
            }
        }
    }
    std::string getName() const override { return "BubbleSort"; }
};

class MergeSort : public ISortStrategy {
public:
    void sort(std::vector<int>& data) override {
        if (data.size() <= 1) return;
        std::vector<int> temp(data.size());
        mergeSortImpl(data, temp, 0, data.size() - 1);
    }

private:
    void mergeSortImpl(std::vector<int>& data, std::vector<int>& temp, int left, int right) {
        if (left >= right) return;
        int mid = left + (right - left) / 2;
        mergeSortImpl(data, temp, left, mid);
        mergeSortImpl(data, temp, mid + 1, right);
        merge(data, temp, left, mid, right);
    }

    void merge(std::vector<int>& data, std::vector<int>& temp, int left, int mid, int right) {
        for (int i = left; i <= right; ++i) temp[i] = data[i];
        int i = left, j = mid + 1, k = left;
        while (i <= mid && j <= right) {
            if (temp[i] <= temp[j]) data[k++] = temp[i++];
            else data[k++] = temp[j++];
        }
        while (i <= mid) data[k++] = temp[i++];
        while (j <= right) data[k++] = temp[j++];
    }

public:
    std::string getName() const override { return "MergeSort"; }
};

// ============ ä¸Šä¸‹æ–‡ ============
class Sorter {
    std::unique_ptr<ISortStrategy> strategy;

public:
    void setStrategy(std::unique_ptr<ISortStrategy> s) {
        strategy = std::move(s);
        std::cout << "ğŸ”„ Strategy set to: " << strategy->getName() << "\n";
    }

    void execute(std::vector<int>& data) {
        if (!strategy) {
            std::cout << "âŒ No strategy set!\n";
            return;
        }
        std::cout << "â–¶ï¸ Executing " << strategy->getName() << "...\n";
        strategy->sort(data);
    }
};

// ============ å·¥å…·å‡½æ•° ============
void printVector(const std::vector<int>& v, const std::string& title) {
    std::cout << title << ": ";
    for (int x : v) std::cout << x << " ";
    std::cout << "\n";
}

// ============ å®¢æˆ·ç«¯ ============
#include "Strategy.h"

int main() {
    std::cout << "=== ç­–ç•¥æ¨¡å¼: æ’åºç®—æ³•åˆ‡æ¢ ===\n\n";

    Sorter sorter;
    std::vector<int> data = {64, 34, 25, 12, 22, 11, 90};

    printVector(data, "Original data");

    // ä½¿ç”¨å†’æ³¡æ’åº
    sorter.setStrategy(std::make_unique<BubbleSort>());
    sorter.execute(data);
    printVector(data, "After BubbleSort");

    // é‡ç½®æ•°æ®
    data = {64, 34, 25, 12, 22, 11, 90};

    // ä½¿ç”¨å¿«é€Ÿæ’åº
    sorter.setStrategy(std::make_unique<QuickSort>());
    sorter.execute(data);
    printVector(data, "After QuickSort");

    // é‡ç½®æ•°æ®
    data = {64, 34, 25, 12, 22, 11, 90};

    // ä½¿ç”¨å½’å¹¶æ’åº
    sorter.setStrategy(std::make_unique<MergeSort>());
    sorter.execute(data);
    printVector(data, "After MergeSort");

    return 0;
}
```



## PlantUML

```
@startuml

' æŠ½è±¡ç­–ç•¥
interface Strategy {
    +algorithmInterface()
}

' å…·ä½“ç­–ç•¥
class ConcreteStrategyA {
    +algorithmInterface()
}

class ConcreteStrategyB {
    +algorithmInterface()
}

class ConcreteStrategyC {
    +algorithmInterface()
}

' ä¸Šä¸‹æ–‡
class Context {
    -strategy: Strategy
    +setStrategy(strategy: Strategy)
    +contextInterface()
}

' å®¢æˆ·ç«¯
class Client {
    +main()
}

' å…³ç³»
Strategy <|-- ConcreteStrategyA
Strategy <|-- ConcreteStrategyB
Strategy <|-- ConcreteStrategyC
Context --> Strategy : uses
Client --> Context : configures
Client --> Strategy : creates

note right of Strategy
    Declares interface
    common to all supported
    algorithms.
end note

note right of ConcreteStrategyA
    Implements the algorithm
    using the Strategy interface.
end note

note bottom of Context
    Maintains a reference to a
    Strategy object and calls
    its algorithmInterface().
end note

note top of Client
    Chooses and sets the
    concrete strategy.
end note

@enduml
```

![](./picture/14.StrategyPattern.png)



# 17. æ¨¡æ¿æ–¹æ³•æ¨¡å¼

## ç®€ä»‹


> C++ æ¨¡æ¿æ–¹æ³•æ¨¡å¼(Template Method Pattern)
> **å®šä¹‰ç®—æ³•éª¨æ¶, å°†æŸäº›æ­¥éª¤å»¶è¿Ÿåˆ°å­ç±»å®ç°ã€‚**
>  â€”â€” çˆ¶ç±»æ§åˆ¶æµç¨‹, å­ç±»å®ç°ç»†èŠ‚ã€‚

------

ğŸ“Œ 1. ä»‹ç»

- **ç±»å‹**: è¡Œä¸ºå‹æ¨¡å¼
- **æ ¸å¿ƒæ€æƒ³**: 
  - åœ¨**æŠ½è±¡åŸºç±»**ä¸­å®šä¹‰ä¸€ä¸ª**æ¨¡æ¿æ–¹æ³•(é€šå¸¸æ˜¯ final æˆ–éè™šå‡½æ•°)**, å®ƒæŒ‰å›ºå®šé¡ºåºè°ƒç”¨å¤šä¸ªæ­¥éª¤ã€‚
  - å…¶ä¸­éƒ¨åˆ†æ­¥éª¤æ˜¯**çº¯è™šå‡½æ•°æˆ–è™šå‡½æ•°**, ç”±å­ç±»å®ç°å…·ä½“è¡Œä¸ºã€‚
  - çˆ¶ç±»æ§åˆ¶â€œä¸å˜çš„æµç¨‹â€, å­ç±»æä¾›â€œå¯å˜çš„å®ç°â€ã€‚
- **å…³é”®è¯**: ç®—æ³•éª¨æ¶ã€ç»§æ‰¿ã€é’©å­æ–¹æ³•ã€å¥½è±ååŸåˆ™(â€œDonâ€™t call us, weâ€™ll call youâ€)

------

ğŸ¯ 2. é€‚ç”¨åœºæ™¯

 âœ” ç®—æ³•ç»“æ„ç¨³å®š, ä½†æŸäº›æ­¥éª¤å®ç°å¯å˜(å¦‚æ³¡èŒ¶/å’–å•¡ã€æ•°æ®å¤„ç†æµç¨‹ã€æ¸¸æˆå…³å¡æµç¨‹)
 âœ” éœ€è¦æ§åˆ¶å­ç±»æ‰©å±•èŒƒå›´, é˜²æ­¢ç ´åç®—æ³•ç»“æ„
 âœ” å¤šä¸ªå­ç±»æœ‰å…¬å…±è¡Œä¸º, å¸Œæœ›é¿å…ä»£ç é‡å¤
 âœ” æ¡†æ¶è®¾è®¡ä¸­, æä¾›æ ‡å‡†æµç¨‹, å…è®¸ç”¨æˆ·è‡ªå®šä¹‰éƒ¨åˆ†æ­¥éª¤

------

âš–ï¸ 3. ä¼˜ç¼ºç‚¹

| ä¼˜ç‚¹                                         | ç¼ºç‚¹                                 |
| -------------------------------------------- | ------------------------------------ |
| âœ… å°è£…ä¸å˜éƒ¨åˆ†, æ‰©å±•å¯å˜éƒ¨åˆ†                 | âŒ ç»§æ‰¿å¯¼è‡´ç±»æ•°é‡è†¨èƒ€                 |
| âœ… æå–å…¬å…±ä»£ç , ä¾¿äºç»´æŠ¤                     | âŒ å­ç±»å½±å“çˆ¶ç±»(è¿åâ€œé‡Œæ°æ›¿æ¢â€é£é™©) |
| âœ… è¡Œä¸ºç”±çˆ¶ç±»æ§åˆ¶, å­ç±»å®ç°ç»†èŠ‚(å¥½è±ååŸåˆ™) | âŒ ä¸é€‚åˆé¢‘ç¹å˜åŒ–çš„ç®—æ³•ç»“æ„           |
| âœ… ç¬¦åˆå¼€é—­åŸåˆ™(æ‰©å±•å­ç±»ä¸æ”¹çˆ¶ç±»)           |                                      |

------

âš ï¸ 4. æ³¨æ„äº‹é¡¹

1. **æ¨¡æ¿æ–¹æ³•å»ºè®®è®¾ä¸º `final`(C++11+)** â†’ é˜²æ­¢å­ç±»é‡å†™éª¨æ¶, ç ´åæµç¨‹ã€‚
2. **æ­¥éª¤æ–¹æ³•å¯è®¾ä¸º `protected`** â†’ ä»…å­ç±»å¯è®¿é—®, å¤–éƒ¨ä¸å¯è°ƒç”¨ã€‚
3. **å¯æä¾›â€œé’©å­æ–¹æ³•(hook)â€** â†’ ç©ºå®ç°è™šå‡½æ•°, å­ç±»å¯é€‰é‡å†™ã€‚
4. **é¿å…åœ¨æ¨¡æ¿æ–¹æ³•ä¸­è°ƒç”¨å¯èƒ½è¢«å­ç±»é‡å†™çš„éfinalè™šå‡½æ•°åˆå§‹åŒ–èµ„æº** â†’ æ„é€ å‡½æ•°ä¸­è°ƒç”¨è™šå‡½æ•°æ˜¯æœªå®šä¹‰è¡Œä¸ºï¼
5. **æ…ç”¨æ·±ç»§æ‰¿** â†’ ä¼˜å…ˆç»„åˆ, ä½†æ¨¡æ¿æ–¹æ³•æ˜¯â€œåˆç†ä½¿ç”¨ç»§æ‰¿â€çš„ç»å…¸åœºæ™¯ã€‚

 ğŸ§  ä¸€å¥è¯æ€»ç»“æ¨¡æ¿æ–¹æ³•: 

> **â€œçˆ¶å®šæµç¨‹, å­å¡«æ­¥éª¤ï¼›é’©å­å¯é€‰, éª¨æ¶ä¸å˜ã€‚â€**

------

âœ… **é€‚ç”¨è¯­è¨€**: C++ã€Javaã€C#ã€Python ç­‰æ”¯æŒç»§æ‰¿å’Œè™šå‡½æ•°çš„è¯­è¨€
âœ… **ç»å…¸åº”ç”¨**: 

- Java `AbstractList`ã€`InputStream`
- C++ æ¡†æ¶ä¸­çš„åˆå§‹åŒ–/å¤„ç†/æ¸…ç†æµç¨‹
- æ¸¸æˆAIè¡Œä¸ºæ ‘ä¸­çš„æ ‡å‡†æ‰§è¡Œæµç¨‹

------

ğŸ“Œ **å­¦ä¹ å»ºè®®**: 

- ä¸**ç­–ç•¥æ¨¡å¼**å¯¹æ¯”: æ¨¡æ¿æ–¹æ³• = **ç»§æ‰¿å®ç°**æµç¨‹å®šåˆ¶ï¼›ç­–ç•¥æ¨¡å¼ = **ç»„åˆå®ç°**ç®—æ³•æ›¿æ¢ã€‚
- ä¸**å·¥å‚æ–¹æ³•**ç»“åˆ: æ¨¡æ¿æ–¹æ³•ä¸­æŸæ­¥å¯è°ƒç”¨å·¥å‚æ–¹æ³•åˆ›å»ºå¯¹è±¡ã€‚

## ä»£ç 

æ³¡é¥®æ–™æµç¨‹

```
#include <iostream>
using namespace std;

// æŠ½è±¡åŸºç±»: å®šä¹‰ç®—æ³•éª¨æ¶
class Beverage {
public:
    // æ¨¡æ¿æ–¹æ³•: å®šä¹‰æµç¨‹, finalé˜²æ­¢è¢«é‡å†™
    void prepareRecipe() final {
        boilWater();
        brew();
        pourInCup();
        if (customerWantsCondiments()) { // é’©å­æ–¹æ³•
            addCondiments();
        }
    }

protected:
    // åŸºæœ¬æ­¥éª¤(éƒ¨åˆ†ç”±å­ç±»å®ç°)
    virtual void brew() = 0;           // çº¯è™š, å¿…é¡»å®ç°
    virtual void addCondiments() = 0;  // çº¯è™š, å¿…é¡»å®ç°

    // å…·ä½“æ­¥éª¤(çˆ¶ç±»å®ç°)
    void boilWater() {
        cout << "Boiling water" << endl;
    }

    void pourInCup() {
        cout << "Pouring into cup" << endl;
    }

    // é’©å­æ–¹æ³•: é»˜è®¤å®ç°, å­ç±»å¯é€‰é‡å†™
    virtual bool customerWantsCondiments() const {
        return true; // é»˜è®¤åŠ è°ƒæ–™
    }
};

// å­ç±»1: æ³¡èŒ¶
class Tea : public Beverage {
protected:
    void brew() override {
        cout << "Steeping the tea" << endl;
    }

    void addCondiments() override {
        cout << "Adding lemon" << endl;
    }
};

// å­ç±»2: å†²å’–å•¡
class Coffee : public Beverage {
protected:
    void brew() override {
        cout << "Dripping coffee through filter" << endl;
    }

    void addCondiments() override {
        cout << "Adding sugar and milk" << endl;
    }

    // é‡å†™é’©å­: è¯¢é—®ç”¨æˆ·æ˜¯å¦è¦è°ƒæ–™
    bool customerWantsCondiments() const override {
        // æ¨¡æ‹Ÿç”¨æˆ·è¾“å…¥
        cout << "Would you like milk and sugar with your coffee (y/n)? ";
        char answer;
        cin >> answer;
        return (answer == 'y' || answer == 'Y');
    }
};

// å®¢æˆ·ç«¯ä½¿ç”¨
int main() {
    cout << "Making tea..." << endl;
    Tea tea;
    tea.prepareRecipe();

    cout << "\nMaking coffee..." << endl;
    Coffee coffee;
    coffee.prepareRecipe();

    return 0;
}
```

## PlantUML

```
@startuml
abstract class Beverage {
    +{final} prepareRecipe() : void
    #boilWater() : void
    #pourInCup() : void
    #{virtual} customerWantsCondiments() : bool
    #{abstract} brew() : void
    #{abstract} addCondiments() : void
}

class Tea {
    #brew() : void
    #addCondiments() : void
}

class Coffee {
    #brew() : void
    #addCondiments() : void
    #customerWantsCondiments() : bool
}

Beverage <|-- Tea
Beverage <|-- Coffee

note right of Beverage
  Template Method Pattern
  prepareRecipe() æ˜¯æ¨¡æ¿æ–¹æ³•
  brew() å’Œ addCondiments() æ˜¯æŠ½è±¡æ­¥éª¤
  customerWantsCondiments() æ˜¯é’©å­æ–¹æ³•
end note

@enduml
```

![](./picture/15.TemplateMethodPattern.png)

# 18. è§‚å¯Ÿè€…æ¨¡å¼

## ç®€ä»‹

> C++ è§‚å¯Ÿè€…æ¨¡å¼(Observer Pattern)
> **å®šä¹‰å¯¹è±¡é—´çš„ä¸€å¯¹å¤šä¾èµ–å…³ç³», å½“ä¸€ä¸ªå¯¹è±¡(ä¸»é¢˜)çŠ¶æ€æ”¹å˜æ—¶, æ‰€æœ‰ä¾èµ–å®ƒçš„å¯¹è±¡(è§‚å¯Ÿè€…)è‡ªåŠ¨æ”¶åˆ°é€šçŸ¥å¹¶æ›´æ–°ã€‚**

------

ğŸ“Œ 1. ä»‹ç»

- **ç±»å‹**: è¡Œä¸ºå‹æ¨¡å¼

- **åˆ«å**: å‘å¸ƒ-è®¢é˜…æ¨¡å¼(Publish-Subscribe, ä½†ä¸¥æ ¼æ¥è¯´æ˜¯å…¶åŒæ­¥ç´§è€¦åˆç‰ˆæœ¬)

- æ ¸å¿ƒè§’è‰²: 
  - `Subject`(ä¸»é¢˜/è¢«è§‚å¯Ÿè€…): ç»´æŠ¤è§‚å¯Ÿè€…åˆ—è¡¨, æä¾›æ³¨å†Œ/ç§»é™¤/é€šçŸ¥æ¥å£ã€‚
  - `Observer`(è§‚å¯Ÿè€…): å®šä¹‰æ›´æ–°æ¥å£, ä¾›ä¸»é¢˜è°ƒç”¨ã€‚

- **é€šä¿¡æ–¹å¼: æ¨æ¨¡å‹(Push) æˆ– æ‹‰æ¨¡å‹(Pull)**
  - æ¨: ä¸»é¢˜ä¸»åŠ¨ä¼ é€’æ•°æ®ç»™è§‚å¯Ÿè€…
  - æ‹‰: è§‚å¯Ÿè€…è‡ªå·±ä»ä¸»é¢˜æ‹‰å–æ•°æ®(ä¸»é¢˜åªå‘â€œæœ‰æ›´æ–°â€ä¿¡å·)

------

ğŸ¯ 2. é€‚ç”¨åœºæ™¯

 âœ” å¯¹è±¡çŠ¶æ€å˜åŒ–éœ€é€šçŸ¥å¤šä¸ªå¯¹è±¡(å¦‚GUIæ§ä»¶ã€æ•°æ®ç»‘å®š)
 âœ” è§£è€¦â€œæ•°æ®å±‚â€ä¸â€œè§†å›¾å±‚â€(MVCä¸­çš„æ ¸å¿ƒæœºåˆ¶)
 âœ” äº‹ä»¶ç³»ç»Ÿã€æ¶ˆæ¯é€šçŸ¥ã€æ—¥å¿—ç›‘å¬ã€è‚¡ç¥¨è¡Œæƒ…æ¨é€
 âœ” é¿å…å¯¹è±¡é—´ç›´æ¥å¼•ç”¨, é™ä½è€¦åˆ

------

âš–ï¸ 3. ä¼˜ç¼ºç‚¹

| ä¼˜ç‚¹                               | ç¼ºç‚¹                                   |
| ---------------------------------- | -------------------------------------- |
| âœ… å»ºç«‹åŠ¨æ€ã€æ¾è€¦åˆçš„ä¸€å¯¹å¤šå…³ç³»     | âŒ é€šçŸ¥é¡ºåºä¸ç¡®å®š(é™¤éæ˜¾å¼æ§åˆ¶)       |
| âœ… æ”¯æŒå¹¿æ’­é€šä¿¡, è‡ªåŠ¨é€šçŸ¥æ‰€æœ‰è§‚å¯Ÿè€… | âŒ å¯èƒ½å¯¼è‡´â€œå†…å­˜æ³„æ¼â€(è§‚å¯Ÿè€…æœªæ³¨é”€)   |
| âœ… ç¬¦åˆå¼€é—­åŸåˆ™(å¯è‡ªç”±å¢åˆ è§‚å¯Ÿè€…) | âŒ è¿‡åº¦ä½¿ç”¨ä¼šå¯¼è‡´ç³»ç»Ÿå¤æ‚ã€éš¾ä»¥è¿½è¸ªä¾èµ– |
| âœ… æ˜“äºæ‰©å±•æ–°è§‚å¯Ÿè€…                 | âŒ åŒæ­¥é€šçŸ¥å¯èƒ½é˜»å¡ä¸»é¢˜(å¯ç”¨å¼‚æ­¥ä¼˜åŒ–) |

------

âš ï¸ 4. æ³¨æ„äº‹é¡¹

1. **è§‚å¯Ÿè€…éœ€åœ¨é”€æ¯å‰ä»ä¸»é¢˜ä¸­æ³¨é”€** â†’ å¦åˆ™ä¸»é¢˜é€šçŸ¥å·²é”€æ¯å¯¹è±¡ â†’ æœªå®šä¹‰è¡Œä¸º(å´©æºƒ)ã€‚

2. **è€ƒè™‘çº¿ç¨‹å®‰å…¨** â†’ å¤šçº¿ç¨‹ç¯å¢ƒä¸‹, æ³¨å†Œ/æ³¨é”€/é€šçŸ¥éœ€åŠ é”ã€‚

3. **é¿å…åœ¨é€šçŸ¥è¿‡ç¨‹ä¸­ä¿®æ”¹è§‚å¯Ÿè€…åˆ—è¡¨** â†’ å¯èƒ½å¯¼è‡´è¿­ä»£å™¨å¤±æ•ˆ â†’ å»ºè®®å¤åˆ¶åˆ—è¡¨æˆ–å»¶è¿Ÿåˆ é™¤ã€‚

4. æ¨ vs æ‹‰æ¨¡å‹é€‰æ‹©: 

   - æ¨: æ•ˆç‡é«˜, ä½†è€¦åˆæ•°æ®ç»“æ„
   - æ‹‰: æ›´çµæ´», ä½†è§‚å¯Ÿè€…éœ€æŒæœ‰ä¸»é¢˜å¼•ç”¨
   
5. **å¯é€‰: ä½¿ç”¨ `std::function` + `std::vector` æ›¿ä»£ç»§æ‰¿æ¥å£** â†’ æ›´è½»é‡, é€‚åˆç®€å•åœºæ™¯(è§ç¤ºä¾‹äºŒ)ã€‚

ğŸ§  ä¸€å¥è¯æ€»ç»“è§‚å¯Ÿè€…æ¨¡å¼: 

> **â€œæˆ‘å˜ä½ çŸ¥, è‡ªåŠ¨é€šçŸ¥ï¼›ä¸€å¯¹å¤šè”, è§£è€¦åˆ©å™¨ã€‚â€**

------

âœ… **ç»å…¸åº”ç”¨**: 

- GUIäº‹ä»¶ç›‘å¬(æŒ‰é’®ç‚¹å‡»ã€çª—å£å…³é—­)
- MVCæ¶æ„ä¸­çš„ Model â†’ View é€šçŸ¥
- æ¸¸æˆæˆå°±ç³»ç»Ÿã€æ—¥å¿—ç³»ç»Ÿã€è‚¡ç¥¨è¡Œæƒ…æ¨é€
- Qt çš„ `Signal/Slot`ã€.NET çš„ `Event`ã€Java çš„ `PropertyChangeListener`

------

ğŸ“Œ **å­¦ä¹ å»ºè®®**: 

- ä¸**å‘å¸ƒ-è®¢é˜…æ¨¡å¼**å¯¹æ¯”: è§‚å¯Ÿè€…æ˜¯åŒæ­¥ã€ç´§è€¦åˆï¼›å‘å¸ƒè®¢é˜…é€šè¿‡æ¶ˆæ¯é˜Ÿåˆ—å¼‚æ­¥è§£è€¦ã€‚
- ä¸**ä¸­ä»‹è€…æ¨¡å¼**å¯¹æ¯”: è§‚å¯Ÿè€…æ˜¯â€œå¹¿æ’­â€, ä¸­ä»‹è€…æ˜¯â€œè°ƒåº¦ä¸­å¿ƒâ€ã€‚

## ä»£ç 

âœ… ç¤ºä¾‹ä¸€: ä¼ ç»Ÿæ¥å£ç»§æ‰¿æ–¹å¼(ç»å…¸GoFé£æ ¼)

```
#include <iostream>
#include <vector>
#include <algorithm>
#include <memory>

// æŠ½è±¡è§‚å¯Ÿè€…æ¥å£
class Observer {
public:
    virtual ~Observer() = default;
    virtual void update(float temperature, float humidity, float pressure) = 0;
};

// æŠ½è±¡ä¸»é¢˜æ¥å£
class Subject {
public:
    virtual ~Subject() = default;
    virtual void registerObserver(std::shared_ptr<Observer> o) = 0;
    virtual void removeObserver(std::shared_ptr<Observer> o) = 0;
    virtual void notifyObservers() = 0;
};

// å…·ä½“ä¸»é¢˜: æ°”è±¡ç«™
class WeatherData : public Subject {
    std::vector<std::weak_ptr<Observer>> observers; // ä½¿ç”¨ weak_ptr é¿å…å¾ªç¯å¼•ç”¨
    float temperature = 0.0f;
    float humidity = 0.0f;
    float pressure = 0.0f;

public:
    void registerObserver(std::shared_ptr<Observer> o) override {
        observers.push_back(o);
    }

    void removeObserver(std::shared_ptr<Observer> o) override {
        observers.erase(
            std::remove_if(observers.begin(), observers.end(),
                [&o](const std::weak_ptr<Observer>& w) {
                    auto p = w.lock();
                    return !p || p == o;
                }),
            observers.end()
        );
    }

    void notifyObservers() override {
        // å¤åˆ¶åˆ°ä¸´æ—¶vector, é¿å…è¿­ä»£ä¸­ä¿®æ”¹
        std::vector<std::shared_ptr<Observer>> validObservers;
        for (auto& w : observers) {
            if (auto obs = w.lock()) {
                validObservers.push_back(obs);
            }
        }
        for (auto& obs : validObservers) {
            obs->update(temperature, humidity, pressure);
        }
    }

    // æ¨¡æ‹Ÿä¼ æ„Ÿå™¨æ•°æ®æ›´æ–°
    void setMeasurements(float temp, float hum, float pres) {
        temperature = temp;
        humidity = hum;
        pressure = pres;
        notifyObservers();
    }
};

// å…·ä½“è§‚å¯Ÿè€…1: å½“å‰çŠ¶å†µæ˜¾ç¤º
class CurrentConditionsDisplay : public Observer {
    float temperature = 0.0f;
    float humidity = 0.0f;
    std::weak_ptr<Subject> weatherData; // å¯é€‰: ç”¨äºæ‹‰æ¨¡å‹

public:
    CurrentConditionsDisplay(std::shared_ptr<Subject> wd) : weatherData(wd) {}

    void update(float temp, float hum, float pres) override {
        temperature = temp;
        humidity = hum;
        display();
    }

    void display() {
        std::cout << "Current conditions: " << temperature
                  << "F degrees and " << humidity << "% humidity\n";
    }
};

// å…·ä½“è§‚å¯Ÿè€…2: ç»Ÿè®¡æ˜¾ç¤º
class StatisticsDisplay : public Observer {
    float maxTemp = 0.0f;
    float minTemp = 200.0f;
    float tempSum = 0.0f;
    int numReadings = 0;

public:
    void update(float temp, float hum, float pres) override {
        tempSum += temp;
        numReadings++;
        if (temp > maxTemp) maxTemp = temp;
        if (temp < minTemp) minTemp = temp;
        display();
    }

    void display() {
        std::cout << "Avg/Max/Min temperature = "
                  << (tempSum / numReadings) << "/" << maxTemp << "/" << minTemp << "\n";
    }
};

// å®¢æˆ·ç«¯ä½¿ç”¨
int main() {
    auto weatherData = std::make_shared<WeatherData>();

    auto currentDisplay = std::make_shared<CurrentConditionsDisplay>(weatherData);
    auto statsDisplay = std::make_shared<StatisticsDisplay>();

    weatherData->registerObserver(currentDisplay);
    weatherData->registerObserver(statsDisplay);

    weatherData->setMeasurements(80, 65, 30.4f);
    weatherData->setMeasurements(82, 70, 29.2f);
    weatherData->setMeasurements(78, 90, 29.2f);

    // è‡ªåŠ¨æ¸…ç†: shared_ptr + weak_ptr ç®¡ç†ç”Ÿå‘½å‘¨æœŸ
    return 0;
}
```

âœ… ç¤ºä¾‹äºŒ: ç°ä»£C++å‡½æ•°å¼é£æ ¼(std::function + lambda)

```
#include <iostream>
#include <vector>
#include <functional>

class WeatherStation {
    std::vector<std::function<void(float, float, float)>> observers;

public:
    void subscribe(std::function<void(float, float, float)> f) {
        observers.push_back(f);
    }

    void unsubscribe(const std::function<void(float, float, float)>& f) {
        observers.erase(
            std::remove(observers.begin(), observers.end(), f),
            observers.end()
        );
    }

    void setMeasurements(float temp, float hum, float pres) {
        for (const auto& f : observers) {
            f(temp, hum, pres);
        }
    }
};

int main() {
    WeatherStation station;

    auto display1 = [](float t, float h, float p) {
        std::cout << "[Display1] Temp: " << t << ", Hum: " << h << "\n";
    };

    auto display2 = [](float t, float h, float p) {
        std::cout << "[Display2] Got update!\n";
    };

    station.subscribe(display1);
    station.subscribe(display2);

    station.setMeasurements(25.5f, 60.0f, 1013.25f);

    return 0;
}
```

## PlantUML

```
@startuml
title Observer Pattern - Classic GoF

interface Subject {
    +registerObserver(o: Observer)
    +removeObserver(o: Observer)
    +notifyObservers()
}

interface Observer {
    +update(temperature: float, humidity: float, pressure: float)
}

class WeatherData {
    -observers: List<Observer>
    -temperature: float
    -humidity: float
    -pressure: float
    +setMeasurements(t,h,p)
}

class CurrentConditionsDisplay {
    -temperature: float
    -humidity: float
    +display()
}

class StatisticsDisplay {
    -maxTemp: float
    -minTemp: float
    -tempSum: float
    -numReadings: int
    +display()
}

Subject <|.. WeatherData
Observer <|.. CurrentConditionsDisplay
Observer <|.. StatisticsDisplay

WeatherData "1" *-- "0..*" Observer : observes >

note right of Subject
  ç»´æŠ¤è§‚å¯Ÿè€…åˆ—è¡¨
  æä¾›æ³¨å†Œ/ç§»é™¤/é€šçŸ¥æ¥å£
end note

note right of Observer
  å®šä¹‰æ›´æ–°æ¥å£
  ç”±å…·ä½“è§‚å¯Ÿè€…å®ç°
end note

@enduml
```

![](./picture/16.ObserverPattern.png)



# 19.è¿­ä»£å™¨æ¨¡å¼

## ç®€ä»‹

> ğŸ”„ C++ è¿­ä»£å™¨æ¨¡å¼(Iterator Pattern)
> **æä¾›ä¸€ç§æ–¹æ³•é¡ºåºè®¿é—®èšåˆå¯¹è±¡ä¸­çš„å„ä¸ªå…ƒç´ , è€Œåˆä¸æš´éœ²å…¶å†…éƒ¨è¡¨ç¤ºã€‚**

------

ğŸ“Œ 1. ä»‹ç»

- **ç±»å‹**: è¡Œä¸ºå‹æ¨¡å¼
- æ ¸å¿ƒæ€æƒ³ : 
  - å°†**éå†é€»è¾‘**ä»**èšåˆå¯¹è±¡**ä¸­æŠ½ç¦» â†’ å°è£…åˆ°**è¿­ä»£å™¨å¯¹è±¡**ä¸­ã€‚
  - å®¢æˆ·ç«¯é€šè¿‡ç»Ÿä¸€æ¥å£è®¿é—®å…ƒç´  â†’ **æ— éœ€çŸ¥é“å®¹å™¨å†…éƒ¨ç»“æ„**ã€‚
- **å…³é”®è¯**: éå†ã€å°è£…ã€ç»Ÿä¸€æ¥å£ã€è§£è€¦

> ğŸ’¡ **C++ STL ä¸­çš„ `begin()` / `end()` / `++it` / `\*it` å°±æ˜¯è¿­ä»£å™¨æ¨¡å¼çš„ç»å…¸å®ç°ï¼**

------

ğŸ¯ 2. é€‚ç”¨åœºæ™¯

 âœ” éœ€è¦éå†ä¸åŒæ•°æ®ç»“æ„(æ•°ç»„ã€é“¾è¡¨ã€æ ‘ã€å›¾)ä½†ä¸æƒ³æš´éœ²å†…éƒ¨ç»“æ„
 âœ” å¸Œæœ›æä¾›å¤šç§éå†æ–¹å¼(å‰åºã€ååºã€å±‚åºã€åå‘)
 âœ” è§£è€¦â€œæ•°æ®å­˜å‚¨â€ä¸â€œæ•°æ®è®¿é—®â€é€»è¾‘
 âœ” ç¬¦åˆâ€œå•ä¸€èŒè´£åŸåˆ™â€â€”â€”å®¹å™¨ç®¡å­˜å‚¨, è¿­ä»£å™¨ç®¡éå†

------

âš–ï¸ 3. ä¼˜ç¼ºç‚¹

| ä¼˜ç‚¹                                 | ç¼ºç‚¹                                       |
| ------------------------------------ | ------------------------------------------ |
| âœ… æ”¯æŒå¤šç§éå†ç­–ç•¥(å¦‚æ­£å‘/åå‘)    | âŒ å¢åŠ ç±»æ•°é‡(æ¯ä¸ªå®¹å™¨å¯èƒ½éœ€é…å¤šä¸ªè¿­ä»£å™¨) |
| âœ… ç®€åŒ–èšåˆç±»æ¥å£(æ— éœ€æš´éœ²å†…éƒ¨ç»“æ„) | âŒ è¿­ä»£è¿‡ç¨‹ä¸­å®¹å™¨ä¿®æ”¹å¯èƒ½å¯¼è‡´æœªå®šä¹‰è¡Œä¸º     |
| âœ… ç¬¦åˆå¼€é—­åŸåˆ™(å¯æ‰©å±•æ–°è¿­ä»£å™¨)     | âŒ æ€§èƒ½ç•¥ä½äºç›´æ¥è®¿é—®(å‡½æ•°è°ƒç”¨å¼€é”€)       |
| âœ… ç»Ÿä¸€è®¿é—®æ¥å£, å®¢æˆ·ç«¯ä»£ç æ›´ç®€æ´     |                                            |

------

âš ï¸ 4. æ³¨æ„äº‹é¡¹

1. **è¿­ä»£å™¨å¤±æ•ˆé—®é¢˜**: åœ¨éå†è¿‡ç¨‹ä¸­ä¿®æ”¹å®¹å™¨(å¦‚åˆ é™¤å…ƒç´ )å¯èƒ½å¯¼è‡´è¿­ä»£å™¨å¤±æ•ˆ â†’ è¡Œä¸ºæœªå®šä¹‰ï¼

2. **çº¿ç¨‹å®‰å…¨**: å¤šçº¿ç¨‹ä¸‹éå†+ä¿®æ”¹éœ€åŠ é”æˆ–ä½¿ç”¨å¹¶å‘å®‰å…¨å®¹å™¨ã€‚

3. **ç°ä»£C++å»ºè®®**: ä¼˜å…ˆä½¿ç”¨ STL çš„ `std::begin()`, `std::end()`, èŒƒå›´forå¾ªç¯ â†’ æ›´å®‰å…¨é«˜æ•ˆã€‚

4. è¿­ä»£å™¨åˆ†ç±»(C++ STL): 

   - è¾“å…¥/è¾“å‡ºè¿­ä»£å™¨
   - å‰å‘/åŒå‘/éšæœºè®¿é—®è¿­ä»£å™¨
   - æ ¹æ®å®¹å™¨èƒ½åŠ›æä¾›ä¸åŒèƒ½åŠ›è¿­ä»£å™¨
   
5. **é¿å…è¿‡åº¦è®¾è®¡**: ç®€å•å®¹å™¨ç›´æ¥ç”¨ç´¢å¼•æˆ–STLå³å¯, ä¸å¿…æ‰‹å†™è¿­ä»£å™¨ã€‚

ğŸ§  ä¸€å¥è¯æ€»ç»“è¿­ä»£å™¨æ¨¡å¼: 

> **â€œéå†ä¸é—®å‡ºå¤„, ç»Ÿä¸€æ¥å£èµ°è·¯ï¼›STLæ—©å·²å†…åµŒ, æ‰‹å†™åªä¸ºé¢†æ‚Ÿã€‚â€**

------

âœ… **ç»å…¸åº”ç”¨**: 

- C++ STL æ‰€æœ‰å®¹å™¨(`vector`, `list`, `map`...)çš„ `iterator`
- Java `Collection.iterator()`
- Python `__iter__()` / `__next__()`
- æ•°æ®åº“ç»“æœé›†éå†(ResultSet)

## ä»£ç 

æ‰‹å†™è¿­ä»£å™¨ + STLé£æ ¼æ¥å£

ğŸ¯ åœºæ™¯: å®ç°ä¸€ä¸ªâ€œä¹¦æ¶(BookShelf)â€å®¹å™¨, æ”¯æŒæ­£å‘éå†

```
#include <iostream>
#include <vector>
#include <memory>
#include <string>

// === èšåˆå…ƒç´  ===
class Book {
    std::string name;
public:
    Book(const std::string& n) : name(n) {}
    const std::string& getName() const { return name; }
};

// === æŠ½è±¡è¿­ä»£å™¨æ¥å£ ===
class Iterator {
public:
    virtual ~Iterator() = default;
    virtual bool hasNext() const = 0;
    virtual std::shared_ptr<Book> next() = 0;
};

// === å…·ä½“èšåˆç±»: ä¹¦æ¶ ===
class BookShelf {
    std::vector<std::shared_ptr<Book>> books;

public:
    void addBook(std::shared_ptr<Book> book) {
        books.push_back(book);
    }

    size_t size() const {
        return books.size();
    }

    // è·å–è¿­ä»£å™¨(STLé£æ ¼)
    class IteratorImpl : public Iterator {
        const BookShelf& shelf;
        size_t index = 0;

    public:
        IteratorImpl(const BookShelf& s) : shelf(s) {}

        bool hasNext() const override {
            return index < shelf.size();
        }

        std::shared_ptr<Book> next() override {
            if (!hasNext()) {
                throw std::out_of_range("No more books");
            }
            return shelf.books[index++];
        }
    };

    // STLé£æ ¼æ¥å£
    IteratorImpl begin() const {
        return IteratorImpl(*this);
    }

    IteratorImpl end() const {
        auto it = IteratorImpl(*this);
        it.index = size(); // æŒ‡å‘æœ«å°¾
        return it;
    }

    // ä¼ ç»Ÿæ¨¡å¼æ¥å£(å¯é€‰)
    std::unique_ptr<Iterator> createIterator() const {
        return std::make_unique<IteratorImpl>(*this);
    }
};

// === å®¢æˆ·ç«¯ä½¿ç”¨ ===
int main() {
    BookShelf shelf;
    shelf.addBook(std::make_shared<Book>("ã€Šè®¾è®¡æ¨¡å¼ã€‹"));
    shelf.addBook(std::make_shared<Book>("ã€ŠC++ Primerã€‹"));
    shelf.addBook(std::make_shared<Book>("ã€Šé‡æ„ã€‹"));

    std::cout << "=== ä¼ ç»Ÿè¿­ä»£å™¨æ¨¡å¼ ===\n";
    auto it = shelf.createIterator();
    while (it->hasNext()) {
        std::cout << "Book: " << it->next()->getName() << "\n";
    }

    std::cout << "\n=== STLé£æ ¼è¿­ä»£å™¨(æ¨è) ===\n";
    for (auto it = shelf.begin(); it.hasNext(); ) {
        std::cout << "Book: " << it.next()->getName() << "\n";
    }

    std::cout << "\n=== èŒƒå›´forå¾ªç¯(éœ€å®šä¹‰begin/endå…¨å±€å‡½æ•°)===\n";
    // æ³¨: è¦æ”¯æŒèŒƒå›´for, éœ€å®šä¹‰éæˆå‘˜ begin/end(æˆ–æˆå‘˜å‡½æ•°)
    // æ­¤å¤„ä¸ºæ¼”ç¤º, æ‰‹åŠ¨æ¨¡æ‹Ÿ: 
    auto b = shelf.begin();
    auto e = shelf.end();
    for (auto current = b; !(current.index == e.index); ) {
        std::cout << "Book: " << current.next()->getName() << "\n";
    }

    return 0;
}
```

## PlantUML

```
@startuml

' === èšåˆå…ƒç´ : Book ===
class Book {
    - name : std::string
    + getName() : const std::string&
}

' === æŠ½è±¡è¿­ä»£å™¨æ¥å£ ===
class Iterator {
    {abstract} + hasNext() : bool
    {abstract} + next() : std::shared_ptr<Book>
}

' === å…·ä½“èšåˆç±»: BookShelf ===
class BookShelf {
    - books : std::vector<std::shared_ptr<Book>>
    + addBook(book : std::shared_ptr<Book>)
    + size() : size_t
    + createIterator() : std::unique_ptr<Iterator>
    + begin() : IteratorImpl
    + end() : IteratorImpl
}

' === åµŒå¥—çš„å…·ä½“è¿­ä»£å™¨å®ç° ===
class BookShelf::IteratorImpl {
    - shelf : const BookShelf&
    - index : size_t
    + hasNext() : bool
    + next() : std::shared_ptr<Book>
}

' === å…³ç³» ===
BookShelf o-- "1..*" Book : contains
BookShelf --> Iterator : creates
BookShelf::IteratorImpl --|> Iterator : implements
BookShelf::IteratorImpl .. BookShelf : nested in
Iterator <|.. BookShelf::IteratorImpl : implements

' === å®¢æˆ·ç«¯(å¯é€‰ï¼Œç”¨äºè¯´æ˜ä½¿ç”¨å…³ç³»)===
class Client {
    note right
        ä½¿ç”¨ BookShelf å’Œ Iterator
        éå†ä¹¦ç±
    end note
}

Client --> BookShelf : uses
Client --> Iterator : uses

@enduml
```

![](./picture/17.IteratorPattern.png)


# 20.è´£ä»»é“¾æ¨¡å¼

## ç®€ä»‹

> â›“ï¸ C++ è´£ä»»é“¾æ¨¡å¼(Chain of Responsibility Pattern)
> **å°†è¯·æ±‚æ²¿ç€å¤„ç†è€…é“¾ä¼ é€’, ç›´åˆ°æœ‰ä¸€ä¸ªå¤„ç†è€…å¤„ç†å®ƒä¸ºæ­¢ã€‚**

------

ğŸ“Œ 1. ä»‹ç»

- **ç±»å‹**: è¡Œä¸ºå‹æ¨¡å¼

- æ ¸å¿ƒæ€æƒ³: 
  - å¤šä¸ªå¯¹è±¡**ç»„æˆä¸€æ¡é“¾**, æ¯ä¸ªå¯¹è±¡éƒ½æœ‰æœºä¼šå¤„ç†è¯·æ±‚ã€‚
  - è¯·æ±‚å‘é€è€…**æ— éœ€çŸ¥é“è°å¤„ç†**, åªéœ€å°†è¯·æ±‚å‘ç»™é“¾ä¸Šç¬¬ä¸€ä¸ªå¯¹è±¡ã€‚
  - å¯¹è±¡å¯**è‡ªè¡Œå†³å®šæ˜¯å¦å¤„ç† + æ˜¯å¦ä¼ é€’ç»™ä¸‹ä¸€ä¸ª**ã€‚

- **å…³é”®è¯**: é“¾å¼ä¼ é€’ã€è§£è€¦ã€åŠ¨æ€å¤„ç†ã€å®¡æ‰¹æµã€ä¸­é—´ä»¶

> ğŸ’¡ **ç±»æ¯”**: å…¬å¸è¯·å‡å®¡æ‰¹(ç»„é•¿â†’ç»ç†â†’æ€»ç›‘)ã€å¼‚å¸¸å¤„ç†(try-catch é“¾)ã€Web ä¸­é—´ä»¶(Express/Koa ä¸­é—´ä»¶)

------

ğŸ¯ 2. é€‚ç”¨åœºæ™¯

 âœ” å¤šä¸ªå¯¹è±¡å¯å¤„ç†åŒä¸€è¯·æ±‚, ä½†å…·ä½“ç”±è°å¤„ç†åœ¨è¿è¡Œæ—¶å†³å®š
 âœ” æƒ³åœ¨ä¸æ˜ç¡®æŒ‡å®šæ¥æ”¶è€…çš„æƒ…å†µä¸‹, å‘å¤šä¸ªå¯¹è±¡ä¸­çš„ä¸€ä¸ªæäº¤è¯·æ±‚
 âœ” è¯·æ±‚çš„å¤„ç†è€…é›†åˆåº”è¢«åŠ¨æ€æŒ‡å®šæˆ–æ‰©å±•
 âœ” å®ç°â€œå®¡æ‰¹æµç¨‹â€ã€â€œæ—¥å¿—è¿‡æ»¤â€ã€â€œæƒé™æ ¡éªŒâ€ã€â€œå¼‚å¸¸å¤„ç†â€ç­‰é“¾å¼ç»“æ„

------

âš–ï¸ 3. ä¼˜ç¼ºç‚¹

| ä¼˜ç‚¹                               | ç¼ºç‚¹                           |
| ---------------------------------- | ------------------------------ |
| âœ… é™ä½è¯·æ±‚å‘é€è€…ä¸æ¥æ”¶è€…è€¦åˆåº¦     | âŒ è¯·æ±‚å¯èƒ½æœªè¢«å¤„ç†(é“¾æ–­è£‚)   |
| âœ… å¢å¼ºçµæ´»æ€§: å¯åŠ¨æ€å¢åˆ èŠ‚ç‚¹       | âŒ æ€§èƒ½å¼€é”€: é“¾è¿‡é•¿æ—¶é€ä¸ªåˆ¤æ–­   |
| âœ… æ˜“äºæ‰©å±•æ–°å¤„ç†è€…(ç¬¦åˆå¼€é—­åŸåˆ™) | âŒ è°ƒè¯•å›°éš¾: è¯·æ±‚è·¯å¾„ä¸ç›´è§‚     |
| âœ… æ”¯æŒå¤šä¸ªå¯¹è±¡å¤„ç†åŒä¸€è¯·æ±‚(å¯é€‰) | âŒ é€’å½’æˆ–å¾ªç¯å¼•ç”¨å¯èƒ½å¯¼è‡´æ ˆæº¢å‡º |

------

âš ï¸ 4. æ³¨æ„äº‹é¡¹

1. **é¿å…æ— é™å¾ªç¯**: ç¡®ä¿é“¾æœ‰ç»ˆç‚¹(æœ€åä¸€ä¸ªèŠ‚ç‚¹è¦ä¹ˆå¤„ç†, è¦ä¹ˆæŠ›å¼‚å¸¸/æ—¥å¿—)ã€‚

2. **é»˜è®¤å…œåº•å¤„ç†è€…**: å»ºè®®é“¾å°¾è®¾ç½®â€œé»˜è®¤å¤„ç†å™¨â€æˆ–â€œæ—¥å¿—è®°å½•å™¨â€, é¿å…è¯·æ±‚æ— äººå¤„ç†ã€‚

3. **çº¿ç¨‹å®‰å…¨**: è‹¥é“¾ç»“æ„åŠ¨æ€å˜åŒ–(å¦‚å¤šçº¿ç¨‹å¢åˆ èŠ‚ç‚¹), éœ€åŠ é”æˆ–ä½¿ç”¨ä¸å¯å˜é“¾ã€‚

4. çº¯è´£ä»»é“¾ vs éçº¯è´£ä»»é“¾: 
   - **çº¯**: ä¸€ä¸ªå¯¹è±¡å¤„ç†å, **ä¸å†ä¼ é€’**(å¦‚å®¡æ‰¹é€šè¿‡å³ç»ˆæ­¢)
   - **éçº¯**: å¤„ç†å**ä»å¯ä¼ é€’**(å¦‚æ—¥å¿—è®°å½•+æƒé™æ ¡éªŒ+ä¸šåŠ¡å¤„ç†)

5. ç°ä»£C++å»ºè®®: 
   - å¯ç”¨ `std::vector<std::function<bool(Request&)>>` å®ç°è½»é‡çº§å‡½æ•°å¼è´£ä»»é“¾ã€‚
   - æˆ–ç”¨æ™ºèƒ½æŒ‡é’ˆç®¡ç†èŠ‚ç‚¹ç”Ÿå‘½å‘¨æœŸ(å¦‚ `std::unique_ptr<Handler>`)ã€‚

ğŸ§  ä¸€å¥è¯æ€»ç»“è´£ä»»é“¾æ¨¡å¼: 

> **â€œè¯·æ±‚è¿›é“¾, é€çº§åˆ¤æ–­ï¼›èƒ½è€…å¤„ç†, ä¸èƒ½åˆ™ä¼ ï¼›æ— äººæ¥æ‰‹, å…œåº•è¦è®¾ã€‚â€**

------

âœ… **ç»å…¸åº”ç”¨**: 

- Web æ¡†æ¶ä¸­é—´ä»¶(å¦‚ Express.jsã€Koa)
- æ—¥å¿—ç³»ç»Ÿ(ConsoleLogger â†’ FileLogger â†’ DBLogger)
- æƒé™æ ¡éªŒ(Tokenæ ¡éªŒ â†’ è§’è‰²æ ¡éªŒ â†’ æ“ä½œæƒé™æ ¡éªŒ)
- å¼‚å¸¸å¤„ç†(try-catch é“¾)
- æ¸¸æˆAIè¡Œä¸ºæ ‘(æ¡ä»¶åˆ¤æ–­é“¾)

## ä»£ç 

è¯·å‡å®¡æ‰¹æµç¨‹

ğŸ¯ åœºæ™¯: å‘˜å·¥è¯·å‡ â†’ ç»„é•¿ â†’ ç»ç† â†’ æ€»ç›‘ é€çº§å®¡æ‰¹

```
#include <iostream>
#include <memory>
#include <string>

// === è¯·æ±‚ç±»: è¯·å‡ç”³è¯· ===
struct LeaveRequest {
    std::string employee;
    int days;
    LeaveRequest(const std::string& emp, int d) : employee(emp), days(d) {}
};

// === æŠ½è±¡å¤„ç†è€… ===
class Handler {
protected:
    std::unique_ptr<Handler> nextHandler;

public:
    virtual ~Handler() = default;

    // è®¾ç½®ä¸‹ä¸€ä¸ªå¤„ç†å™¨
    void setNext(std::unique_ptr<Handler> next) {
        nextHandler = std::move(next);
    }

    // å¤„ç†è¯·æ±‚(æ¨¡æ¿æ–¹æ³•)
    virtual void handleRequest(const LeaveRequest& request) {
        if (canHandle(request)) {
            doHandle(request);
        } else if (nextHandler) {
            std::cout << getName() << " æ— æƒå¤„ç†, è½¬äº¤ä¸‹ä¸€çº§...\n";
            nextHandler->handleRequest(request);
        } else {
            std::cout << "âš ï¸  æ‰€æœ‰ä¸Šçº§å‡æ— æ³•å¤„ç†æ­¤è¯·å‡ç”³è¯·ï¼\n";
        }
    }

protected:
    virtual std::string getName() const = 0;
    virtual bool canHandle(const LeaveRequest& request) const = 0;
    virtual void doHandle(const LeaveRequest& request) = 0;
};

// === å…·ä½“å¤„ç†è€…: ç»„é•¿ ===
class TeamLeader : public Handler {
protected:
    std::string getName() const override { return "ç»„é•¿"; }
    bool canHandle(const LeaveRequest& request) const override {
        return request.days <= 1;
    }
    void doHandle(const LeaveRequest& request) override {
        std::cout << "âœ… ç»„é•¿æ‰¹å‡†äº† " << request.employee << " çš„ " << request.days << " å¤©å‡æœŸã€‚\n";
    }
};

// === å…·ä½“å¤„ç†è€…: ç»ç† ===
class Manager : public Handler {
protected:
    std::string getName() const override { return "ç»ç†"; }
    bool canHandle(const LeaveRequest& request) const override {
        return request.days <= 3;
    }
    void doHandle(const LeaveRequest& request) override {
        std::cout << "âœ… ç»ç†æ‰¹å‡†äº† " << request.employee << " çš„ " << request.days << " å¤©å‡æœŸã€‚\n";
    }
};

// === å…·ä½“å¤„ç†è€…: æ€»ç›‘ ===
class Director : public Handler {
protected:
    std::string getName() const override { return "æ€»ç›‘"; }
    bool canHandle(const LeaveRequest& request) const override {
        return request.days <= 7; // æœ€é«˜æ‰¹7å¤©
    }
    void doHandle(const LeaveRequest& request) override {
        std::cout << "âœ… æ€»ç›‘æ‰¹å‡†äº† " << request.employee << " çš„ " << request.days << " å¤©å‡æœŸã€‚\n";
    }
};

// === å®¢æˆ·ç«¯ä½¿ç”¨ ===
int main() {
    // æ„å»ºè´£ä»»é“¾: ç»„é•¿ â†’ ç»ç† â†’ æ€»ç›‘
    auto leader = std::make_unique<TeamLeader>();
    auto manager = std::make_unique<Manager>();
    auto director = std::make_unique<Director>();

    leader->setNext(std::move(manager));
    leader->nextHandler->setNext(std::move(director)); // æ³¨æ„: managerå·²è¢«move, åªèƒ½é€šè¿‡nextè®¿é—®

    // å‘èµ·è¯·æ±‚
    std::cout << "=== è¯·å‡1å¤© ===\n";
    leader->handleRequest(LeaveRequest("å¼ ä¸‰", 1));

    std::cout << "\n=== è¯·å‡3å¤© ===\n";
    leader->handleRequest(LeaveRequest("æå››", 3));

    std::cout << "\n=== è¯·å‡5å¤© ===\n";
    leader->handleRequest(LeaveRequest("ç‹äº”", 5));

    std::cout << "\n=== è¯·å‡10å¤© ===\n";
    leader->handleRequest(LeaveRequest("èµµå…­", 10));

    return 0;
}
```

## PlantUML

```
@startuml
title Chain of Responsibility Pattern

class Handler {
    -nextHandler: Handler*
    +setNext(Handler*)
    +handleRequest(request)
    {abstract} +canHandle(request) : bool
    {abstract} +doHandle(request)
    {abstract} +getName() : string
}

class TeamLeader {
    +canHandle() : bool
    +doHandle()
    +getName() : string
}

class Manager {
    +canHandle() : bool
    +doHandle()
    +getName() : string
}

class Director {
    +canHandle() : bool
    +doHandle()
    +getName() : string
}

class LeaveRequest {
    -employee: string
    -days: int
}

class Client

Handler <|-- TeamLeader
Handler <|-- Manager
Handler <|-- Director

Handler "0..1" --> "0..1" Handler : nextHandler

Client --> Handler : sends request
Client --> LeaveRequest : creates

note right of Handler
  æŠ½è±¡å¤„ç†è€…
  æŒæœ‰ä¸‹ä¸€ä¸ªå¤„ç†å™¨æŒ‡é’ˆ
  æ¨¡æ¿æ–¹æ³•handleRequest
end note

note right of TeamLeader
  å¤„ç† <=1 å¤©å‡æœŸ
end note

@enduml
```
![](./picture/18.ChainOfResponsibilityPattern.png)


# 21.å‘½ä»¤æ¨¡å¼

## ç®€ä»‹

> ğŸ“œ å‘½ä»¤æ¨¡å¼(Command Pattern)
> **å°†â€œè¯·æ±‚â€å°è£…ä¸ºå¯¹è±¡, ä»è€Œä½¿ä½ å¯ä»¥ç”¨ä¸åŒçš„è¯·æ±‚å¯¹å®¢æˆ·è¿›è¡Œå‚æ•°åŒ–ã€æ’é˜Ÿã€è®°å½•æ—¥å¿—, ä»¥åŠæ”¯æŒå¯æ’¤é”€çš„æ“ä½œã€‚**

------

ğŸ“Œ 1. ä»‹ç»

- **ç±»å‹**: è¡Œä¸ºå‹æ¨¡å¼

- æ ¸å¿ƒæ€æƒ³
  - å°†**ä¸€ä¸ªæ“ä½œ(æ–¹æ³•è°ƒç”¨)å°è£…æˆå¯¹è±¡** â†’ å³â€œå‘½ä»¤å¯¹è±¡â€ã€‚
  - è°ƒç”¨è€…(Invoker)ä¸æ¥æ”¶è€…(Receiver)**è§£è€¦** â†’ é€šè¿‡å‘½ä»¤å¯¹è±¡é€šä¿¡ã€‚
  - æ”¯æŒ**æ’¤é”€(Undo)ã€é‡åš(Redo)ã€é˜Ÿåˆ—ã€æ—¥å¿—ã€äº‹åŠ¡**ç­‰é«˜çº§åŠŸèƒ½ã€‚

- **å…³é”®è¯**: è¯·æ±‚å°è£…ã€è§£è€¦ã€æ’¤é”€ã€é˜Ÿåˆ—ã€å®å‘½ä»¤

> ğŸ’¡ **ç±»æ¯”**: é¥æ§å™¨æŒ‰é’®(å‘½ä»¤å¯¹è±¡)â†’ æ§åˆ¶ç”µè§†(æ¥æ”¶è€…)ï¼›é¤å…ç‚¹é¤(å‘½ä»¤)â†’ å¨å¸ˆ(æ¥æ”¶è€…)æ‰§è¡Œã€‚

------

ğŸ¯ 2. é€‚ç”¨åœºæ™¯

 âœ” éœ€è¦å‚æ•°åŒ–å¯¹è±¡æ“ä½œ(å¦‚å›è°ƒã€äº‹ä»¶å¤„ç†)
 âœ” éœ€è¦æ”¯æŒæ’¤é”€/é‡åšåŠŸèƒ½(å¦‚ç¼–è¾‘å™¨ã€æ¸¸æˆ)
 âœ” éœ€è¦å°†æ“ä½œæ’é˜Ÿæˆ–è®°å½•æ—¥å¿—(å¦‚ä»»åŠ¡é˜Ÿåˆ—ã€äº‹åŠ¡)
 âœ” éœ€è¦å°†è¯·æ±‚å‘é€è€…ä¸æ¥æ”¶è€…è§£è€¦(å¦‚GUIæŒ‰é’®ç»‘å®šä¸åŒæ“ä½œ)
 âœ” å®ç°â€œå®å‘½ä»¤â€æˆ–â€œæ‰¹é‡æ“ä½œâ€

------

âš–ï¸ 3. ä¼˜ç¼ºç‚¹

| ä¼˜ç‚¹                             | ç¼ºç‚¹                                                  |
| -------------------------------- | ----------------------------------------------------- |
| âœ… è§£è€¦è°ƒç”¨è€…ä¸æ¥æ”¶è€…             | âŒ ç±»çˆ†ç‚¸: æ¯ä¸ªå‘½ä»¤ä¸€ä¸ªç±»(å¯ç”¨ `std::function` ç¼“è§£) |
| âœ… æ”¯æŒæ’¤é”€ã€é‡åšã€æ—¥å¿—ã€é˜Ÿåˆ—     | âŒ å¢åŠ ç³»ç»Ÿå¤æ‚åº¦(å°ç³»ç»Ÿå¯èƒ½è¿‡åº¦è®¾è®¡)                |
| âœ… æ˜“äºæ‰©å±•æ–°å‘½ä»¤(ç¬¦åˆå¼€é—­åŸåˆ™) | âŒ å†…å­˜å¼€é”€: å‘½ä»¤å¯¹è±¡éœ€ä¿å­˜çŠ¶æ€ç”¨äºæ’¤é”€                |
| âœ… æ”¯æŒç»„åˆå‘½ä»¤(å®å‘½ä»¤)         |                                                       |

------

âš ï¸ 4. æ³¨æ„äº‹é¡¹

1. æ’¤é”€çŠ¶æ€ä¿å­˜
   - ç®€å•å‘½ä»¤: ä¿å­˜æ‰§è¡Œå‰çŠ¶æ€(å¤‡å¿˜å½•æ¨¡å¼é…åˆ)
   - å¤æ‚å‘½ä»¤: è®°å½•åå‘æ“ä½œ(å¦‚â€œç§»åŠ¨â†’åå‘ç§»åŠ¨â€)

2. çº¿ç¨‹å®‰å…¨
   - å‘½ä»¤é˜Ÿåˆ—å¤šçº¿ç¨‹æ¶ˆè´¹æ—¶éœ€åŠ é”
   - æ’¤é”€æ ˆéœ€è€ƒè™‘å¹¶å‘è®¿é—®

3. ç°ä»£C++å»ºè®®
   - å¯ç”¨ `std::function<void()>` + Lambda å®ç°è½»é‡å‘½ä»¤, é¿å…ç±»çˆ†ç‚¸ã€‚
   - ç”¨ `std::unique_ptr<Command>` ç®¡ç†å‘½ä»¤ç”Ÿå‘½å‘¨æœŸã€‚

4. å‘½ä»¤ vs å‡½æ•°å¯¹è±¡
   - å‘½ä»¤æ¨¡å¼æ›´å¼ºè°ƒâ€œç»“æ„åŒ–å°è£… + å¯æ’¤é”€ + å¯è®°å½•â€
   - å‡½æ•°å¯¹è±¡(Functor)æ›´è½»é‡, é€‚åˆæ— çŠ¶æ€å›è°ƒ

5. **é¿å…è¿‡åº¦è®¾è®¡**: ç®€å•å›è°ƒç›´æ¥ç”¨å‡½æ•°æŒ‡é’ˆæˆ–Lambdaå³å¯ã€‚

ğŸ§  ä¸€å¥è¯æ€»ç»“å‘½ä»¤æ¨¡å¼: 

> **â€œè¯·æ±‚å°è£…æˆå¯¹è±¡, è°ƒç”¨æ¥æ”¶ä¸¤ä¸æ„ï¼›æ’¤é”€é‡åšæ’é˜Ÿèµ°, å®å‘½ä»¤ä¹Ÿä¸æ„ã€‚â€**

------

âœ… **ç»å…¸åº”ç”¨**: 

- GUI æŒ‰é’®/èœå•å‘½ä»¤(Qtã€MFC)
- ç¼–è¾‘å™¨æ’¤é”€/é‡åš(Ctrl+Z / Ctrl+Y)
- æ¸¸æˆæŠ€èƒ½/é“å…·ç³»ç»Ÿ
- ä»»åŠ¡è°ƒåº¦ç³»ç»Ÿ(æ”¯æŒæš‚åœã€å–æ¶ˆã€é‡è¯•)
- æ•°æ®åº“äº‹åŠ¡(commit / rollback)

## ä»£ç 

æ™ºèƒ½å®¶å±…é¥æ§å™¨ + æ’¤é”€åŠŸèƒ½

ğŸ¯ åœºæ™¯: é¥æ§å™¨æ§åˆ¶ç¯ã€éŸ³å“ï¼›æ”¯æŒæ’¤é”€ä¸Šä¸€æ¡å‘½ä»¤

```
#include <iostream>
#include <memory>
#include <vector>
#include <stack>

// === æŠ½è±¡å‘½ä»¤æ¥å£ ===
class Command {
public:
    virtual ~Command() = default;
    virtual void execute() = 0;
    virtual void undo() = 0; // æ”¯æŒæ’¤é”€
};

// === æ¥æ”¶è€…: ç¯ ===
class Light {
    std::string location;
    bool isOn = false;

public:
    Light(const std::string& loc) : location(loc) {}

    void on() {
        isOn = true;
        std::cout << location << " ç¯å·²æ‰“å¼€\n";
    }

    void off() {
        isOn = false;
        std::cout << location << " ç¯å·²å…³é—­\n";
    }

    bool getState() const { return isOn; }
};

// === æ¥æ”¶è€…: éŸ³å“ ===
class Stereo {
    std::string location;
    int volume = 0;

public:
    Stereo(const std::string& loc) : location(loc) {}

    void on() {
        std::cout << location << " éŸ³å“å·²æ‰“å¼€\n";
    }

    void off() {
        std::cout << location << " éŸ³å“å·²å…³é—­\n";
    }

    void setVolume(int vol) {
        volume = vol;
        std::cout << location << " éŸ³é‡è®¾ä¸º " << volume << "\n";
    }

    int getVolume() const { return volume; }
};

// === å…·ä½“å‘½ä»¤: å¼€ç¯ ===
class LightOnCommand : public Command {
    Light& light;
    bool prevState; // ç”¨äºæ’¤é”€

public:
    LightOnCommand(Light& l) : light(l), prevState(l.getState()) {}

    void execute() override {
        prevState = light.getState(); // ä¿å­˜æ‰§è¡Œå‰çŠ¶æ€
        light.on();
    }

    void undo() override {
        if (prevState) {
            light.on();
        } else {
            light.off();
        }
    }
};

// === å…·ä½“å‘½ä»¤: å…³ç¯ ===
class LightOffCommand : public Command {
    Light& light;
    bool prevState;

public:
    LightOffCommand(Light& l) : light(l), prevState(l.getState()) {}

    void execute() override {
        prevState = light.getState();
        light.off();
    }

    void undo() override {
        if (prevState) {
            light.on();
        } else {
            light.off();
        }
    }
};

// === å…·ä½“å‘½ä»¤: è®¾ç½®éŸ³é‡ ===
class StereoSetVolumeCommand : public Command {
    Stereo& stereo;
    int prevVolume;

public:
    StereoSetVolumeCommand(Stereo& s, int vol) : stereo(s), prevVolume(s.getVolume()) {
        targetVolume = vol;
    }

private:
    int targetVolume;

public:
    void execute() override {
        prevVolume = stereo.getVolume();
        stereo.setVolume(targetVolume);
    }

    void undo() override {
        stereo.setVolume(prevVolume);
    }
};

// === è°ƒç”¨è€…: é¥æ§å™¨ ===
class RemoteControl {
    std::vector<std::unique_ptr<Command>> onCommands;
    std::vector<std::unique_ptr<Command>> offCommands;
    std::stack<Command*> commandHistory; // æ’¤é”€å†å²
    static const int NUM_SLOTS = 3;

public:
    RemoteControl() {
        onCommands.resize(NUM_SLOTS);
        offCommands.resize(NUM_SLOTS);
    }

    void setCommand(int slot, std::unique_ptr<Command> onCmd, std::unique_ptr<Command> offCmd) {
        onCommands[slot] = std::move(onCmd);
        offCommands[slot] = std::move(offCmd);
    }

    void pressOnButton(int slot) {
        if (slot < onCommands.size() && onCommands[slot]) {
            onCommands[slot]->execute();
            commandHistory.push(onCommands[slot].get());
        }
    }

    void pressOffButton(int slot) {
        if (slot < offCommands.size() && offCommands[slot]) {
            offCommands[slot]->execute();
            commandHistory.push(offCommands[slot].get());
        }
    }

    void pressUndo() {
        if (!commandHistory.empty()) {
            std::cout << "â†©ï¸  æ­£åœ¨æ’¤é”€...\n";
            commandHistory.top()->undo();
            commandHistory.pop();
        } else {
            std::cout << "âš ï¸  æ— æ“ä½œå¯æ’¤é”€\n";
        }
    }
};

// === å®¢æˆ·ç«¯ä½¿ç”¨ ===
int main() {
    RemoteControl remote;

    Light livingRoomLight("å®¢å…");
    Light kitchenLight("å¨æˆ¿");
    Stereo stereo("å®¢å…");

    // è®¾ç½®å‘½ä»¤
    remote.setCommand(0,
        std::make_unique<LightOnCommand>(livingRoomLight),
        std::make_unique<LightOffCommand>(livingRoomLight)
    );

    remote.setCommand(1,
        std::make_unique<LightOnCommand>(kitchenLight),
        std::make_unique<LightOffCommand>(kitchenLight)
    );

    remote.setCommand(2,
        std::make_unique<StereoSetVolumeCommand>(stereo, 11),
        std::make_unique<StereoSetVolumeCommand>(stereo, 0)
    );

    std::cout << "=== æµ‹è¯•æ“ä½œ ===\n";
    remote.pressOnButton(0); // å¼€å®¢å…ç¯
    remote.pressOnButton(2); // éŸ³å“éŸ³é‡11
    remote.pressOffButton(1); // å…³å¨æˆ¿ç¯

    std::cout << "\n=== æ’¤é”€æ“ä½œ ===\n";
    remote.pressUndo(); // æ’¤é”€å…³å¨æˆ¿ç¯ â†’ å¼€å¨æˆ¿ç¯
    remote.pressUndo(); // æ’¤é”€éŸ³å“éŸ³é‡11 â†’ æ¢å¤åŸéŸ³é‡
    remote.pressUndo(); // æ’¤é”€å¼€å®¢å…ç¯ â†’ å…³å®¢å…ç¯

    std::cout << "\n=== å†æ¬¡æ’¤é”€(åº”æ— æ“ä½œ)===\n";
    remote.pressUndo();

    return 0;
}
```

è¾“å‡º

```
=== æµ‹è¯•æ“ä½œ ===
å®¢å… ç¯å·²æ‰“å¼€
å®¢å… éŸ³é‡è®¾ä¸º 11
å¨æˆ¿ ç¯å·²å…³é—­

=== æ’¤é”€æ“ä½œ ===
â†©ï¸  æ­£åœ¨æ’¤é”€...
å¨æˆ¿ ç¯å·²æ‰“å¼€
â†©ï¸  æ­£åœ¨æ’¤é”€...
å®¢å… éŸ³é‡è®¾ä¸º 0
â†©ï¸  æ­£åœ¨æ’¤é”€...
å®¢å… ç¯å·²å…³é—­

=== å†æ¬¡æ’¤é”€(åº”æ— æ“ä½œ)===
âš ï¸  æ— æ“ä½œå¯æ’¤é”€
```

## PlantUML

```
@startuml
title Command Pattern

interface Command {
    +execute()
    +undo()
}

class Light {
    -location: string
    -isOn: bool
    +on()
    +off()
    +getState() : bool
}

class Stereo {
    -location: string
    -volume: int
    +on()
    +off()
    +setVolume(int)
    +getVolume() : int
}

class LightOnCommand {
    -light: Light&
    -prevState: bool
    +execute()
    +undo()
}

class LightOffCommand {
    -light: Light&
    -prevState: bool
    +execute()
    +undo()
}

class StereoSetVolumeCommand {
    -stereo: Stereo&
    -prevVolume: int
    -targetVolume: int
    +execute()
    +undo()
}

class RemoteControl {
    -onCommands: vector<Command*>
    -offCommands: vector<Command*>
    -commandHistory: stack<Command*>
    +setCommand(slot, onCmd, offCmd)
    +pressOnButton(slot)
    +pressOffButton(slot)
    +pressUndo()
}

class Client

Command <|.. LightOnCommand
Command <|.. LightOffCommand
Command <|.. StereoSetVolumeCommand

LightOnCommand --> Light
LightOffCommand --> Light
StereoSetVolumeCommand --> Stereo

RemoteControl --> Command : holds

Client --> RemoteControl : uses
Client --> Light : creates
Client --> Stereo : creates

note right of Command
  å°è£…ä¸€ä¸ªè¯·æ±‚ä¸ºå¯¹è±¡
  æ”¯æŒexecute/undo
end note

note right of RemoteControl
  è°ƒç”¨è€…Invoker
  æŒæœ‰å‘½ä»¤å¯¹è±¡
  æ”¯æŒæ’¤é”€å†å²
end note

@enduml
```

![](./picture/19.CommandPattern.png)


# 22.å¤‡å¿˜å½•æ¨¡å¼

## ç®€ä»‹

> ğŸ“¸ å¤‡å¿˜å½•æ¨¡å¼(Memento Pattern)
> **åœ¨ä¸ç ´åå°è£…æ€§çš„å‰æä¸‹, æ•è·ä¸€ä¸ªå¯¹è±¡çš„å†…éƒ¨çŠ¶æ€, å¹¶åœ¨è¯¥å¯¹è±¡ä¹‹å¤–ä¿å­˜è¿™ä¸ªçŠ¶æ€, ä»¥ä¾¿ä»¥åå¯å°†è¯¥å¯¹è±¡æ¢å¤åˆ°åŸå…ˆä¿å­˜çš„çŠ¶æ€ã€‚**

------

ğŸ“Œ 1. ä»‹ç»

- **ç±»å‹**: è¡Œä¸ºå‹æ¨¡å¼

- æ ¸å¿ƒè§’è‰²
  - **Originator(åŸå‘å™¨)**: è¦è¢«ä¿å­˜/æ¢å¤çŠ¶æ€çš„å¯¹è±¡ã€‚
  - **Memento(å¤‡å¿˜å½•)**: å­˜å‚¨ Originator çš„å†…éƒ¨çŠ¶æ€(é€šå¸¸ä¸ºç§æœ‰æˆ–å—é™è®¿é—®)ã€‚
  - **Caretaker(è´Ÿè´£äºº)**: è´Ÿè´£ä¿å­˜å’Œç®¡ç† Memento, ä½†**ä¸èƒ½ä¿®æ”¹æˆ–æŸ¥çœ‹å…¶å†…å®¹**ã€‚

- **å…³é”®è¯**: çŠ¶æ€å¿«ç…§ã€æ’¤é”€æ¢å¤ã€æ¸¸æˆå­˜æ¡£ã€å°è£…æ€§

> ğŸ’¡ **ç±»æ¯”**: æ¸¸æˆâ€œå­˜æ¡£/è¯»æ¡£â€ã€ç¼–è¾‘å™¨â€œæ’¤é”€å†å²â€ã€æ•°æ®åº“â€œäº‹åŠ¡å›æ»šç‚¹â€ã€‚

------

ğŸ¯ 2. é€‚ç”¨åœºæ™¯

 âœ” éœ€è¦ä¿å­˜å¯¹è±¡åœ¨æŸä¸€æ—¶åˆ»çš„çŠ¶æ€, ä»¥ä¾¿åç»­æ¢å¤(å¦‚æ’¤é”€æ“ä½œ)
 âœ” ä¸å¸Œæœ›æš´éœ²å¯¹è±¡å†…éƒ¨ç»†èŠ‚, ä½†åˆè¦å¤–éƒ¨ä¿å­˜å…¶çŠ¶æ€
 âœ” å®ç°â€œæ£€æŸ¥ç‚¹â€ã€â€œå†å²å¿«ç…§â€ã€â€œäº‹åŠ¡å›æ»šâ€åŠŸèƒ½
 âœ” ä¸**å‘½ä»¤æ¨¡å¼**é…åˆå®ç°å¤šçº§æ’¤é”€(æ¯ä¸ªå‘½ä»¤ä¿å­˜ä¸€ä¸ªå¤‡å¿˜å½•)

------

âš–ï¸ 3. ä¼˜ç¼ºç‚¹

| ä¼˜ç‚¹                                          | ç¼ºç‚¹                                       |
| --------------------------------------------- | ------------------------------------------ |
| âœ… ä¿æŒå°è£…æ€§: çŠ¶æ€ç”± Originator è‡ªå·±ç®¡ç†      | âŒ å†…å­˜å¼€é”€å¤§: ä¿å­˜å¤šä¸ªå¿«ç…§å¯èƒ½å ç”¨å¤§é‡å†…å­˜ |
| âœ… æ”¯æŒæ’¤é”€ã€æ¢å¤ã€å†å²ç‰ˆæœ¬                    | âŒ å¤æ‚å¯¹è±¡åºåˆ—åŒ–å›°éš¾(éœ€æ·±æ‹·è´)           |
| âœ… ç®€åŒ– Originator èŒè´£: çŠ¶æ€ä¿å­˜/æ¢å¤é€»è¾‘åˆ†ç¦» | âŒ é¢‘ç¹ä¿å­˜å½±å“æ€§èƒ½                         |
| âœ… æ˜“äºæ‰©å±•: å¯é…åˆå‘½ä»¤æ¨¡å¼å®ç°å¤šçº§æ’¤é”€        |                                            |

------

âš ï¸ 4. æ³¨æ„äº‹é¡¹

1. æ·±æ‹·è´ vs æµ…æ‹·è´
   - è‹¥ Originator åŒ…å«æŒ‡é’ˆæˆ–åŠ¨æ€èµ„æº, Memento **å¿…é¡»æ·±æ‹·è´**, å¦åˆ™æ¢å¤æ—¶å¯èƒ½æ‚¬ç©ºæˆ–å†²çªã€‚

2. å†…å­˜ç®¡ç†
   - é¿å…æ— é™åˆ¶ä¿å­˜å¿«ç…§ â†’ å¯è®¾ç½®æœ€å¤§å†å²æ•°æˆ–è‡ªåŠ¨æ¸…ç†ã€‚
   - ç”¨ `std::unique_ptr<Memento>` æˆ– `std::vector<Memento>` ç®¡ç†ç”Ÿå‘½å‘¨æœŸã€‚

3. å°è£…æ€§ä¿æŠ¤
   - Memento ç±»åº”**ä»…å…è®¸ Originator è®¿é—®å…¶å†…éƒ¨æ•°æ®**(C++ ä¸­å¯ç”¨ `friend` ç±»æˆ–åµŒå¥—ç±»å®ç°)ã€‚

4. ç°ä»£C++å»ºè®®
   - å¯ç”¨ `std::any`ã€`std::variant` æˆ–åºåˆ—åŒ–åº“(å¦‚ nlohmann/json)å®ç°é€šç”¨ Mementoã€‚
   - å¯¹ç®€å•çŠ¶æ€, å¯ç”¨ `std::tuple` æˆ–ç»“æ„ä½“ç›´æ¥ä¿å­˜ã€‚

5. å¯¹æ¯”å‘½ä»¤æ¨¡å¼æ’¤é”€
   - **å‘½ä»¤æ¨¡å¼**: è®°å½•â€œæ“ä½œ+åå‘æ“ä½œâ€ â†’ è½»é‡, é€‚åˆç®€å•æ’¤é”€
   - **å¤‡å¿˜å½•æ¨¡å¼**: è®°å½•â€œå®Œæ•´çŠ¶æ€å¿«ç…§â€ â†’ é‡é‡, é€‚åˆå¤æ‚çŠ¶æ€æ¢å¤

ğŸ§  ä¸€å¥è¯æ€»ç»“å¤‡å¿˜å½•æ¨¡å¼: 

> **â€œçŠ¶æ€å¿«ç…§å­˜å¤–éƒ¨, æ¢å¤åŸçŠ¶ä¸æš´éœ²ï¼›å°è£…å®Œæ•´æ˜¯æ ¸å¿ƒ, å†…å­˜ä»£ä»·è¦è®¤é¢†ã€‚â€**

------

âœ… **ç»å…¸åº”ç”¨**: 

- æ¸¸æˆå­˜æ¡£/è¯»æ¡£ç³»ç»Ÿ
- ç¼–è¾‘å™¨å¤šçº§æ’¤é”€(å¦‚ Photoshop å†å²é¢æ¿)
- æ•°æ®åº“äº‹åŠ¡ä¿å­˜ç‚¹(SAVEPOINT)
- è™šæ‹Ÿæœºå¿«ç…§
- é…ç½®å›æ»šç³»ç»Ÿ

## ä»£ç 

æ–‡æœ¬ç¼–è¾‘å™¨ + å¤šçº§æ’¤é”€

ğŸ¯ åœºæ™¯: æ–‡æœ¬ç¼–è¾‘å™¨æ”¯æŒä¿å­˜å†å²çŠ¶æ€, å¯æ’¤é”€åˆ°ä»»æ„å†å²ç‰ˆæœ¬

```
#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <stack>

// === Originator: æ–‡æœ¬ç¼–è¾‘å™¨ ===
class TextEditor {
    std::string content;

public:
    void type(const std::string& text) {
        content += text;
    }

    void erase(size_t len) {
        if (len <= content.length()) {
            content.erase(content.length() - len);
        }
    }

    std::string getContent() const {
        return content;
    }

    // === Memento: åµŒå¥—ç±», ä»… TextEditor å¯è®¿é—®å†…éƒ¨ ===
    class Memento {
        std::string state;
        friend class TextEditor; // å…³é”®: åªæœ‰ TextEditor èƒ½è¯»å†™ state

        Memento(const std::string& s) : state(s) {}
    public:
        // å¯¹ Caretaker æš´éœ²åªè¯»æ¥å£(å¯é€‰)
        std::string getStateSnapshot() const { return state; }
    };

    // ä¿å­˜å½“å‰çŠ¶æ€
    std::unique_ptr<Memento> save() const {
        return std::make_unique<Memento>(content);
    }

    // æ¢å¤åˆ°æŒ‡å®šçŠ¶æ€
    void restore(const Memento& memento) {
        content = memento.state;
    }
};

// === Caretaker: å†å²ç®¡ç†å™¨ ===
class History {
    std::stack<std::unique_ptr<TextEditor::Memento>> snapshots;

public:
    void push(std::unique_ptr<TextEditor::Memento> memento) {
        snapshots.push(std::move(memento));
    }

    std::unique_ptr<TextEditor::Memento> pop() {
        if (snapshots.empty()) return nullptr;
        auto memento = std::move(snapshots.top());
        snapshots.pop();
        return memento;
    }

    bool isEmpty() const {
        return snapshots.empty();
    }
};

// === å®¢æˆ·ç«¯ä½¿ç”¨ ===
int main() {
    TextEditor editor;
    History history;

    auto saveSnapshot = [&]() {
        history.push(editor.save());
        std::cout << "ğŸ’¾ ä¿å­˜å¿«ç…§: \"" << editor.getContent() << "\"\n";
    };

    auto undo = [&]() {
        auto memento = history.pop();
        if (memento) {
            editor.restore(*memento);
            std::cout << "â†©ï¸  æ’¤é”€åˆ°: \"" << editor.getContent() << "\"\n";
        } else {
            std::cout << "âš ï¸  æ— å†å²è®°å½•å¯æ¢å¤\n";
        }
    };

    std::cout << "=== å¼€å§‹ç¼–è¾‘ ===\n";
    editor.type("Hello");
    saveSnapshot();

    editor.type(", World!");
    saveSnapshot();

    editor.type(" How are you?");
    saveSnapshot();

    std::cout << "\n=== å½“å‰å†…å®¹: \"" << editor.getContent() << "\"\n";

    std::cout << "\n=== æ‰§è¡Œæ’¤é”€ ===\n";
    undo(); // æ’¤é”€ " How are you?"
    undo(); // æ’¤é”€ ", World!"

    std::cout << "\n=== å†æ¬¡è¾“å…¥ ===\n";
    editor.type(" C++ Programmer!");
    saveSnapshot();

    std::cout << "\n=== æœ€ç»ˆå†…å®¹: \"" << editor.getContent() << "\"\n";

    return 0;
}
```

```
=== å¼€å§‹ç¼–è¾‘ ===
ğŸ’¾ ä¿å­˜å¿«ç…§: "Hello"
ğŸ’¾ ä¿å­˜å¿«ç…§: "Hello, World!"
ğŸ’¾ ä¿å­˜å¿«ç…§: "Hello, World! How are you?"

=== å½“å‰å†…å®¹: "Hello, World! How are you?"

=== æ‰§è¡Œæ’¤é”€ ===
â†©ï¸  æ’¤é”€åˆ°: "Hello, World!"
â†©ï¸  æ’¤é”€åˆ°: "Hello"

=== å†æ¬¡è¾“å…¥ ===
ğŸ’¾ ä¿å­˜å¿«ç…§: "Hello C++ Programmer!"

=== æœ€ç»ˆå†…å®¹: "Hello C++ Programmer!"
```

## PlantUML

```
@startuml
title Memento Pattern

class TextEditor {
    -content: string
    +type(text)
    +erase(len)
    +getContent() : string
    +save() : Memento*
    +restore(memento)
}

class TextEditor.Memento {
    -state: string
    +getStateSnapshot() : string
}

class History {
    -snapshots: stack<Memento*>
    +push(memento)
    +pop() : Memento*
    +isEmpty() : bool
}

class Client

TextEditor +-- Memento : creates
TextEditor --> Memento : restores from
History --> Memento : holds (cannot modify)
Client --> TextEditor : uses
Client --> History : manages snapshots

note right of TextEditor.Memento
  ä»…TextEditorå¯è®¿é—®å†…éƒ¨state
  ä¿æŠ¤å°è£…æ€§
end note

note right of History
  Caretakerè§’è‰²
  ä»…ä¿å­˜/å¼¹å‡º, ä¸ä¿®æ”¹å†…å®¹
end note

@enduml
```

![](./picture/20.MementoPattern.png)


# 23.çŠ¶æ€æ¨¡å¼

## ç®€ä»‹

> ğŸ”„ çŠ¶æ€æ¨¡å¼(State Pattern)
> **å…è®¸å¯¹è±¡åœ¨å…¶å†…éƒ¨çŠ¶æ€æ”¹å˜æ—¶æ”¹å˜å…¶è¡Œä¸º, å¯¹è±¡çœ‹èµ·æ¥ä¼¼ä¹ä¿®æ”¹äº†å®ƒçš„ç±»ã€‚**

------

ğŸ“Œ 1. ä»‹ç»

- **ç±»å‹**: è¡Œä¸ºå‹æ¨¡å¼

- æ ¸å¿ƒæ€æƒ³
  - å°†**å¯¹è±¡çš„è¡Œä¸ºå°è£…åˆ°ä¸åŒçš„â€œçŠ¶æ€ç±»â€ä¸­**ã€‚
  - å¯¹è±¡(Context)**æŒæœ‰å½“å‰çŠ¶æ€å¯¹è±¡**, è¡Œä¸ºå§”æ‰˜ç»™å½“å‰çŠ¶æ€å¤„ç†ã€‚
  - **çŠ¶æ€è½¬æ¢ç”±çŠ¶æ€ç±»è‡ªèº«æˆ– Context æ§åˆ¶** â†’ è¡Œä¸ºéšçŠ¶æ€è‡ªåŠ¨åˆ‡æ¢ã€‚

- **å…³é”®è¯**: çŠ¶æ€é©±åŠ¨è¡Œä¸ºã€è¡Œä¸ºåˆ‡æ¢ã€çŠ¶æ€æœºã€é¿å…å¤§é‡ if-else

> ğŸ’¡ **ç±»æ¯”**: ç”µæ¢¯(å¼€é—¨/å…³é—¨/è¿è¡Œ/åœæ­¢)ã€æ¸¸æˆè§’è‰²(ç«™ç«‹/å¥”è·‘/æ”»å‡»/æ­»äº¡)ã€è®¢å•çŠ¶æ€(å¾…æ”¯ä»˜â†’å·²æ”¯ä»˜â†’å‘è´§â†’å®Œæˆ)

------

ğŸ¯ 2. é€‚ç”¨åœºæ™¯

 âœ” å¯¹è±¡è¡Œä¸ºä¾èµ–äºå®ƒçš„çŠ¶æ€, ä¸”å¿…é¡»åœ¨è¿è¡Œæ—¶æ ¹æ®çŠ¶æ€æ”¹å˜è¡Œä¸º
 âœ” ä»£ç ä¸­åŒ…å«å¤§é‡ä¸å¯¹è±¡çŠ¶æ€æœ‰å…³çš„æ¡ä»¶è¯­å¥(if-else / switch)
 âœ” éœ€è¦å°†â€œçŠ¶æ€ç›¸å…³è¡Œä¸ºâ€å±€éƒ¨åŒ–, é¿å…çŠ¶æ€é€»è¾‘æ•£è½åœ¨å„å¤„
 âœ” å®ç°æœ‰é™çŠ¶æ€æœº(FSM)æˆ–å·¥ä½œæµå¼•æ“

------

âš–ï¸ 3. ä¼˜ç¼ºç‚¹

| ä¼˜ç‚¹                                          | ç¼ºç‚¹                                         |
| --------------------------------------------- | -------------------------------------------- |
| âœ… æ¶ˆé™¤å¤§é‡æ¡ä»¶åˆ†æ”¯, ä»£ç æ›´æ¸…æ™°                | âŒ å¢åŠ ç±»æ•°é‡(æ¯ä¸ªçŠ¶æ€ä¸€ä¸ªç±»)               |
| âœ… ç¬¦åˆå¼€é—­åŸåˆ™: æ–°å¢çŠ¶æ€ä¸ä¿®æ”¹åŸæœ‰ä»£ç         | âŒ çŠ¶æ€é—´è½¬æ¢é€»è¾‘å¯èƒ½å¤æ‚(éœ€è®¾è®¡å¥½è½¬æ¢è§„åˆ™) |
| âœ… çŠ¶æ€èŒè´£æ¸…æ™°, æ˜“äºç»´æŠ¤å’Œæµ‹è¯•                | âŒ è¿‡åº¦è®¾è®¡: ç®€å•çŠ¶æ€ç”¨ enum + switch æ›´è½»é‡  |
| âœ… æ”¯æŒçŠ¶æ€é—´çµæ´»è½¬æ¢(å¯ç”±çŠ¶æ€æˆ–Contextæ§åˆ¶) |                                              |

------

âš ï¸ 4. æ³¨æ„äº‹é¡¹

1. çŠ¶æ€è½¬æ¢æ§åˆ¶æƒ
   - **ç”±çŠ¶æ€ç±»æ§åˆ¶**: æ›´çµæ´», ä½†çŠ¶æ€ç±»éœ€çŸ¥é“å…¶ä»–çŠ¶æ€(è€¦åˆ)
   - **ç”± Context æ§åˆ¶**: æ›´å®‰å…¨, çŠ¶æ€ç±»èŒè´£å•ä¸€(æ¨è)

2. é¿å…å¾ªç¯ä¾èµ–
   - çŠ¶æ€ç±»ä¸åº”ç›´æ¥æŒæœ‰ Context å¼ºå¼•ç”¨ â†’ å¯ç”¨å¼±å¼•ç”¨æˆ–æ¥å£ã€‚

3. çŠ¶æ€å¯¹è±¡å…±äº«
   - è‹¥çŠ¶æ€æ— æˆå‘˜å˜é‡ â†’ å¯è®¾ä¸ºå•ä¾‹, èŠ‚çœå†…å­˜ã€‚

4. ç°ä»£C++å»ºè®®
   - ç”¨ `std::unique_ptr<State>` ç®¡ç†çŠ¶æ€ç”Ÿå‘½å‘¨æœŸã€‚
   - ç”¨ `enum class` + `switch` å®ç°ç®€å•çŠ¶æ€æœº â†’ æ›´é«˜æ•ˆã€‚
   - å¤æ‚çŠ¶æ€æœºå¯ç”¨çŠ¶æ€æ¨¡å¼ + ç­–ç•¥æ¨¡å¼ç»„åˆã€‚

5. å¯¹æ¯”ç­–ç•¥æ¨¡å¼
   - **ç­–ç•¥æ¨¡å¼**: å®¢æˆ·ç«¯ä¸»åŠ¨åˆ‡æ¢ç®—æ³•
   - **çŠ¶æ€æ¨¡å¼**: å¯¹è±¡æ ¹æ®è‡ªèº«çŠ¶æ€è‡ªåŠ¨åˆ‡æ¢è¡Œä¸º

ğŸ§  ä¸€å¥è¯æ€»ç»“çŠ¶æ€æ¨¡å¼: 

> **â€œçŠ¶æ€é©±åŠ¨è¡Œä¸ºå˜, å§”æ‰˜çŠ¶æ€æ¥å®ç°ï¼›å‘Šåˆ«æ»¡å±if-else, çŠ¶æ€åˆ‡æ¢æ›´ä½“é¢ã€‚â€**

------

âœ… **ç»å…¸åº”ç”¨**: 

- ç”µæ¢¯æ§åˆ¶ç³»ç»Ÿ
- æ¸¸æˆè§’è‰²çŠ¶æ€(ç«™ç«‹/å¥”è·‘/æ”»å‡»/æ­»äº¡)
- è®¢å•çŠ¶æ€æœº(å¾…æ”¯ä»˜â†’å·²æ”¯ä»˜â†’å‘è´§â†’å®Œæˆâ†’é€€æ¬¾)
- TCPè¿æ¥çŠ¶æ€(CLOSED â†’ LISTEN â†’ ESTABLISHED â†’ ...)
- UIæ§ä»¶çŠ¶æ€(æŒ‰é’®: æ­£å¸¸/æ‚¬åœ/æŒ‰ä¸‹/ç¦ç”¨)

## ä»£ç 

ç”µæ¢¯æ§åˆ¶ç³»ç»Ÿ

ğŸ¯ åœºæ™¯: ç”µæ¢¯æœ‰â€œå¼€é—¨â€ã€â€œå…³é—¨â€ã€â€œè¿è¡Œâ€ã€â€œåœæ­¢â€å››ç§çŠ¶æ€, ä¸åŒçŠ¶æ€ä¸‹å¯æ‰§è¡Œä¸åŒæ“ä½œ

```
#include <iostream>
#include <memory>
#include <string>

// å‰å‘å£°æ˜
class Elevator;

// === æŠ½è±¡çŠ¶æ€æ¥å£ ===
class ElevatorState {
public:
    virtual ~ElevatorState() = default;
    virtual void openDoor(Elevator& elevator) = 0;
    virtual void closeDoor(Elevator& elevator) = 0;
    virtual void run(Elevator& elevator) = 0;
    virtual void stop(Elevator& elevator) = 0;
    virtual std::string getName() const = 0;
};

// === å…·ä½“çŠ¶æ€ç±» ===
class OpeningState : public ElevatorState {
public:
    void openDoor(Elevator& elevator) override {
        std::cout << "ğŸšª é—¨å·²æ‰“å¼€, æ— éœ€é‡å¤æ“ä½œ\n";
    }

    void closeDoor(Elevator& elevator) override {
        std::cout << "âœ… é—¨å·²å…³é—­\n";
        elevator.setState(std::make_unique<StoppingState>());
    }

    void run(Elevator& elevator) override {
        std::cout << "âŒ é—¨æœªå…³, ä¸èƒ½è¿è¡Œï¼\n";
    }

    void stop(Elevator& elevator) override {
        std::cout << "â¸ï¸  ç”µæ¢¯å·²åœæ­¢, é—¨å¼€ç€\n";
    }

    std::string getName() const override { return "å¼€é—¨çŠ¶æ€"; }
};

class ClosingState : public ElevatorState {
public:
    void openDoor(Elevator& elevator) override {
        std::cout << "âœ… é—¨é‡æ–°æ‰“å¼€\n";
        elevator.setState(std::make_unique<OpeningState>());
    }

    void closeDoor(Elevator& elevator) override {
        std::cout << "âœ… é—¨å·²å…³é—­\n";
        elevator.setState(std::make_unique<StoppingState>());
    }

    void run(Elevator& elevator) override {
        std::cout << "âŒ é—¨æ­£åœ¨å…³é—­ä¸­, ä¸èƒ½è¿è¡Œï¼\n";
    }

    void stop(Elevator& elevator) override {
        std::cout << "â¸ï¸  ç”µæ¢¯å·²åœæ­¢, é—¨æ­£åœ¨å…³é—­\n";
    }

    std::string getName() const override { return "å…³é—¨çŠ¶æ€"; }
};

class RunningState : public ElevatorState {
public:
    void openDoor(Elevator& elevator) override {
        std::cout << "âŒ ç”µæ¢¯è¿è¡Œä¸­, ç¦æ­¢å¼€é—¨ï¼\n";
    }

    void closeDoor(Elevator& elevator) override {
        std::cout << "âœ… é—¨å·²å…³é—­(è¿è¡Œä¸­ä¿æŒå…³é—­)\n";
    }

    void run(Elevator& elevator) override {
        std::cout << "ğŸš€ ç”µæ¢¯æ­£åœ¨è¿è¡Œ\n";
    }

    void stop(Elevator& elevator) override {
        std::cout << "âœ… ç”µæ¢¯å·²åœæ­¢\n";
        elevator.setState(std::make_unique<StoppingState>());
    }

    std::string getName() const override { return "è¿è¡ŒçŠ¶æ€"; }
};

class StoppingState : public ElevatorState {
public:
    void openDoor(Elevator& elevator) override {
        std::cout << "âœ… é—¨å·²æ‰“å¼€\n";
        elevator.setState(std::make_unique<OpeningState>());
    }

    void closeDoor(Elevator& elevator) override {
        std::cout << "âœ… é—¨å·²å…³é—­(ä¿æŒå…³é—­)\n";
    }

    void run(Elevator& elevator) override {
        std::cout << "ğŸš€ ç”µæ¢¯å¼€å§‹è¿è¡Œ\n";
        elevator.setState(std::make_unique<RunningState>());
    }

    void stop(Elevator& elevator) override {
        std::cout << "â¸ï¸  ç”µæ¢¯å·²åœæ­¢\n";
    }

    std::string getName() const override { return "åœæ­¢çŠ¶æ€"; }
};

// === Context: ç”µæ¢¯ ===
class Elevator {
    std::unique_ptr<ElevatorState> currentState;

public:
    Elevator() {
        // åˆå§‹çŠ¶æ€: åœæ­¢
        currentState = std::make_unique<StoppingState>();
    }

    void setState(std::unique_ptr<ElevatorState> state) {
        std::cout << "ğŸ”„ çŠ¶æ€åˆ‡æ¢: " << currentState->getName() << " â†’ " << state->getName() << "\n";
        currentState = std::move(state);
    }

    void openDoor() {
        std::cout << "\n[æ“ä½œ] å¼€é—¨ â†’ ";
        currentState->openDoor(*this);
    }

    void closeDoor() {
        std::cout << "\n[æ“ä½œ] å…³é—¨ â†’ ";
        currentState->closeDoor(*this);
    }

    void run() {
        std::cout << "\n[æ“ä½œ] è¿è¡Œ â†’ ";
        currentState->run(*this);
    }

    void stop() {
        std::cout << "\n[æ“ä½œ] åœæ­¢ â†’ ";
        currentState->stop(*this);
    }

    std::string getCurrentStateName() const {
        return currentState->getName();
    }
};

// === å®¢æˆ·ç«¯ä½¿ç”¨ ===
int main() {
    Elevator elevator;

    std::cout << "=== ç”µæ¢¯åˆå§‹çŠ¶æ€: " << elevator.getCurrentStateName() << " ===\n";

    elevator.openDoor();   // â†’ å¼€é—¨çŠ¶æ€
    elevator.closeDoor();  // â†’ åœæ­¢çŠ¶æ€
    elevator.run();        // â†’ è¿è¡ŒçŠ¶æ€
    elevator.openDoor();   // éæ³•æ“ä½œ
    elevator.stop();       // â†’ åœæ­¢çŠ¶æ€
    elevator.run();        // â†’ è¿è¡ŒçŠ¶æ€
    elevator.stop();       // â†’ åœæ­¢çŠ¶æ€

    std::cout << "\n=== æœ€ç»ˆçŠ¶æ€: " << elevator.getCurrentStateName() << " ===\n";

    return 0;
}
```

```
=== ç”µæ¢¯åˆå§‹çŠ¶æ€: åœæ­¢çŠ¶æ€ ===

[æ“ä½œ] å¼€é—¨ â†’ âœ… é—¨å·²æ‰“å¼€
ğŸ”„ çŠ¶æ€åˆ‡æ¢: åœæ­¢çŠ¶æ€ â†’ å¼€é—¨çŠ¶æ€

[æ“ä½œ] å…³é—¨ â†’ âœ… é—¨å·²å…³é—­
ğŸ”„ çŠ¶æ€åˆ‡æ¢: å¼€é—¨çŠ¶æ€ â†’ åœæ­¢çŠ¶æ€

[æ“ä½œ] è¿è¡Œ â†’ ğŸš€ ç”µæ¢¯å¼€å§‹è¿è¡Œ
ğŸ”„ çŠ¶æ€åˆ‡æ¢: åœæ­¢çŠ¶æ€ â†’ è¿è¡ŒçŠ¶æ€

[æ“ä½œ] å¼€é—¨ â†’ âŒ ç”µæ¢¯è¿è¡Œä¸­, ç¦æ­¢å¼€é—¨ï¼

[æ“ä½œ] åœæ­¢ â†’ âœ… ç”µæ¢¯å·²åœæ­¢
ğŸ”„ çŠ¶æ€åˆ‡æ¢: è¿è¡ŒçŠ¶æ€ â†’ åœæ­¢çŠ¶æ€

[æ“ä½œ] è¿è¡Œ â†’ ğŸš€ ç”µæ¢¯å¼€å§‹è¿è¡Œ
ğŸ”„ çŠ¶æ€åˆ‡æ¢: åœæ­¢çŠ¶æ€ â†’ è¿è¡ŒçŠ¶æ€

[æ“ä½œ] åœæ­¢ â†’ âœ… ç”µæ¢¯å·²åœæ­¢
ğŸ”„ çŠ¶æ€åˆ‡æ¢: è¿è¡ŒçŠ¶æ€ â†’ åœæ­¢çŠ¶æ€

=== æœ€ç»ˆçŠ¶æ€: åœæ­¢çŠ¶æ€ ===
```

## PlantUML

```
@startuml
title State Pattern

class Elevator {
    -currentState: ElevatorState*
    +setState(state)
    +openDoor()
    +closeDoor()
    +run()
    +stop()
    +getCurrentStateName() : string
}

interface ElevatorState {
    +openDoor(elevator)
    +closeDoor(elevator)
    +run(elevator)
    +stop(elevator)
    +getName() : string
}

class OpeningState {
    +openDoor()
    +closeDoor()
    +run()
    +stop()
    +getName()
}

class ClosingState {
    +openDoor()
    +closeDoor()
    +run()
    +stop()
    +getName()
}

class RunningState {
    +openDoor()
    +closeDoor()
    +run()
    +stop()
    +getName()
}

class StoppingState {
    +openDoor()
    +closeDoor()
    +run()
    +stop()
    +getName()
}

Elevator --> ElevatorState : currentState
ElevatorState <|.. OpeningState
ElevatorState <|.. ClosingState
ElevatorState <|.. RunningState
ElevatorState <|.. StoppingState

note right of Elevator
  Contextè§’è‰²
  æŒæœ‰å½“å‰çŠ¶æ€å¯¹è±¡
  è¡Œä¸ºå§”æ‰˜ç»™çŠ¶æ€å¤„ç†
end note

note right of ElevatorState
  çŠ¶æ€æ¥å£
  æ‰€æœ‰çŠ¶æ€å¿…é¡»å®ç°
end note

@enduml
```

![](./picture/21.StatePattern.png)

# 24.è®¿é—®è€…æ¨¡å¼

## ç®€ä»‹

> ğŸ‘¤ è®¿é—®è€…æ¨¡å¼(Visitor Pattern)
> **å°†ä½œç”¨äºæŸç§æ•°æ®ç»“æ„ä¸­å„å…ƒç´ çš„æ“ä½œåˆ†ç¦»å‡ºæ¥å°è£…æˆç‹¬ç«‹çš„ç±», ä½¿å…¶å¯ä»¥åœ¨ä¸æ”¹å˜å„å…ƒç´ ç±»çš„å‰æä¸‹å®šä¹‰ä½œç”¨äºè¿™äº›å…ƒç´ çš„æ–°æ“ä½œã€‚**

------

ğŸ“Œ 1. ä»‹ç»

- **ç±»å‹**: è¡Œä¸ºå‹æ¨¡å¼

- æ ¸å¿ƒæ€æƒ³
  - æ•°æ®ç»“æ„(Element)ç¨³å®š, ä½†**æ“ä½œ(è¡Œä¸º)ç»å¸¸å˜åŒ–** â†’ å°†â€œæ“ä½œâ€ä»â€œæ•°æ®ç»“æ„â€ä¸­è§£è€¦ã€‚
  - é€šè¿‡â€œåŒåˆ†æ´¾â€(Double Dispatch)å®ç°: Element æ¥æ”¶ Visitor, Visitor æ ¹æ® Element ç±»å‹è°ƒç”¨å¯¹åº”æ–¹æ³•ã€‚

- **å…³é”®è¯**: åŒåˆ†æ´¾ã€æ“ä½œä¸æ•°æ®ç»“æ„è§£è€¦ã€æ‰©å±•æ–°æ“ä½œã€éå†å¤æ‚ç»“æ„

> ğŸ’¡ **ç±»æ¯”**: 
> - åŒ»é™¢: ç—…äºº(Element)ä¸åŠ¨, ä¸åŒåŒ»ç”Ÿ(Visitor)æ¥å·¡è¯Š(å¼€è¯/åšæ‰‹æœ¯/å¿ƒç†å’¨è¯¢)
> - ç¨åŠ¡ç³»ç»Ÿ: å‘˜å·¥ç±»å‹(å·¥ç¨‹å¸ˆ/ç»ç†/é”€å”®)å›ºå®š, ä¸åŒè®¿é—®è€…è®¡ç®—â€œä¸ªç¨â€ã€â€œç¤¾ä¿â€ã€â€œå¥–é‡‘â€

------

ğŸ¯ 2. é€‚ç”¨åœºæ™¯

 âœ” æ•°æ®ç»“æ„ç›¸å¯¹ç¨³å®š, ä½†éœ€é¢‘ç¹æ–°å¢æ“ä½œ(å¦‚å¯¼å‡ºã€æ‰“å°ã€åºåˆ—åŒ–ã€ç»Ÿè®¡)
 âœ” éœ€è¦å¯¹ä¸€ä¸ªå¤æ‚å¯¹è±¡ç»“æ„(å¦‚ç»„åˆæ¨¡å¼)ä¸­çš„å¯¹è±¡æ‰§è¡Œå¤šç§ä¸åŒæ“ä½œ
 âœ” å¸Œæœ›åœ¨ä¸ä¿®æ”¹ Element ç±»çš„æƒ…å†µä¸‹å¢åŠ æ–°è¡Œä¸º(ç¬¦åˆå¼€é—­åŸåˆ™)
 âœ” å®ç°â€œæ“ä½œâ€ä¸â€œæ•°æ®ç»“æ„â€çš„å½»åº•åˆ†ç¦»

------

âš–ï¸ 3. ä¼˜ç¼ºç‚¹

| ä¼˜ç‚¹                                                | ç¼ºç‚¹                                                         |
| --------------------------------------------------- | ------------------------------------------------------------ |
| âœ… ç¬¦åˆå¼€é—­åŸåˆ™: æ–°å¢æ“ä½œæ— éœ€ä¿®æ”¹ Element ç±»         | âŒ æ–°å¢ Element ç±»éœ€ä¿®æ”¹æ‰€æœ‰ Visitor â†’ è¿åå¼€é—­åŸåˆ™           |
| âœ… èšåˆç›¸å…³æ“ä½œ: æ‰€æœ‰è®¿é—®é€»è¾‘é›†ä¸­åœ¨ä¸€ä¸ª Visitor ç±»ä¸­ | âŒ ç ´åå°è£…æ€§: Visitor éœ€è®¿é—® Element å†…éƒ¨æ•°æ®(å¸¸éœ€è®¾ä¸º friend) |
| âœ… æ˜“äºå¢åŠ æ–°æ“ä½œ(åªéœ€æ–°å¢ Visitor ç±»)             | âŒ åŒåˆ†æ´¾åœ¨ C++ ä¸­éœ€æ‰‹åŠ¨å®ç°(æ— åŠ¨æ€å¤šåˆ†æ´¾)                  |
| âœ… é€‚åˆå¤æ‚å¯¹è±¡ç»“æ„(å¦‚æ ‘ã€å›¾ã€ç»„åˆæ¨¡å¼)            | âŒ å­¦ä¹ æˆæœ¬é«˜, ç»“æ„å¤æ‚                                       |

------

âš ï¸ 4. æ³¨æ„äº‹é¡¹

1. åŒåˆ†æ´¾å®ç°
   - C++ æ— åŸç”Ÿå¤šåˆ†æ´¾ â†’ éœ€ Element è°ƒç”¨ `visitor.visit(*this)` å®ç°ç¬¬äºŒæ¬¡åˆ†æ´¾ã€‚

2. å°è£…æ€§ç ´å
   - Visitor å¸¸éœ€è®¿é—® Element ç§æœ‰æˆå‘˜ â†’ å¯å°† Visitor è®¾ä¸º Element çš„ `friend`, æˆ–æä¾› `public` æ¥å£ã€‚

3. æ–°å¢ Element çš„ä»£ä»·
   - æ¯æ–°å¢ä¸€ä¸ª Element ç±» â†’ æ‰€æœ‰ Visitor ç±»éœ€å¢åŠ å¯¹åº” `visit()` æ–¹æ³• â†’ **ä¸é€‚åˆ Element é¢‘ç¹å˜åŒ–çš„åœºæ™¯**ã€‚

4. ç°ä»£C++å»ºè®®
   - ç”¨ `std::variant` + `std::visit` å®ç°è½»é‡çº§è®¿é—®è€…(C++17)ã€‚
   - ç”¨ Lambda + å‡½æ•°å¯¹è±¡æ›¿ä»£ä¼ ç»Ÿ Visitor ç±»(æ›´çµæ´»)ã€‚

5. ä¸è¿­ä»£å™¨æ¨¡å¼å¯¹æ¯”
   - è¿­ä»£å™¨: éå†å…ƒç´ 
   - è®¿é—®è€…: å¯¹æ¯ä¸ªå…ƒç´ æ‰§è¡Œç‰¹å®šæ“ä½œ(å¸¸é…åˆè¿­ä»£å™¨ä½¿ç”¨)

ğŸ§  ä¸€å¥è¯æ€»ç»“è®¿é—®è€…æ¨¡å¼: 

> **â€œå…ƒç´ ç¨³å®šæ“ä½œå˜, è®¿é—®è€…æ¥è§£è€¦ï¼›åŒåˆ†æ´¾æ˜¯æ ¸å¿ƒ, æ–°å¢æ“ä½œä¸ç”¨æ”¹å…ƒç´ ã€‚â€**

------

âœ… **ç»å…¸åº”ç”¨**: 

- ç¼–è¯‘å™¨: AST(æŠ½è±¡è¯­æ³•æ ‘)éå†(è¯­ä¹‰åˆ†æã€ä»£ç ç”Ÿæˆã€ä¼˜åŒ–)
- æ–‡æ¡£å¤„ç†: å¯¹ä¸åŒæ–‡æ¡£å…ƒç´ (æ®µè½/è¡¨æ ¼/å›¾ç‰‡)æ‰§è¡Œâ€œæ¸²æŸ“â€ã€â€œç»Ÿè®¡å­—æ•°â€ã€â€œå¯¼å‡ºPDFâ€
- æ¸¸æˆ: å¯¹ä¸åŒæ¸¸æˆå¯¹è±¡(æ•Œäºº/é“å…·/åœ°å½¢)æ‰§è¡Œâ€œç¢°æ’æ£€æµ‹â€ã€â€œæ¸²æŸ“â€ã€â€œå­˜æ¡£â€
- è´¢åŠ¡ç³»ç»Ÿ: å¯¹ä¸åŒèµ„äº§ç±»å‹è®¡ç®—â€œæŠ˜æ—§â€ã€â€œç¨ç‡â€ã€â€œé£é™©å€¼â€

## ä»£ç 

å…¬å¸å‘˜å·¥è–ªèµ„ç»Ÿè®¡ç³»ç»Ÿ

ğŸ¯ åœºæ™¯: å…¬å¸æœ‰â€œå·¥ç¨‹å¸ˆâ€ã€â€œç»ç†â€ã€â€œé”€å”®â€ä¸‰ç§å‘˜å·¥, éœ€æ”¯æŒâ€œè®¡ç®—æ€»è–ªèµ„â€ã€â€œæ‰“å°å‘˜å·¥ä¿¡æ¯â€ã€â€œå¯¼å‡ºåˆ°JSONâ€ç­‰æ“ä½œ

```
#include <iostream>
#include <vector>
#include <string>
#include <memory>
#include <iomanip>

// === å‰å‘å£°æ˜ ===
class Engineer;
class Manager;
class Salesman;

// === æŠ½è±¡è®¿é—®è€… ===
class Visitor {
public:
    virtual ~Visitor() = default;
    virtual void visit(Engineer& engineer) = 0;
    virtual void visit(Manager& manager) = 0;
    virtual void visit(Salesman& salesman) = 0;
};

// === æŠ½è±¡å…ƒç´ (å‘˜å·¥) ===
class Employee {
public:
    virtual ~Employee() = default;
    virtual void accept(Visitor& visitor) = 0; // åŒåˆ†æ´¾å…³é”®
    virtual std::string getName() const = 0;
    virtual double getBaseSalary() const = 0;
};

// === å…·ä½“å…ƒç´ : å·¥ç¨‹å¸ˆ ===
class Engineer : public Employee {
    std::string name;
    double baseSalary;
    int overtimeHours; // åŠ ç­å°æ—¶

public:
    Engineer(const std::string& n, double salary, int hours)
        : name(n), baseSalary(salary), overtimeHours(hours) {}

    void accept(Visitor& visitor) override {
        visitor.visit(*this); // åŒåˆ†æ´¾: è°ƒç”¨å…·ä½“ visit(Engineer&)
    }

    std::string getName() const override { return name; }
    double getBaseSalary() const override { return baseSalary; }
    int getOvertimeHours() const { return overtimeHours; }
    double getOvertimePay() const { return overtimeHours * 50.0; } // åŠ ç­è´¹æ¯å°æ—¶50
};

// === å…·ä½“å…ƒç´ : ç»ç† ===
class Manager : public Employee {
    std::string name;
    double baseSalary;
    double bonusRate; // å¥–é‡‘æ¯”ä¾‹

public:
    Manager(const std::string& n, double salary, double rate)
        : name(n), baseSalary(salary), bonusRate(rate) {}

    void accept(Visitor& visitor) override {
        visitor.visit(*this);
    }

    std::string getName() const override { return name; }
    double getBaseSalary() const override { return baseSalary; }
    double getBonusRate() const { return bonusRate; }
    double getBonus() const { return baseSalary * bonusRate; }
};

// === å…·ä½“å…ƒç´ : é”€å”® ===
class Salesman : public Employee {
    std::string name;
    double baseSalary;
    double salesAmount; // é”€å”®é¢
    double commissionRate; // ææˆæ¯”ä¾‹

public:
    Salesman(const std::string& n, double salary, double amount, double rate)
        : name(n), baseSalary(salary), salesAmount(amount), commissionRate(rate) {}

    void accept(Visitor& visitor) override {
        visitor.visit(*this);
    }

    std::string getName() const override { return name; }
    double getBaseSalary() const override { return baseSalary; }
    double getSalesAmount() const { return salesAmount; }
    double getCommissionRate() const { return commissionRate; }
    double getCommission() const { return salesAmount * commissionRate; }
};

// === å…·ä½“è®¿é—®è€…1: è–ªèµ„è®¡ç®—å™¨ ===
class SalaryCalculator : public Visitor {
    double totalSalary = 0.0;

public:
    void visit(Engineer& engineer) override {
        double salary = engineer.getBaseSalary() + engineer.getOvertimePay();
        totalSalary += salary;
        std::cout << "ğŸ§° å·¥ç¨‹å¸ˆ " << engineer.getName() << " è–ªèµ„: Â¥" << salary << "\n";
    }

    void visit(Manager& manager) override {
        double salary = manager.getBaseSalary() + manager.getBonus();
        totalSalary += salary;
        std::cout << "ğŸ‘” ç»ç† " << manager.getName() << " è–ªèµ„: Â¥" << salary << "\n";
    }

    void visit(Salesman& salesman) override {
        double salary = salesman.getBaseSalary() + salesman.getCommission();
        totalSalary += salary;
        std::cout << "ğŸ›ï¸  é”€å”® " << salesman.getName() << " è–ªèµ„: Â¥" << salary << "\n";
    }

    double getTotalSalary() const { return totalSalary; }
};

// === å…·ä½“è®¿é—®è€…2: å‘˜å·¥ä¿¡æ¯æ‰“å°æœº ===
class EmployeePrinter : public Visitor {
public:
    void visit(Engineer& engineer) override {
        std::cout << "ğŸ§° å·¥ç¨‹å¸ˆ: " << engineer.getName()
                  << " | åŸºæœ¬å·¥èµ„: Â¥" << engineer.getBaseSalary()
                  << " | åŠ ç­: " << engineer.getOvertimeHours() << "å°æ—¶\n";
    }

    void visit(Manager& manager) override {
        std::cout << "ğŸ‘” ç»ç†: " << manager.getName()
                  << " | åŸºæœ¬å·¥èµ„: Â¥" << manager.getBaseSalary()
                  << " | å¥–é‡‘ç‡: " << manager.getBonusRate() * 100 << "%\n";
    }

    void visit(Salesman& salesman) override {
        std::cout << "ğŸ›ï¸  é”€å”®: " << salesman.getName()
                  << " | åŸºæœ¬å·¥èµ„: Â¥" << salesman.getBaseSalary()
                  << " | é”€å”®é¢: Â¥" << salesman.getSalesAmount()
                  << " | ææˆç‡: " << salesman.getCommissionRate() * 100 << "%\n";
    }
};

// === å…¬å¸ç±»(å¯¹è±¡ç»“æ„) ===
class Company {
    std::vector<std::unique_ptr<Employee>> employees;

public:
    void addEmployee(std::unique_ptr<Employee> emp) {
        employees.push_back(std::move(emp));
    }

    void accept(Visitor& visitor) {
        for (auto& emp : employees) {
            emp->accept(visitor); // åŒåˆ†æ´¾è§¦å‘
        }
    }
};

// === å®¢æˆ·ç«¯ä½¿ç”¨ ===
int main() {
    Company company;

    // æ·»åŠ å‘˜å·¥
    company.addEmployee(std::make_unique<Engineer>("å¼ ä¸‰", 8000, 10));
    company.addEmployee(std::make_unique<Manager>("æå››", 15000, 0.2));
    company.addEmployee(std::make_unique<Salesman>("ç‹äº”", 6000, 200000, 0.05));

    std::cout << "=== å‘˜å·¥ä¿¡æ¯ ===\n";
    EmployeePrinter printer;
    company.accept(printer);

    std::cout << "\n=== è–ªèµ„è®¡ç®— ===\n";
    SalaryCalculator calculator;
    company.accept(calculator);
    std::cout << "\nğŸ’° å…¬å¸æ€»è–ªèµ„æ”¯å‡º: Â¥" << std::fixed << std::setprecision(2)
              << calculator.getTotalSalary() << "\n";

    return 0;
}
```

è¾“å‡º

```
=== å‘˜å·¥ä¿¡æ¯ ===
ğŸ§° å·¥ç¨‹å¸ˆ: å¼ ä¸‰ | åŸºæœ¬å·¥èµ„: Â¥8000 | åŠ ç­: 10å°æ—¶
ğŸ‘” ç»ç†: æå›› | åŸºæœ¬å·¥èµ„: Â¥15000 | å¥–é‡‘ç‡: 20%
ğŸ›ï¸  é”€å”®: ç‹äº” | åŸºæœ¬å·¥èµ„: Â¥6000 | é”€å”®é¢: Â¥200000 | ææˆç‡: 5%

=== è–ªèµ„è®¡ç®— ===
ğŸ§° å·¥ç¨‹å¸ˆ å¼ ä¸‰ è–ªèµ„: Â¥8500
ğŸ‘” ç»ç† æå›› è–ªèµ„: Â¥18000
ğŸ›ï¸  é”€å”® ç‹äº” è–ªèµ„: Â¥16000

ğŸ’° å…¬å¸æ€»è–ªèµ„æ”¯å‡º: Â¥42500.00
```

## PlantUML

```
@startuml
title Visitor Pattern

interface Visitor {
    +visit(engineer: Engineer)
    +visit(manager: Manager)
    +visit(salesman: Salesman)
}

abstract class Employee {
    +accept(visitor: Visitor)
    +getName() : string
    +getBaseSalary() : double
}

class Engineer {
    -name: string
    -baseSalary: double
    -overtimeHours: int
    +getOvertimeHours() : int
    +getOvertimePay() : double
}

class Manager {
    -name: string
    -baseSalary: double
    -bonusRate: double
    +getBonusRate() : double
    +getBonus() : double
}

class Salesman {
    -name: string
    -baseSalary: double
    -salesAmount: double
    -commissionRate: double
    +getSalesAmount() : double
    +getCommissionRate() : double
    +getCommission() : double
}

class SalaryCalculator {
    -totalSalary: double
    +getTotalSalary() : double
}

class EmployeePrinter

class Company {
    -employees: vector<Employee*>
    +addEmployee(emp)
    +accept(visitor)
}

Visitor <|.. SalaryCalculator
Visitor <|.. EmployeePrinter

Employee <|-- Engineer
Employee <|-- Manager
Employee <|-- Salesman

Company --> Employee : contains
Company --> Visitor : accepts

note right of Visitor
  æŠ½è±¡è®¿é—®è€…
  å®šä¹‰å¯¹æ¯ç§å…ƒç´ çš„æ“ä½œ
end note

note right of Employee
  æŠ½è±¡å…ƒç´ 
  acceptæ–¹æ³•å®ç°åŒåˆ†æ´¾
end note

note right of Company
  å¯¹è±¡ç»“æ„(Object Structure)
  ç®¡ç†å…ƒç´ é›†åˆ, æä¾›éå†
end note

@enduml
```

![](./picture/22.VisitorPattern.png)


# 25.ä¸­ä»‹è€…æ¨¡å¼

## ç®€ä»‹

ğŸ§© ä¸­ä»‹è€…æ¨¡å¼(Mediator Pattern)

> **ç”¨ä¸€ä¸ªä¸­ä»‹å¯¹è±¡æ¥å°è£…ä¸€ç³»åˆ—å¯¹è±¡ä¹‹é—´çš„äº¤äº’ã€‚ä¸­ä»‹è€…ä½¿å„å¯¹è±¡ä¸éœ€è¦æ˜¾å¼åœ°ç›¸äº’å¼•ç”¨, ä»è€Œä½¿å…¶è€¦åˆæ¾æ•£, è€Œä¸”å¯ä»¥ç‹¬ç«‹åœ°æ”¹å˜å®ƒä»¬ä¹‹é—´çš„äº¤äº’ã€‚**

------

ğŸ“Œ 1. ä»‹ç»

- **ç±»å‹**: è¡Œä¸ºå‹æ¨¡å¼

- æ ¸å¿ƒæ€æƒ³
  - å¯¹è±¡ä¹‹é—´**ä¸ç›´æ¥é€šä¿¡**, è€Œæ˜¯é€šè¿‡â€œä¸­ä»‹è€…â€åè°ƒã€‚
  - **é™ä½å¯¹è±¡é—´çš„è€¦åˆåº¦**, å°†â€œå¤šå¯¹å¤šâ€ä¾èµ– â†’ â€œå¤šå¯¹ä¸€â€(æ‰€æœ‰å¯¹è±¡ä¾èµ–ä¸­ä»‹è€…)ã€‚

- **å…³é”®è¯**: è§£è€¦ã€é›†ä¸­æ§åˆ¶ã€é€šä¿¡æ¢çº½ã€é¿å…ç½‘çŠ¶ä¾èµ–

> ğŸ’¡ **ç±»æ¯”**: 
> - æœºåœºå¡”å°(ä¸­ä»‹è€…)åè°ƒæ‰€æœ‰é£æœºèµ·é™(å¯¹è±¡)
> - èŠå¤©å®¤æœåŠ¡å™¨(ä¸­ä»‹è€…)è½¬å‘ç”¨æˆ·æ¶ˆæ¯(å¯¹è±¡)
> - GUIæ¡†æ¶ä¸­, å¯¹è¯æ¡†(ä¸­ä»‹è€…)åè°ƒæŒ‰é’®ã€æ–‡æœ¬æ¡†ã€åˆ—è¡¨æ¡†äº¤äº’

------

ğŸ¯ 2. é€‚ç”¨åœºæ™¯

 âœ” å¯¹è±¡ä¹‹é—´å­˜åœ¨å¤æ‚çš„ç½‘çŠ¶å¼•ç”¨å…³ç³», å¯¼è‡´ç³»ç»Ÿç»“æ„æ··ä¹±ã€éš¾ä»¥ç»´æŠ¤
 âœ” æƒ³å¤ç”¨ä¸€ä¸ªå¯¹è±¡, ä½†å…¶éœ€è¦ä¸å¾ˆå¤šå…¶ä»–å¯¹è±¡äº¤äº’ â†’ é€šè¿‡ä¸­ä»‹è€…ç»Ÿä¸€ç®¡ç†
 âœ” æƒ³å°è£…å¯¹è±¡é—´çš„å¤æ‚é€šä¿¡é€»è¾‘, ä½¿å…¶å¯ç‹¬ç«‹å˜åŒ–
 âœ” å®ç°â€œå‘å¸ƒ-è®¢é˜…â€ã€â€œäº‹ä»¶æ€»çº¿â€ã€â€œèŠå¤©å®¤â€ã€â€œGUIç»„ä»¶è”åŠ¨â€

------

âš–ï¸ 3. ä¼˜ç¼ºç‚¹

| ä¼˜ç‚¹                               | ç¼ºç‚¹                                       |
| ---------------------------------- | ------------------------------------------ |
| âœ… é™ä½å¯¹è±¡é—´è€¦åˆåº¦, ç¬¦åˆè¿ªç±³ç‰¹æ³•åˆ™ | âŒ ä¸­ä»‹è€…å¯èƒ½å˜å¾—è¿‡äºå¤æ‚å’Œåºå¤§(ä¸Šå¸å¯¹è±¡) |
| âœ… é›†ä¸­ç®¡ç†äº¤äº’é€»è¾‘, ä¾¿äºç»´æŠ¤å’Œæ‰©å±• | âŒ ä¸­ä»‹è€…æ‰¿æ‹…è¿‡å¤šèŒè´£, è¿åå•ä¸€èŒè´£åŸåˆ™     |
| âœ… å¯¹è±¡å¯ç‹¬ç«‹å˜åŒ–, å¤ç”¨æ€§é«˜         | âŒ ç³»ç»Ÿæ€§èƒ½å¯èƒ½å—å½±å“(æ‰€æœ‰äº¤äº’ç»ä¸­ä»‹è€…)   |
| âœ… æ˜“äºå¢åŠ æ–°å¯¹è±¡æˆ–æ–°äº¤äº’è§„åˆ™       | âŒ è°ƒè¯•å›°éš¾(äº¤äº’è·¯å¾„å˜é•¿)                 |

------

âš ï¸ 4. æ³¨æ„äº‹é¡¹

1. é¿å…â€œä¸Šå¸ä¸­ä»‹è€…â€
   - ä¸­ä»‹è€…ä¸åº”æ‰¿æ‹…è¿‡å¤šä¸šåŠ¡é€»è¾‘ â†’ å¯æ‹†åˆ†ä¸ºå¤šä¸ªä¸­ä»‹è€…æˆ–é…åˆå…¶ä»–æ¨¡å¼(å¦‚å‘½ä»¤æ¨¡å¼)ã€‚

2. å¯¹è±¡æ³¨å†Œæœºåˆ¶
   - å¯¹è±¡åº”èƒ½åŠ¨æ€æ³¨å†Œ/æ³¨é”€åˆ°ä¸­ä»‹è€… â†’ ç”¨ `std::vector<std::weak_ptr<Colleague>>` é¿å…å¾ªç¯å¼•ç”¨ã€‚

3. ç°ä»£C++å»ºè®®
   - ç”¨ `std::function` + Lambda å®ç°çµæ´»çš„æ¶ˆæ¯å¤„ç†ã€‚
   - ç”¨ `std::unordered_map<std::string, std::function<...>>` å®ç°â€œæ¶ˆæ¯è·¯ç”±â€ã€‚

4. ä¸è§‚å¯Ÿè€…æ¨¡å¼å¯¹æ¯”
   - **è§‚å¯Ÿè€…**: ä¸€å¯¹å¤šâ€œå‘å¸ƒ-è®¢é˜…â€, è¢«è§‚å¯Ÿè€…ä¸»åŠ¨é€šçŸ¥
   - **ä¸­ä»‹è€…**: å¤šå¯¹å¤šâ€œåè°ƒé€šä¿¡â€, ä¸­ä»‹è€…ä¸»åŠ¨è°ƒåº¦

5. æ€§èƒ½è€ƒè™‘
   - é«˜é¢‘é€šä¿¡åœºæ™¯ â†’ è€ƒè™‘ç›´æ¥é€šä¿¡æˆ–äº‹ä»¶é˜Ÿåˆ—ä¼˜åŒ–

ğŸ§  ä¸€å¥è¯æ€»ç»“ä¸­ä»‹è€…æ¨¡å¼: 

> **â€œå¯¹è±¡é€šä¿¡æ‰¾ä¸­ä»‹, è§£è€¦ç½‘çŠ¶ä¾èµ–ï¼›é›†ä¸­æ§åˆ¶æ˜¯æ ¸å¿ƒ, é¿å…ç›´æ¥å¼•ç”¨ã€‚â€**

------

âœ… **ç»å…¸åº”ç”¨**: 

- GUIæ¡†æ¶: å¯¹è¯æ¡†åè°ƒæŒ‰é’®ã€æ–‡æœ¬æ¡†ã€ä¸‹æ‹‰æ¡†è”åŠ¨
- èŠå¤©å®¤/å³æ—¶é€šè®¯ç³»ç»Ÿ
- æœºåœºå¡”å°è°ƒåº¦é£æœºèµ·é™
- æ¸¸æˆAI: AIæŒ‡æŒ¥å®˜åè°ƒå¤šä¸ªå•ä½è¡ŒåŠ¨
- MVCæ¶æ„ä¸­, Controller ä½œä¸ºä¸­ä»‹è€…åè°ƒ Model å’Œ View

## ä»£ç 

èŠå¤©å®¤ç³»ç»Ÿ

ğŸ¯ åœºæ™¯: å¤šä¸ªç”¨æˆ·åŠ å…¥èŠå¤©å®¤, é€šè¿‡èŠå¤©å®¤ä¸­ä»‹è€…å‘é€/æ¥æ”¶æ¶ˆæ¯, ç”¨æˆ·ä¹‹é—´ä¸ç›´æ¥é€šä¿¡

```
#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <algorithm>

// === å‰å‘å£°æ˜ ===
class ChatRoom;

// === æŠ½è±¡åŒäº‹ç±»(ç”¨æˆ·) ===
class User {
protected:
    std::string name;
    ChatRoom* chatRoom; // æŒæœ‰ä¸­ä»‹è€…å¼•ç”¨

public:
    User(const std::string& n) : name(n), chatRoom(nullptr) {}
    virtual ~User() = default;

    void setChatRoom(ChatRoom* room) { chatRoom = room; }
    std::string getName() const { return name; }

    // å‘é€æ¶ˆæ¯(å§”æ‰˜ç»™ä¸­ä»‹è€…)
    void sendMessage(const std::string& message) {
        if (chatRoom) {
            chatRoom->sendMessage(this, message);
        }
    }

    // æ¥æ”¶æ¶ˆæ¯(ç”±ä¸­ä»‹è€…è°ƒç”¨)
    virtual void receiveMessage(const std::string& from, const std::string& message) {
        std::cout << "ğŸ“© [" << name << "] æ”¶åˆ°æ¥è‡ª " << from << " çš„æ¶ˆæ¯: \"" << message << "\"\n";
    }
};

// === å…·ä½“åŒäº‹ç±»: æ™®é€šç”¨æˆ· ===
class NormalUser : public User {
public:
    using User::User;
};

// === å…·ä½“åŒäº‹ç±»: VIPç”¨æˆ·(æ¶ˆæ¯å¸¦â­) ===
class VIPUser : public User {
public:
    using User::User;

    void receiveMessage(const std::string& from, const std::string& message) override {
        std::cout << "â­ [" << name << "] æ”¶åˆ°VIPæ¶ˆæ¯ from " << from << ": \"" << message << "\"\n";
    }
};

// === ä¸­ä»‹è€…: èŠå¤©å®¤ ===
class ChatRoom {
    std::vector<std::shared_ptr<User>> users;

public:
    void addUser(std::shared_ptr<User> user) {
        user->setChatRoom(this);
        users.push_back(user);
        std::cout << "âœ… ç”¨æˆ· \"" << user->getName() << "\" åŠ å…¥èŠå¤©å®¤\n";
    }

    void removeUser(const std::string& name) {
        users.erase(
            std::remove_if(users.begin(), users.end(),
                [&](const std::shared_ptr<User>& u) { return u->getName() == name; }),
            users.end()
        );
        std::cout << "âŒ ç”¨æˆ· \"" << name << "\" ç¦»å¼€èŠå¤©å®¤\n";
    }

    // æ ¸å¿ƒ: ä¸­ä»‹è€…è´Ÿè´£æ¶ˆæ¯åˆ†å‘
    void sendMessage(User* sender, const std::string& message) {
        std::cout << "\nğŸ“¤ [" << sender->getName() << "] å‘é€: \"" << message << "\"\n";
        for (auto& user : users) {
            if (user.get() != sender) { // ä¸å‘ç»™è‡ªå·±
                user->receiveMessage(sender->getName(), message);
            }
        }
    }

    void broadcastSystemMessage(const std::string& msg) {
        std::cout << "\nğŸ“¢ ç³»ç»Ÿå¹¿æ’­: " << msg << "\n";
        for (auto& user : users) {
            user->receiveMessage("ç³»ç»Ÿ", msg);
        }
    }

    size_t getUserCount() const { return users.size(); }
};

// === å®¢æˆ·ç«¯ä½¿ç”¨ ===
int main() {
    ChatRoom chatRoom;

    // åˆ›å»ºç”¨æˆ·
    auto alice = std::make_shared<NormalUser>("Alice");
    auto bob = std::make_shared<VIPUser>("Bob");
    auto charlie = std::make_shared<NormalUser>("Charlie");

    // åŠ å…¥èŠå¤©å®¤
    chatRoom.addUser(alice);
    chatRoom.addUser(bob);
    chatRoom.addUser(charlie);

    std::cout << "\n=== å¼€å§‹èŠå¤© ===\n";
    alice->sendMessage("å¤§å®¶å¥½, æˆ‘æ˜¯Aliceï¼");
    bob->sendMessage("æˆ‘æ˜¯VIPç”¨æˆ·Bob â­");
    charlie->sendMessage("æˆ‘æ˜¯Charlie, å¾ˆé«˜å…´è®¤è¯†å¤§å®¶ï¼");

    std::cout << "\n=== ç³»ç»Ÿå¹¿æ’­ ===\n";
    chatRoom.broadcastSystemMessage("æœåŠ¡å™¨å°†åœ¨5åˆ†é’Ÿåç»´æŠ¤, è¯·ä¿å­˜èŠå¤©è®°å½•ã€‚");

    std::cout << "\n=== ç”¨æˆ·ç¦»å¼€ ===\n";
    chatRoom.removeUser("Alice");
    bob->sendMessage("Aliceç¦»å¼€äº†...");

    std::cout << "\n=== å½“å‰åœ¨çº¿äººæ•°: " << chatRoom.getUserCount() << " ===\n";

    return 0;
}
```

è¾“å‡º

```
âœ… ç”¨æˆ· "Alice" åŠ å…¥èŠå¤©å®¤
âœ… ç”¨æˆ· "Bob" åŠ å…¥èŠå¤©å®¤
âœ… ç”¨æˆ· "Charlie" åŠ å…¥èŠå¤©å®¤

=== å¼€å§‹èŠå¤© ===

ğŸ“¤ [Alice] å‘é€: "å¤§å®¶å¥½, æˆ‘æ˜¯Aliceï¼"
â­ [Bob] æ”¶åˆ°VIPæ¶ˆæ¯ from Alice: "å¤§å®¶å¥½, æˆ‘æ˜¯Aliceï¼"
ğŸ“© [Charlie] æ”¶åˆ°æ¥è‡ª Alice çš„æ¶ˆæ¯: "å¤§å®¶å¥½, æˆ‘æ˜¯Aliceï¼"

ğŸ“¤ [Bob] å‘é€: "æˆ‘æ˜¯VIPç”¨æˆ·Bob â­"
ğŸ“© [Alice] æ”¶åˆ°æ¥è‡ª Bob çš„æ¶ˆæ¯: "æˆ‘æ˜¯VIPç”¨æˆ·Bob â­"
ğŸ“© [Charlie] æ”¶åˆ°æ¥è‡ª Bob çš„æ¶ˆæ¯: "æˆ‘æ˜¯VIPç”¨æˆ·Bob â­"

ğŸ“¤ [Charlie] å‘é€: "æˆ‘æ˜¯Charlie, å¾ˆé«˜å…´è®¤è¯†å¤§å®¶ï¼"
ğŸ“© [Alice] æ”¶åˆ°æ¥è‡ª Charlie çš„æ¶ˆæ¯: "æˆ‘æ˜¯Charlie, å¾ˆé«˜å…´è®¤è¯†å¤§å®¶ï¼"
â­ [Bob] æ”¶åˆ°VIPæ¶ˆæ¯ from Charlie: "æˆ‘æ˜¯Charlie, å¾ˆé«˜å…´è®¤è¯†å¤§å®¶ï¼"

=== ç³»ç»Ÿå¹¿æ’­ ===

ğŸ“¢ ç³»ç»Ÿå¹¿æ’­: æœåŠ¡å™¨å°†åœ¨5åˆ†é’Ÿåç»´æŠ¤, è¯·ä¿å­˜èŠå¤©è®°å½•ã€‚
ğŸ“© [Alice] æ”¶åˆ°æ¥è‡ª ç³»ç»Ÿ çš„æ¶ˆæ¯: "æœåŠ¡å™¨å°†åœ¨5åˆ†é’Ÿåç»´æŠ¤, è¯·ä¿å­˜èŠå¤©è®°å½•ã€‚"
â­ [Bob] æ”¶åˆ°VIPæ¶ˆæ¯ from ç³»ç»Ÿ: "æœåŠ¡å™¨å°†åœ¨5åˆ†é’Ÿåç»´æŠ¤, è¯·ä¿å­˜èŠå¤©è®°å½•ã€‚"
ğŸ“© [Charlie] æ”¶åˆ°æ¥è‡ª ç³»ç»Ÿ çš„æ¶ˆæ¯: "æœåŠ¡å™¨å°†åœ¨5åˆ†é’Ÿåç»´æŠ¤, è¯·ä¿å­˜èŠå¤©è®°å½•ã€‚"

=== ç”¨æˆ·ç¦»å¼€ ===
âŒ ç”¨æˆ· "Alice" ç¦»å¼€èŠå¤©å®¤

ğŸ“¤ [Bob] å‘é€: "Aliceç¦»å¼€äº†..."
ğŸ“© [Charlie] æ”¶åˆ°æ¥è‡ª Bob çš„æ¶ˆæ¯: "Aliceç¦»å¼€äº†..."

=== å½“å‰åœ¨çº¿äººæ•°: 2 ===
```

## PlantUML

```
@startuml
title Mediator Pattern

interface Mediator {
    +sendMessage(sender, message)
    +addUser(user)
    +removeUser(name)
}

class ChatRoom {
    -users: vector<shared_ptr<User>>
    +sendMessage(sender, message)
    +addUser(user)
    +removeUser(name)
    +broadcastSystemMessage(msg)
    +getUserCount() : size_t
}

abstract class User {
    -name: string
    -chatRoom: ChatRoom*
    +sendMessage(message)
    +receiveMessage(from, message)
    +getName() : string
    +setChatRoom(room)
}

class NormalUser {
    +receiveMessage(from, message)
}

class VIPUser {
    +receiveMessage(from, message)
}

Mediator <|.. ChatRoom

User <|-- NormalUser
User <|-- VIPUser

ChatRoom --> User : manages
User --> ChatRoom : holds reference

note right of Mediator
  ä¸­ä»‹è€…æ¥å£
  å®šä¹‰å¯¹è±¡é—´äº¤äº’åè®®
end note

note right of ChatRoom
  å…·ä½“ä¸­ä»‹è€…
  é›†ä¸­ç®¡ç†æ‰€æœ‰ç”¨æˆ·å’Œæ¶ˆæ¯åˆ†å‘
end note

note right of User
  æŠ½è±¡åŒäº‹ç±»
  é€šè¿‡ä¸­ä»‹è€…é€šä¿¡, ä¸ç›´æ¥å¼•ç”¨å…¶ä»–åŒäº‹
end note

@enduml
```

![](./picture/23.MediatorPattern.png)


# 26.è§£é‡Šå™¨æ¨¡å¼

## ç®€ä»‹

> ğŸ§® è§£é‡Šå™¨æ¨¡å¼(Interpreter Pattern)
> **ç»™å®šä¸€ä¸ªè¯­è¨€, å®šä¹‰å®ƒçš„æ–‡æ³•çš„ä¸€ç§è¡¨ç¤º, å¹¶å®šä¹‰ä¸€ä¸ªè§£é‡Šå™¨, è¿™ä¸ªè§£é‡Šå™¨ä½¿ç”¨è¯¥è¡¨ç¤ºæ¥è§£é‡Šè¯­è¨€ä¸­çš„å¥å­ã€‚**

------

ğŸ“Œ 1. ä»‹ç»

- **ç±»å‹**: è¡Œä¸ºå‹æ¨¡å¼

- æ ¸å¿ƒæ€æƒ³
  - å°†**è¯­æ³•è§„åˆ™**æŠ½è±¡ä¸ºç±»(ç»ˆç»“ç¬¦è¡¨è¾¾å¼ã€éç»ˆç»“ç¬¦è¡¨è¾¾å¼)ã€‚
  - æ„å»º**æŠ½è±¡è¯­æ³•æ ‘(AST)**, é€šè¿‡é€’å½’è§£é‡Šæ‰§è¡Œã€‚
  - é€‚ç”¨äº**ç®€å•è¯­è¨€**æˆ–**ç‰¹å®šé¢†åŸŸè¯­è¨€(DSL)** çš„è§£æä¸æ‰§è¡Œã€‚

- **å…³é”®è¯**: æ–‡æ³•ã€è§£é‡Šå™¨ã€ASTã€é€’å½’è§£é‡Šã€ç»ˆç»“ç¬¦/éç»ˆç»“ç¬¦

> ğŸ’¡ **ç±»æ¯”**: 
>
> - è®¡ç®—å™¨è§£é‡Š â€œ1 + 2 * 3â€
> - æ­£åˆ™è¡¨è¾¾å¼å¼•æ“è§£é‡Š â€œa*b+â€
> - SQL è§£æå™¨è§£é‡Š â€œSELECT * FROM users WHERE age > 18â€

------

ğŸ¯ 2. é€‚ç”¨åœºæ™¯

 âœ” éœ€è¦è§£é‡Šæ‰§è¡Œ**ç®€å•è¯­æ³•è§„åˆ™**(å¦‚æ•°å­¦è¡¨è¾¾å¼ã€å¸ƒå°”è¡¨è¾¾å¼ã€é…ç½®è§„åˆ™)
 âœ” è¯­æ³•è§„åˆ™**ç›¸å¯¹ç¨³å®š**, ä½†éœ€è¦é¢‘ç¹è§£é‡Šä¸åŒâ€œå¥å­â€
 âœ” å®ç°**ç‰¹å®šé¢†åŸŸè¯­è¨€(DSL)**, å¦‚è§„åˆ™å¼•æ“ã€é…ç½®è¯­è¨€ã€è„šæœ¬è¯­è¨€å­é›†
 âœ” è¯­æ³•å¯è¡¨ç¤ºä¸º**æ ‘å½¢ç»“æ„(AST)**

> â— **ä¸é€‚ç”¨äºå¤æ‚è¯­è¨€(å¦‚å®Œæ•´ç¼–ç¨‹è¯­è¨€)** â†’ åº”ä½¿ç”¨ä¸“ä¸šè§£æå™¨ç”Ÿæˆå·¥å…·(å¦‚ ANTLR, Bison)

------

âš–ï¸ 3. ä¼˜ç¼ºç‚¹

| ä¼˜ç‚¹                                  | ç¼ºç‚¹                                              |
| ------------------------------------- | ------------------------------------------------- |
| âœ… æ˜“äºæ”¹å˜å’Œæ‰©å±•æ–‡æ³•(æ–°å¢è¡¨è¾¾å¼ç±»)  | âŒ å¤æ‚æ–‡æ³•ä¼šå¯¼è‡´ç±»çˆ†ç‚¸(æ¯ä¸ªè§„åˆ™ä¸€ä¸ªç±»)          |
| âœ… å®ç°æ–‡æ³•è¾ƒç›´è§‚(ç±»ç»“æ„ â‰ˆ è¯­æ³•è§„åˆ™) | âŒ æ‰§è¡Œæ•ˆç‡è¾ƒä½(é€’å½’è§£é‡Š, æ— ä¼˜åŒ–)                |
| âœ… æ˜“äºå®ç°è§£é‡Šå™¨(é€’å½’è°ƒç”¨)          | âŒ ç»´æŠ¤å›°éš¾(æ–‡æ³•å˜æ›´éœ€ä¿®æ”¹å¤šä¸ªç±»)                |
| âœ… é€‚åˆç®€å•DSLæˆ–é…ç½®è§„åˆ™å¼•æ“           | â— ä»…é€‚åˆç®€å•è¯­æ³•, å¤æ‚è¯­æ³•åº”ä½¿ç”¨ Parser Generator |

------

âš ï¸ 4. æ³¨æ„äº‹é¡¹

1. æ–‡æ³•å¤æ‚åº¦æ§åˆ¶
   - ä»…é€‚ç”¨äº**ç®€å•æ–‡æ³•**(å¦‚å››åˆ™è¿ç®—ã€å¸ƒå°”é€»è¾‘)ã€‚
   - å¤æ‚æ–‡æ³• â†’ ç”¨ **ANTLR / Bison / Boost.Spirit**ã€‚

2. æ€§èƒ½ä¼˜åŒ–
   - å¯åŠ å…¥â€œç¼“å­˜è§£é‡Šç»“æœâ€æˆ–â€œç¼–è¯‘ä¸ºå­—èŠ‚ç â€æå‡æ€§èƒ½ã€‚

3. ç°ä»£C++å»ºè®®
   - ç”¨ `std::variant` + `std::visit` å®ç°è½»é‡è¡¨è¾¾å¼æ ‘(C++17)ã€‚
   - ç”¨ Lambda è¡¨è¾¾å¼æ„å»ºåŠ¨æ€è§„åˆ™ã€‚

4. ä¸ç­–ç•¥æ¨¡å¼å¯¹æ¯”
   - ç­–ç•¥: ç®—æ³•åˆ‡æ¢
   - è§£é‡Šå™¨: è¯­æ³•è§„åˆ™è§£é‡Š

5. æ‰©å±•æ€§
   - æ–°å¢è¿ç®—ç¬¦ â†’ æ–°å¢ Expression å­ç±», ç¬¦åˆå¼€é—­åŸåˆ™ã€‚

ğŸ§  ä¸€å¥è¯æ€»ç»“è§£é‡Šå™¨æ¨¡å¼: 

> **â€œæ–‡æ³•å˜ç±»æ ‘, è§£é‡Šé€’å½’èµ°ï¼›é€‚åˆå°DSL, å¤æ‚è¯­æ³•è«å¼ºæ±‚ã€‚â€**

------

âœ… **ç»å…¸åº”ç”¨**: 

- è®¡ç®—å™¨(å››åˆ™è¿ç®—è¡¨è¾¾å¼)
- å¸ƒå°”è§„åˆ™å¼•æ“(æƒé™æ§åˆ¶ã€é£æ§è§„åˆ™)
- æ­£åˆ™è¡¨è¾¾å¼ç®€åŒ–ç‰ˆ
- SQL WHERE æ¡ä»¶è§£æ
- é…ç½®æ–‡ä»¶è§„åˆ™è§£æ(å¦‚ Nginx rewrite è§„åˆ™)

## ä»£ç 

å¸ƒå°”è¡¨è¾¾å¼è§£é‡Šå™¨

ğŸ¯ åœºæ™¯: è§£é‡Šæ‰§è¡Œå¸ƒå°”è¡¨è¾¾å¼, å¦‚ `(true and false) or true`

```
#include <iostream>
#include <string>
#include <memory>
#include <map>
#include <sstream>
#include <cctype>

// === æŠ½è±¡è¡¨è¾¾å¼æ¥å£ ===
class Expression {
public:
    virtual ~Expression() = default;
    virtual bool interpret(const std::map<std::string, bool>& context) const = 0;
};

// === ç»ˆç»“ç¬¦è¡¨è¾¾å¼: å¸ƒå°”å¸¸é‡ ===
class BooleanExpression : public Expression {
    bool value;

public:
    explicit BooleanExpression(bool v) : value(v) {}

    bool interpret(const std::map<std::string, bool>&) const override {
        return value;
    }
};

// === ç»ˆç»“ç¬¦è¡¨è¾¾å¼: å˜é‡ ===
class VariableExpression : public Expression {
    std::string name;

public:
    explicit VariableExpression(const std::string& n) : name(n) {}

    bool interpret(const std::map<std::string, bool>& context) const override {
        auto it = context.find(name);
        if (it != context.end()) {
            return it->second;
        }
        throw std::runtime_error("Undefined variable: " + name);
    }
};

// === éç»ˆç»“ç¬¦è¡¨è¾¾å¼: AND ===
class AndExpression : public Expression {
    std::unique_ptr<Expression> left;
    std::unique_ptr<Expression> right;

public:
    AndExpression(std::unique_ptr<Expression> l, std::unique_ptr<Expression> r)
        : left(std::move(l)), right(std::move(r)) {}

    bool interpret(const std::map<std::string, bool>& context) const override {
        return left->interpret(context) && right->interpret(context);
    }
};

// === éç»ˆç»“ç¬¦è¡¨è¾¾å¼: OR ===
class OrExpression : public Expression {
    std::unique_ptr<Expression> left;
    std::unique_ptr<Expression> right;

public:
    OrExpression(std::unique_ptr<Expression> l, std::unique_ptr<Expression> r)
        : left(std::move(l)), right(std::move(r)) {}

    bool interpret(const std::map<std::string, bool>& context) const override {
        return left->interpret(context) || right->interpret(context);
    }
};

// === éç»ˆç»“ç¬¦è¡¨è¾¾å¼: NOT ===
class NotExpression : public Expression {
    std::unique_ptr<Expression> expr;

public:
    explicit NotExpression(std::unique_ptr<Expression> e) : expr(std::move(e)) {}

    bool interpret(const std::map<std::string, bool>& context) const override {
        return !expr->interpret(context);
    }
};

// === ç®€å•è¯æ³•åˆ†æå™¨ + è¯­æ³•è§£æå™¨(æ”¯æŒ: true, false, and, or, not, å˜é‡å, æ‹¬å·) ===
class ExpressionParser {
    std::string input;
    size_t pos = 0;

    // è·³è¿‡ç©ºç™½å­—ç¬¦
    void skipWhitespace() {
        while (pos < input.size() && std::isspace(input[pos])) {
            ++pos;
        }
    }

    // è·å–ä¸‹ä¸€ä¸ªToken
    std::string nextToken() {
        skipWhitespace();
        if (pos >= input.size()) return "";

        if (std::isalpha(input[pos])) {
            std::string token;
            while (pos < input.size() && std::isalnum(input[pos])) {
                token += input[pos++];
            }
            return token;
        }

        return std::string(1, input[pos++]); // å•å­—ç¬¦:  ( ) and or not
    }

    // é€’å½’ä¸‹é™è§£æå™¨
    std::unique_ptr<Expression> parseExpression() {
        auto expr = parseOr();
        return expr;
    }

    std::unique_ptr<Expression> parseOr() {
        auto left = parseAnd();
        std::string token = nextToken();
        if (token == "or") {
            auto right = parseOr();
            return std::make_unique<OrExpression>(std::move(left), std::move(right));
        }
        pos -= token.size(); // å›é€€
        return left;
    }

    std::unique_ptr<Expression> parseAnd() {
        auto left = parseNot();
        std::string token = nextToken();
        if (token == "and") {
            auto right = parseAnd();
            return std::make_unique<AndExpression>(std::move(left), std::move(right));
        }
        pos -= token.size();
        return left;
    }

    std::unique_ptr<Expression> parseNot() {
        std::string token = nextToken();
        if (token == "not") {
            auto expr = parsePrimary();
            return std::make_unique<NotExpression>(std::move(expr));
        }
        pos -= token.size();
        return parsePrimary();
    }

    std::unique_ptr<Expression> parsePrimary() {
        std::string token = nextToken();
        if (token == "(") {
            auto expr = parseExpression();
            std::string close = nextToken();
            if (close != ")") {
                throw std::runtime_error("Expected ')'");
            }
            return expr;
        } else if (token == "true") {
            return std::make_unique<BooleanExpression>(true);
        } else if (token == "false") {
            return std::make_unique<BooleanExpression>(false);
        } else if (std::isalpha(token[0])) {
            return std::make_unique<VariableExpression>(token);
        } else {
            throw std::runtime_error("Unexpected token: " + token);
        }
    }

public:
    explicit ExpressionParser(const std::string& str) : input(str) {}

    std::unique_ptr<Expression> parse() {
        pos = 0;
        return parseExpression();
    }
};

// === å®¢æˆ·ç«¯ä½¿ç”¨ ===
int main() {
    // æµ‹è¯•è¡¨è¾¾å¼
    std::vector<std::string> testExpressions = {
        "true and false",
        "(true or false) and true",
        "not false",
        "x and y",
        "(x or y) and not z"
    };

    // ä¸Šä¸‹æ–‡å˜é‡å€¼
    std::map<std::string, bool> context = {
        {"x", true},
        {"y", false},
        {"z", true}
    };

    for (const auto& exprStr : testExpressions) {
        try {
            ExpressionParser parser(exprStr);
            auto expression = parser.parse();

            bool result = expression->interpret(context);
            std::cout << "âœ… è¡¨è¾¾å¼: " << exprStr
                      << " â†’ ç»“æœ: " << (result ? "true" : "false") << "\n";

        } catch (const std::exception& e) {
            std::cout << "âŒ è§£æé”™è¯¯: " << exprStr << " â†’ " << e.what() << "\n";
        }
    }

    return 0;
}
```

è¾“å‡º

```
âœ… è¡¨è¾¾å¼: true and false â†’ ç»“æœ: false
âœ… è¡¨è¾¾å¼: (true or false) and true â†’ ç»“æœ: true
âœ… è¡¨è¾¾å¼: not false â†’ ç»“æœ: true
âœ… è¡¨è¾¾å¼: x and y â†’ ç»“æœ: false
âœ… è¡¨è¾¾å¼: (x or y) and not z â†’ ç»“æœ: false
```



## PlantUML

```
@startuml
title Interpreter Pattern

interface Expression {
    +interpret(context: Map<String,Bool>) : bool
}

class BooleanExpression {
    -value: bool
    +interpret(context) : bool
}

class VariableExpression {
    -name: string
    +interpret(context) : bool
}

class AndExpression {
    -left: Expression*
    -right: Expression*
    +interpret(context) : bool
}

class OrExpression {
    -left: Expression*
    -right: Expression*
    +interpret(context) : bool
}

class NotExpression {
    -expr: Expression*
    +interpret(context) : bool
}

class ExpressionParser {
    -input: string
    -pos: size_t
    +parse() : unique_ptr<Expression>
    -parseExpression()
    -parseOr()
    -parseAnd()
    -parseNot()
    -parsePrimary()
    -nextToken() : string
    -skipWhitespace()
}

Expression <|.. BooleanExpression
Expression <|.. VariableExpression
Expression <|.. AndExpression
Expression <|.. OrExpression
Expression <|.. NotExpression

ExpressionParser --> Expression : creates

note right of Expression
  æŠ½è±¡è¡¨è¾¾å¼æ¥å£
  æ‰€æœ‰è¡¨è¾¾å¼å¿…é¡»å®ç°interpret
end note

note right of BooleanExpression
  ç»ˆç»“ç¬¦è¡¨è¾¾å¼: å¸ƒå°”å¸¸é‡
end note

note right of VariableExpression
  ç»ˆç»“ç¬¦è¡¨è¾¾å¼: å˜é‡
end note

note right of AndExpression
  éç»ˆç»“ç¬¦è¡¨è¾¾å¼: AND
end note

note right of ExpressionParser
  ç®€å•è¯æ³•åˆ†æå™¨ + è¯­æ³•è§£æå™¨
  æ„å»ºæŠ½è±¡è¯­æ³•æ ‘(AST)
end note

@enduml
```

![](./picture/24.InterpreterPattern.png)